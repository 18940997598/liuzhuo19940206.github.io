<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#333333">
    <meta name="msapplication-TileColor" content="#333333">
    
    
    
    <meta name="keywords" content="Life, ARIA, Hexo, liuzhuo, Cakki, gakki">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#333333">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="解忧杂货店" type="application/atom+xml" />
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-dark.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>Spring Boot与缓存 | 解忧杂货店 - 爱生活爱解忧</title>
  </head>
  <body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"  data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #333333;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">解忧杂货店</a></h1>
        <h2 class="subtitle">爱生活爱解忧</h2>
      </div>
      
      <div class="logo">
        <img src="/images/logo.png" alt="logo">
      </div>
      
    </div>
    <nav id="nav" class="nav">
      <a id="nav-toggle" class="nav-toggle" aria-hidden="true"><i class="fas fa-bars" aria-label="切换导航栏"></i></a>
      <ul id="menu" role="menubar" aria-hidden="false">
        
        <li role="menuitem"><a href="/">首页</a></li>
        
        <li role="menuitem"><a href="/archives/">归档</a></li>
        
        <li role="menuitem"><a href="/categories/">分类</a></li>
        
        <li role="menuitem"><a href="/tags/">标签</a></li>
        
        <li role="menuitem"><a href="/about/">关于</a></li>
        
      </ul>
    </nav>
  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            
<div id="post" class="page">
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://liuzhuo19940206.github.io/2018/11/13/Spring-Boot与缓存/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
       <meta itemprop="name" content="刘卓">
       <meta itemprop="description" content="hello,every body!">
       <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
       <meta itemprop="name" content="解忧杂货店">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">Spring Boot与缓存</h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2018-11-13T10:27:48+08:00">2018-11-13 10:27:48</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/SpringBoot/" itemprop="url" rel="index"><span itemprop="name">SpringBoot</span></a></span><i class="fas fa-angle-right"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/SpringBoot/缓存/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      <p>JSR-107、Spring缓存抽象、整合Redis<br><a id="more"></a></p>
<h2 id="JSR107"><a href="#JSR107" class="headerlink" title="JSR107"></a>JSR107</h2><p>Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry 和 Expiry。</p>
<ol>
<li><p>CachingProvider：定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可<br>以在运行期访问多个CachingProvider。</p>
</li>
<li><p>CacheManager定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache<br>存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。</p>
</li>
<li><p>Cache是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个<br>CacheManager所拥有。</p>
</li>
<li><p>Entry 是一个存储在Cache中的key-value对。</p>
</li>
<li><p>Expiry 每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期<br>的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。</p>
</li>
</ol>
<p><img src="/images/QQ截图20181113103324.png"></p>
<p>JSR107:定义的缓存规范，比较复杂，一般我们很少使用，接下来我们看看Spring的缓存抽象。</p>
<h2 id="Spring缓存抽象"><a href="#Spring缓存抽象" class="headerlink" title="Spring缓存抽象"></a>Spring缓存抽象</h2><p>Spring从3.1开始定义了org.springframework.cache.<strong>Cache</strong>和org.springframework.cache.<strong>CacheManager</strong>接口来统一不同的缓存技术；并支持使用JCache（JSR-107）<strong>注解</strong>简化我们开发；</p>
<ul>
<li><p>Cache接口为缓存的组件规范定义，包含缓存的各种操作集合；</p>
</li>
<li><p>Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache,ConcurrentMapCache等；</p>
</li>
<li><p>每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。</p>
</li>
<li><p>使用Spring缓存抽象时我们需要关注以下两点；</p>
</li>
</ul>
<p>　　1.确定方法需要被缓存以及他们的缓存策略</p>
<p>　　2.从缓存中读取之前缓存存储的数据</p>
<hr>
<p><img src="/images/QQ截图20181113103919.png"></p>
<h2 id="几个重要概念-amp-缓存注解"><a href="#几个重要概念-amp-缓存注解" class="headerlink" title="几个重要概念&amp;缓存注解"></a>几个重要概念&amp;缓存注解</h2><p><img src="/images/QQ截图20181113104138.png"><br><img src="/images/QQ截图20181113104254.png"><br><img src="/images/QQ截图20181113104630.png"></p>
<h2 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h2><ol>
<li><p>引入spring-boot-starter-cache模块</p>
</li>
<li><p>@EnableCaching开启缓存</p>
</li>
<li><p>使用缓存注解</p>
</li>
<li><p>切换为其他缓存</p>
</li>
</ol>
<hr>
<h3 id="搭建基本环境"><a href="#搭建基本环境" class="headerlink" title="搭建基本环境"></a>搭建基本环境</h3><p>1）导入数据库文件，创建出department和employee表：</p>
<p>打开Navicat：mysql客户端。创建本地的数据库spring_cache</p>
<p><img src="/images/QQ截图20181113114130.png"></p>
<p>将spring_cache.sql文件导入到spring_cache数据库中</p>
<p>spring_cache.sql:</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs undefined">SET FOREIGN_KEY_CHECKS=0;<br><br>-- ----------------------------<br>-- Table structure for department<br>-- ----------------------------<br>DROP TABLE IF EXISTS `department`;<br>CREATE TABLE `department` (<br>  `id` int(11) NOT NULL AUTO_INCREMENT,<br>  `departmentName` varchar(255) DEFAULT NULL,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br><br>-- ----------------------------<br>-- Table structure for employee<br>-- ----------------------------<br>DROP TABLE IF EXISTS `employee`;<br>CREATE TABLE `employee` (<br>  `id` int(11) NOT NULL AUTO_INCREMENT,<br>  `lastName` varchar(255) DEFAULT NULL,<br>  `email` varchar(255) DEFAULT NULL,<br>  `gender` int(2) DEFAULT NULL,<br>  `d_id` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure>
<p>导入成功后，会生成 department和employee表。（大家实在不会，手动创建也行）<br><img src="/images/QQ截图20181113114431.png"></p>
<p>2）打开idea创建Springboot项目。选择cache、web、mysql、mybatis模块<br><img src="/images/QQ截图20181113115000.png"><br><img src="/images/QQ截图20181113115035.png"><br><img src="/images/QQ截图20181113115102.png"></p>
<p><img src="/images/QQ截图20181113115139.png"><br><img src="/images/QQ截图20181113150553.png"></p>
<p>3）创建对应的 javaBean对象：（ department 和 employee ）<br><img src="/images/QQ截图20181113150738.png"><br><img src="/images/QQ截图20181113150806.png"></p>
<p>4）配置数据库信息</p>
<p>在application配置文件中：<br><img src="/images/QQ截图20181113151529.png"><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">#数据库连接<br>spring.datasource.url=jdbc:mysql://localhost:3306/spring_cache<br>spring.datasource.username=root<br>spring.datasource.password=123456<br>spring.datasource.driver-class-name=com.mysql.jdbc.Driver<br><br>#mybatis的驼峰命令:dId=d_id<br>mybatis.configuration.map-underscore-to-camel-case=true<br></code></pre></td></tr></table></figure></p>
<p>5) 整合mybatis</p>
<p>创建mapper包：并创建 DepartmentMapper 和 EmployeeMapper</p>
<p>如果不清楚Mybatis与Springboot的整合，去看Springboot的基础里面的数据部分。<a href="https://gakkil.top/2018/11/11/SpringBoot-day-08/#%E6%95%B4%E5%90%88MyBatis" target="_blank" rel="noopener">Mybatis整合</a></p>
<p><img src="/images/QQ截图20181113152057.png"></p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Mapper<br>public interface EmployeeMapper &#123;<br><br>    //获取Employee对象<br>    @Select(&quot;select * from employee where id =#&#123;id&#125;&quot;)<br>    public Employee getEmployeeById(Integer id);<br><br>    //更新Employee对象<br>    @Update(&quot;update employee set lastName=#&#123;lastName&#125;,email=#&#123;email&#125;,gender=#&#123;gender&#125;,d_id=#&#123;dId&#125; where id=#&#123;id&#125;&quot;)<br>    public Employee updateEmployee(Employee employee);<br><br>    //删除employee对象<br>    @Delete(&quot;delete from employee where id=#&#123;id&#125;&quot;)<br>    public void deleteEmployeeById(Integer id);<br><br>    //增加employee对象<br>    @Insert(&quot;insert into employee(lastName,email,gender,d_id) values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;,#&#123;dId&#125;)&quot;)<br>    public void insertEmployee(Employee employee);<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>6) 编写service和controller层：</p>
<p>EmployeeService：<br><img src="/images/QQ截图20181113153826.png"></p>
<p>EmployeeController：<br><img src="/images/QQ截图20181113154057.png"></p>
<p>7）启动应用，验证我们的应用是否成功：</p>
<p>然后在我们的数据库中，随便手动插入一条数据：<br><img src="/images/QQ截图20181113155237.png"></p>
<p>在浏览器中输入：<code>http://localhost:8080/empl/1</code><br><img src="/images/QQ截图20181113155303.png"></p>
<p><strong>PS：如果控制台出现Establishing SSL警告</strong>：是因为在MYSQL5.5.45+, 5.6.26+ and 5.7.6+版本中需要携带服务器身份验证的SSL连接。<br>解决办法：<br>1）在数据库连接的url中添加useSSL=false;（不使用ssl连接）<br>2）url中添加useSSL=true，并且提供服务器的验证证书。</p>
<p>我们这里就直接不使用了，在url后面加上？useSSL=false即可。<br><code>spring.datasource.url=jdbc:mysql://localhost:3306/spring_cache?useSSL=false</code></p>
<h3 id="缓存的快速体验"><a href="#缓存的快速体验" class="headerlink" title="缓存的快速体验"></a>缓存的快速体验</h3><p>步骤：</p>
<p>1）开启缓存的注解，@EnableCaching<br>2）使用缓存的注解来添加缓存的功能</p>
<hr>
<p>在没有使用缓存的时候，每次发送请求都会到数据库中，查询数据：<br>现在，给EmployeeService添加输出语句：<br><img src="/images/QQ截图20181113162215.png"><br>修改日志的级别：<br>logging.level.com.liuzhuo.cache=debug</p>
<p>启动Springboot应用：在浏览器中输入：<code>http://localhost:8080/empl/1</code><br><img src="/images/QQ截图20181113162510.png"><br><img src="/images/QQ截图20181113162536.png"></p>
<p>刷新页面，还是会打印出 输出语句 和 sql的查询信息。<br><img src="/images/QQ截图20181113162657.png"></p>
<hr>
<p>使用缓存：</p>
<p>1）给启动类上面，加上@EnableCaching<br><img src="/images/QQ截图20181113162019.png"></p>
<p>2）给 EmployeeService 中 findEmployeeById 方法添加缓存的注解:( @Cacheable ）<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class EmployeeService &#123;<br><br>    @Autowired<br>    private EmployeeMapper employeeMapper;<br><br>    //获取Employee对象<br><br>    /**<br>     *  Cacheable:查询时候缓存，第一次会到数据库中查询数据，以后都只会到<br>     *  缓存中获取数据。<br>     *  几个重要的属性：<br>     *   1）cacheName/value: 指定缓存组件的名字。<br>     *   2）key：缓存数据使用的key。默认是使用方法参数的值，比如这里id=1的话，默认key=1<br>     *           可以使用SpEl表达式：#id获取的参数的值，#a0 #p0都是获取第一个参数的值<br>     *           #root.args[0]:也是获取第一个参数的值<br>     *   3）keyGenerator:key的生成器，可以自己指定key的生成器的组件的id<br>     *            key或keyGenerator：二选一<br>     *   4) cacheManager:指定缓存管理器<br>     *   5) cacheResolver:指定缓存解析器。和cacheManager二选一<br>     *   6) condition:指定符合条件的情况下，才缓存数据.<br>     *             可以使用SpEl表达式：condition=&quot;#id&gt;5&quot;<br>     *   7) unless:否定缓存，与condition作用相反<br>     *   8) sync:是否使用异步模式<br>     */<br>    @Cacheable<br>    public Employee findEmployeeById(Integer id) &#123;<br>        System.out.println(&quot;查询:&quot;+id+&quot;号的信息&quot;);<br>        return employeeMapper.getEmployeeById(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>3）启动SpringBoot应用：</p>
<p>在浏览器中输入：<code>http://localhost:8080/empl/1</code></p>
<p>只有第一次会打印 输出语句。之后都不会打印输出语句，说明数据已经被缓存到缓存当中了。</p>
<hr>
<h3 id="SpringBoot的缓存原理："><a href="#SpringBoot的缓存原理：" class="headerlink" title="SpringBoot的缓存原理："></a>SpringBoot的缓存原理：</h3><p>1）打开CacheAutoConfiguration：</p>
<p><img src="/images/QQ截图20181113171128.png"></p>
<p>2）观察导入@Import(CacheConfigurationImportSelector.class)<br><img src="/images/QQ截图20181113171308.png"></p>
<p>3）CacheConfigurationImportSelector帮我们缓存了哪些类呢？</p>
<p>打上断点，debug一下：<br><img src="/images/QQ截图20181113171503.png"><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration<br>org.springframework.boot.autoconfigure.cache.JCacheCacheConfiguration<br>org.springframework.boot.autoconfigure.cache.EhCacheCacheConfiguration<br>org.springframework.boot.autoconfigure.cache.HazelcastCacheConfiguration<br>org.springframework.boot.autoconfigure.cache.InfinispanCacheConfiguration<br>org.springframework.boot.autoconfigure.cache.CouchbaseCacheConfiguration<br>org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration<br>org.springframework.boot.autoconfigure.cache.CaffeineCacheConfiguration<br>org.springframework.boot.autoconfigure.cache.GuavaCacheConfiguration<br>org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration<br>org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration<br></code></pre></td></tr></table></figure></p>
<p>4)而注入的这里类，哪些会生效呢？</p>
<p>Application配置：debug=true.</p>
<p>发现：只有 SimpleCacheConfiguration 生效。<br><img src="/images/QQ截图20181113171946.png"></p>
<p>5）SimpleCacheConfiguration给容器中注入了一个cacheManager：ConcurrentMapCacheManager<br><img src="/images/QQ截图20181113172101.png"><br><img src="/images/QQ截图20181113172457.png"></p>
<p>6）ConcurrentMapCacheManager：实质上就是一个ConcurrentHashMap。</p>
<p>然后使用ConcurrentMapCache（实质ConcurrentMap）将数据保存在ConcurrentMap中。</p>
<hr>
<h3 id="缓存的运行流程"><a href="#缓存的运行流程" class="headerlink" title="缓存的运行流程"></a>缓存的运行流程</h3><p>给 EmployeeService 的 findEmployeeById 方法 打上断点：<br><img src="/images/QQ截图20181113173709.png"></p>
<p>给 ConcurrentMapCacheManager getCache 方法 打上断点：<br><img src="/images/QQ截图20181113173817.png"></p>
<p>给 ConcurrentMapCache 的lookup、get、set 打上断点：<br><img src="/images/QQ截图20181113173929.png"><br><img src="/images/QQ截图20181113173941.png"></p>
<p>debug运行一下：</p>
<p>在浏览器中输入：<code>http://localhost:8080/empl/1</code></p>
<p>进入断点处：</p>
<p>当首次进入该方法时，不会执行该方法，会先进入缓存中获取数据<br>根据 cacheNames/value 来获取cache。<br>这里 cacheNames=’empl’<br><img src="/images/QQ截图20181113183208.png"></p>
<p>第一次查询，名称为empl的’cache’一定是null，所以会创建名称为’empl’的cache<br><img src="/images/QQ截图20181113183458.png"><br><img src="/images/QQ截图20181113183641.png"></p>
<p>创建’empl’的cache成功后，这里的cache就是ConcurrentMapCache，放到ConcurrentMapCacheManager中。<br><img src="/images/QQ截图20181113183804.png"></p>
<p>然后在ConcurrentMapCache中，寻找key等于我们默认参数值的value值：<br><img src="/images/QQ截图20181113184208.png"></p>
<p>没有找key=1的缓存值，所以执行 findEmployeeById 方法：<br><img src="/images/QQ截图20181113184329.png"></p>
<p>从数据库中获取数据，将数据放到缓存当中。<br><img src="/images/QQ截图20181113184515.png"></p>
<hr>
<p>当再次，刷新页面时。</p>
<p>name=’empl’的cache已经存在了<br><img src="/images/QQ截图20181113184712.png"></p>
<p>然后在name=’empl’的cache中寻找key=1的缓存：<br><img src="/images/QQ截图20181113184920.png"></p>
<p>然后直接就找到了key=1的缓存了，直接返回对象，不在执行 findEmployeeById 方法了。</p>
<p>直接来了到控制层，return语句，返回视图。<br><img src="/images/QQ截图20181113185435.png"></p>
<p><strong>总结：@cacheable标注的方法执行之前，先来检查缓存中有么有我们的定义的name的cache缓存，按照默认的key生成策略的值去查询对应的缓存，如果没有就运行该方法，并放入缓存中。以后调用就直接使用缓存中的数据。</strong></p>
<p>核心：</p>
<p>1）使用cacheManager[ConcurrentMapCacheManager]按照名字name来获取cache[ConcurrentMapCache]组件</p>
<p>2）key使用keyGenerator生成的，默认是SimpleGenerator。</p>
<p>3）cache使用生成的key来获取缓存或者放入缓存当中。</p>
<h3 id="Cacheable属性的使用"><a href="#Cacheable属性的使用" class="headerlink" title="@Cacheable属性的使用"></a>@Cacheable属性的使用</h3><p>1）cacheNames/value: 指定缓存组件的名字。<br><img src="/images/QQ截图20181113192119.png"></p>
<p>是数组的属性，所以是花括号的形式：cacheNames = {“empl”} 或 value={“empl”}</p>
<p>2）key：缓存数据使用的key。</p>
<p>默认是使用方法参数的值，比如这里id的值为1的话，key就等于1<br><img src="/images/QQ截图20181113192337.png"></p>
<p>多个参数的话，key默认就是 SimpleKey [参数值1，参数值2]</p>
<p>SimpleKey [1,jack]<br><img src="/images/QQ截图20181113192725.png"></p>
<p>还可以使用SpEl表达式：</p>
<p><code>#id获取的参数的值。id就是参数的名字</code>：key=1.</p>
<p><code>#a0、#p0 都是获取第一个参数的值，#a1 就是获取第二参数的值</code></p>
<p> <code>#root.args[0]:也是获取第一个参数的值</code></p>
<p>举例：如果想要生成 方法名+参数值 的 key。比如这里的 findEmployeeById[1]</p>
<p>key = “#root.methodName+’[‘+#id+’]’”<br><img src="/images/QQ截图20181113193620.png"><br><img src="/images/QQ截图20181113193828.png"></p>
<p>3）keyGenerator: key的生成器，可以自己指定key的生成器的组件的id</p>
<p><strong>key 或 keyGenerator：二选一</strong></p>
<p>现在在config下，创建CacheConfig类：<br><img src="/images/QQ截图20181113194259.png"><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class CacheConfig &#123;<br><br>    @Bean(&quot;myKeyGenerator&quot;)<br>    public KeyGenerator keyGenerator()&#123;<br>        return new KeyGenerator() &#123;<br>            @Override<br>            public Object generate(Object o, Method method, Object... objects) &#123;<br>                return method.getName()+&quot;[&quot;+ Arrays.asList(objects)+&quot;]&quot;;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>注意这里的 KeyGenerator：org.springframework.cache.interceptor.KeyGenerator</p>
<p>然后，在 keyGenerator = “myKeyGenerator” ：填写key的生成器的bean的id<br><img src="/images/QQ截图20181113194347.png"></p>
<p>debug下：<br><img src="/images/QQ截图20181113194813.png"></p>
<p>4) cacheManager:指定缓存管理器</p>
<p> 以后整合其他缓存框架时，使用。</p>
<p>5) cacheResolver:指定缓存解析器。和cacheManager二选一</p>
<p>6) condition:指定符合条件的情况下，才缓存数据.</p>
<p>可以使用SpEl表达式：condition=”#id&gt;5”. 当参数值大于5时，才会缓存数据。</p>
<p>7) unless:否定缓存，<strong>与condition作用相反</strong></p>
<p>unless = “#id&lt;2” 的话，就是参数值小于2时，不缓存</p>
<p>8) sync:是否使用异步模式</p>
<p>不过，当使用sync的话，unless是不能使用的。</p>
<h3 id="CachePut的使用"><a href="#CachePut的使用" class="headerlink" title="@CachePut的使用"></a>@CachePut的使用</h3><p>@CachePut：是用来更新缓存的，始终是先执行方法，然后更新缓存。</p>
<p>1）在 EmployeeService 添加 更新employee的方法：<br><img src="/images/QQ截图20181113204129.png"></p>
<p>2）在 EmployeeController 添加 更新employee的映射方法：<br><img src="/images/QQ截图20181113203603.png"></p>
<p>3）启动程序。</p>
<p>首先：输入：<code>http://localhost:8080/empl/1</code> : 查询1号员工的信息<br><img src="/images/QQ截图20181113203724.png"><br><img src="/images/QQ截图20181113203745.png"></p>
<p>再次，访问1号员工的信息：</p>
<p>控制台，什么也不打印，但是界面有数据，说明，我们缓存数据成功！</p>
<p>现在，我们修改1号员工的信息：输入：<code>http://localhost:8080/empl?id=1&amp;lastName=zhangsan&amp;gender=0</code></p>
<p>我们就修改了性别，从1变成0.<br><img src="/images/QQ截图20181113204245.png"><br><img src="/images/QQ截图20181113204305.png"><br><img src="/images/QQ截图20181113204337.png"></p>
<p>更新成功！！！</p>
<hr>
<p>现在，我们再次，访问1号员工的信息，是从缓存中取？还是从数据库中取呢？如果从缓存中取，是旧的数据，还是新的数据？</p>
<p>反正，我们的最终目的是现在获取更新后的1号员工的信息。</p>
<p>我们来，测试一下，访问1号员工的信息：<code>http://localhost:8080/empl/1</code></p>
<p>发现，控制台没有打印输出语句，说明现在还是从缓存中取数据。但是好像返回的数据是旧的？<br><img src="/images/QQ截图20181113204707.png"></p>
<p>这是为啥呢？ 因为，虽然我们的获取缓存的名字 和 更新缓存的缓存的名字 都是empl。但是key不同呀！！！<br><img src="/images/QQ截图20181113204927.png"></p>
<p>所以，现在名字为’empl’的cache中，有两个缓存，一个是key=1的缓存，另一个key=employee值的缓存。所以现在获取的是key=1的缓存(旧的数据)</p>
<p><strong>要想达到我们想要的效果，必须key一致！！！</strong><br><img src="/images/QQ截图20181113205251.png"></p>
<p><strong>注意：@Cacheable的key，不能使用#result，因为@Cacheable是先执行缓存，再执行方法，而@CachePut总是先执行方法，再执行缓存。</strong></p>
<hr>
<p>重启应用，再次测试一次：</p>
<p>先访问1号员工：<code>http://localhost:8080/empl/1</code><br><img src="/images/QQ截图20181113205902.png"></p>
<p>再修改1号员工：<code>http://localhost:8080/empl?id=1&amp;lastName=张三&amp;gender=0&amp;email=zhangsan@qq.com</code><br><img src="/images/QQ截图20181113205710.png"></p>
<p>再次访问1号员工：<code>http://localhost:8080/empl/1</code><br><img src="/images/QQ截图20181113205937.png"></p>
<p>到达，我们的效果！！！</p>
<p><strong>注意：这里我们的缓存的name是一致的，都是’empl’才行，如果你更改了name，不一致的话，效果就达不到了，原因， 你懂的</strong></p>
<p><strong>PS：如果张三在数据库中看是乱码的话，需要在数据库连接中添加 &amp;characterEncoding=utf-8：</strong></p>
<p><strong>spring.datasource.url=jdbc:mysql://localhost:3306/spring_cache?useSSL=false&amp;characterEncoding=utf-8</strong></p>
<h3 id="CacheEvict的使用"><a href="#CacheEvict的使用" class="headerlink" title="@CacheEvict的使用"></a>@CacheEvict的使用</h3><p>@CacheEvict：是用来删除缓存的。</p>
<p>通过key：来删除指定的缓存。</p>
<p>allEntries = true. 删除所有的缓存，默认是为false。<br>当allEntries = true，就不用指定key了。</p>
<p>beforeInvocation = true。先清空缓存，再执行方法。默认是为false。<br>作用：默认情况下，当方法出现异常，缓存就不会清除。当beforeInvocation = true时，不管方法是否出现异常，都会清除缓存。 </p>
<h3 id="Caching的使用"><a href="#Caching的使用" class="headerlink" title="@Caching的使用"></a>@Caching的使用</h3><p>@Caching：组合注解：<br><img src="/images/QQ截图20181113213321.png"><br><img src="/images/QQ截图20181113213634.png"></p>
<h3 id="CacheConfig的使用"><a href="#CacheConfig的使用" class="headerlink" title="@CacheConfig的使用"></a>@CacheConfig的使用</h3><p>@CacheConfig：是作用在<strong>类上面的</strong>，相当于全局配置。<br><img src="/images/QQ截图20181113213950.png"></p>
<p>此时，就不需要在每个方法上的缓存注解中，写cacheNames=’empl’. 如果写了，就使用方法上面的cacheNames。</p>
<h2 id="整合Redis缓存"><a href="#整合Redis缓存" class="headerlink" title="整合Redis缓存"></a>整合Redis缓存</h2><h3 id="搭建redis环境"><a href="#搭建redis环境" class="headerlink" title="搭建redis环境"></a>搭建redis环境</h3><p>1）使用我们安装的虚拟机工具安装Redis</p>
<p>如果不清楚的话，看之前的SpringBoot基础篇，<a href="https://gakkil.top/2018/11/09/SpringBoot-day-07/#%E5%AE%89%E8%A3%85linux%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">docker学习</a></p>
<p>打开虚拟机：<br><img src="/images/QQ截图20181114100415.png"></p>
<p>打开连接虚拟机的客户端：SmarTTY<br><img src="/images/QQ截图20181114100537.png"><br><img src="/images/QQ截图20181114100653.png"></p>
<p>在docker hub中搜索Redis的镜像<br><img src="/images/QQ截图20181114101037.png"></p>
<p>docker官方的镜像在国外，下载镜像会很慢，所以使用国内的docker镜像：<a href="https://www.docker-cn.com/" target="_blank" rel="noopener">https://www.docker-cn.com/</a><br><img src="/images/QQ截图20181114101241.png"><br><img src="/images/QQ截图20181114101523.png"><br><img src="/images/QQ截图20181114101749.png"></p>
<p>运行我们下载的redis镜像：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">docker run -d -p 6379:6379 --name myredis registry.docker-cn.com/library/redis<br></code></pre></td></tr></table></figure></p>
<p><img src="/images/QQ截图20181114102027.png"><br><img src="/images/QQ截图20181114102152.png"></p>
<p>2) 打开redis的客户端：RedisDesktopManager（自行下载）<br><img src="/images/QQ截图20181114102449.png"><br><img src="/images/QQ截图20181114102754.png"></p>
<p>默认redis：16个数据库<br><img src="/images/QQ截图20181114102848.png"></p>
<p>3）简单试试redis的命令</p>
<p>在myredis上面，右键选择：Console<br><img src="/images/QQ截图20181114103104.png"></p>
<p>打开redis中文网：<a href="http://www.redis.cn/" target="_blank" rel="noopener">http://www.redis.cn/</a><br><img src="/images/QQ截图20181114103332.png"></p>
<p>以String类型为例：<br><img src="/images/QQ截图20181114103450.png"></p>
<p>其他命令，请读者自行学习啦~</p>
<h3 id="整合redis"><a href="#整合redis" class="headerlink" title="整合redis"></a>整合redis</h3><p>SpringBoot，默认的配置类是：SimpleCacheConfiguration</p>
<p>默认使用的CacheManager：ConcurrentMapCacheManager</p>
<p>默认使用的Cache：ConcurrentMapCache</p>
<p>现在，整合redis到SpringBoot中。</p>
<p>1）导入redis的stars依赖</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>
<p>2) 在Application配置文件中，添加redis的连接<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">#设置redis的连接<br>spring.redis.host=10.6.11.17<br></code></pre></td></tr></table></figure></p>
<p>这里的 host: 写你自己的虚拟机的ip地址。</p>
<p>3）打开RedisAutoConfiguration<br><img src="/images/QQ截图20181114115036.png"></p>
<p>发现：导入了两个模板类，方便我们操作。</p>
<p>4）在SpringBoot01CacheApplicationTests类中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RunWith(SpringRunner.class)<br>@SpringBootTest<br>public class SpringBoot01CacheApplicationTests &#123;<br><br>	@Autowired<br>	private EmployeeMapper employeeMapper;<br><br>	@Autowired<br>	private RedisTemplate redisTemplate;  //操作k-v，都是对象的<br><br>	@Autowired<br>	private StringRedisTemplate stringRedisTemplate; //操作k-v：k是字符串的<br><br>	/**<br>	 * redis:5种数据结构：<br>	 * 字符串String，list（列表），hash（哈希），set（集合），ZSet（有序集合）<br>	 * opsForValue()：String<br>	 * opsForList():list<br>	 * opsForHash():hash<br>	 * opsForSet():set<br>	 * opsForZSet():ZSet<br>	 */<br>	@Test<br>	public void test01()&#123;<br>		stringRedisTemplate.opsForValue().append(&quot;mgs&quot;,&quot;hello&quot;);<br>	&#125;<br><br><br>	@Test<br>	public void contextLoads() &#123;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>清空：redis中的数据。执行test01<br><img src="/images/QQ截图20181114115954.png"><br><img src="/images/QQ截图20181114120032.png"></p>
<p>其他命令，自行执行测试。</p>
<p>现在测试RedisTemplate：</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test02() &#123;<br>    Employee employee = employeeMapper.getEmployeeById(1);<br>    //将对象放入到redis中<br>    redisTemplate.opsForValue().set(&quot;empl&quot;, employee);<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行测试方法：<br><img src="/images/QQ截图20181114125203.png"></p>
<p>出现无法序列化异常，因为对象保存到redis中，是以序列化的形式。而我们的Employee没有实现序列化。<br><img src="/images/QQ截图20181114125342.png"></p>
<p>再次运行：<br><img src="/images/QQ截图20181114125447.png"><br><img src="/images/QQ截图20181114125504.png"></p>
<p>虽然成功了，但是是序列化的形式，看着不爽。</p>
<p>默认是jdk的序列化形式：<br><img src="/images/QQ截图20181114125648.png"></p>
<p>我们可以自定义自己的序列化方式：</p>
<p>使用我们自己的redis模板，设置自己的json的序列化形式：</p>
<p>在config包下：<br><img src="/images/QQ截图20181114130144.png"></p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class RedisConfig &#123;<br><br>    @Bean(&quot;myRedisTemplate&quot;)<br>    public RedisTemplate&lt;Object, Employee&gt; redisTemplate(<br>            RedisConnectionFactory redisConnectionFactory)<br>            throws UnknownHostException &#123;<br>        RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;Object, Employee&gt;();<br>        template.setConnectionFactory(redisConnectionFactory);<br>        //使用json的序列化<br>        Jackson2JsonRedisSerializer&lt;Employee&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);<br>        template.setDefaultSerializer(redisSerializer);<br>        return template;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用自己的redis模板：<br><img src="/images/QQ截图20181114130400.png"><br><img src="/images/QQ截图20181114130459.png"></p>
<p>运行test03方法：<br><img src="/images/QQ截图20181114130554.png"></p>
<p>以上我们的redis已经整合成功了。</p>
<hr>
<h3 id="使用redis缓存"><a href="#使用redis缓存" class="headerlink" title="使用redis缓存"></a>使用redis缓存</h3><p>我们知道，SpringBoot默认使用：SimpleCacheConfiguration</p>
<p>导入redis-starter后，就会使用 RedisAutoConfiguration。</p>
<p>然后默认使用：RedisTemplate模板。</p>
<p>现在直接启动SpringBoot应用：</p>
<p>在浏览器中输入：<code>http://localhost:8080/empl/1</code></p>
<p><img src="/images/QQ截图20181114133854.png"><br><img src="/images/QQ截图20181114133941.png"></p>
<p>再次输入：<code>http://localhost:8080/empl/1</code></p>
<p>会从缓存中获取数据，控制台不会打印sql语句。</p>
<p><img src="/images/QQ截图20181114134141.png"></p>
<p>不是我们想要的序列化形式：</p>
<p>我们需要自己配置RedisCacheManager：</p>
<p>打开：RedisCacheConfiguration类：</p>
<p>发现默认的RedisCacheManager：<br><img src="/images/QQ截图20181114194646.png"></p>
<p>现在在我们的RedisConfig类：<br><img src="/images/QQ截图20181114195041.png"><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class RedisConfig &#123;<br><br>    @Bean(&quot;employeeRedisTemplate&quot;)<br>    public RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate(<br>            RedisConnectionFactory redisConnectionFactory)<br>            throws UnknownHostException &#123;<br>        RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;Object, Employee&gt;();<br>        template.setConnectionFactory(redisConnectionFactory);<br>        Jackson2JsonRedisSerializer&lt;Employee&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);<br>        template.setDefaultSerializer(redisSerializer);<br>        return template;<br>    &#125;<br><br>    @Bean<br>    public RedisCacheManager cacheManager(RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate) &#123;<br>        RedisCacheManager cacheManager = new RedisCacheManager(employeeRedisTemplate);<br>        //设置是否使用前缀，前缀就是cacheNames。<br>        cacheManager.setUsePrefix(true);<br><br>        return cacheManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>我们配置了自己的RedisCacheManager，默认的就会失效，因为：<br><img src="/images/QQ截图20181114200708.png"></p>
<p>现在，我们使用department来测试：编写departmentMapper，departmentService，departmentController：</p>
<p>DepartmentMapper：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Mapper<br>public interface DepartmentMapper &#123;<br><br>    @Select(&quot;select * from department where id=#&#123;id&#125;&quot;)<br>    public Department getDeptById(Integer id);<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>DepartmentService:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class DepartmentService &#123;<br><br>    @Autowired<br>    private DepartmentMapper departmentMapper;<br><br>    @Cacheable(cacheNames = &quot;dept&quot;)<br>    public Department getDeptById(Integer id)&#123;<br>        return departmentMapper.getDeptById(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>DepartmentController:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RestController<br>public class DepartmentController &#123;<br><br>    @Autowired<br>    private DepartmentService departmentService;<br><br>    @GetMapping(&quot;/dept/&#123;id&#125;&quot;)<br>    public Department getDeptById(@PathVariable(&quot;id&quot;) Integer id) &#123;<br>        return departmentService.getDeptById(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>启动应用：</p>
<p>清空redis数据库。</p>
<p>在浏览器中输入：<code>http://localhost:8080/empl/1</code></p>
<p>第一次查询，会从数据库中查询数据，然后放到缓存中。</p>
<p><img src="/images/QQ截图20181114200147.png"><br><img src="/images/QQ截图20181114200157.png"></p>
<p>此时redis数据库中，是以json啦来序列化的。<br><img src="/images/QQ截图20181114200358.png"></p>
<p>再次：访问<code>http://localhost:8080/empl/1</code>，控制台不会打印sql语句，说明是从缓存中取的。</p>
<p>现在，我们来测试department。在mysql客户端中，自己手动插入一条数据：<br><img src="/images/QQ截图20181114201053.png"></p>
<p>在浏览器中输入：<code>http://localhost:8080/dept/1</code></p>
<p>第一次，会从数据库中获取数据。控制台打印sql语句。将数据放到redis缓存中。<br><img src="/images/QQ截图20181114201003.png"><br><img src="/images/QQ截图20181114201147.png"><br><img src="/images/QQ截图20181114201226.png"></p>
<p>当再次访问：<code>http://localhost:8080/dept/1</code>，照理应该会把department的json数据反序列化到前端，不到mysql数据库中查找。</p>
<p>但是出错了！！！<br><img src="/images/QQ截图20181114201422.png"></p>
<p>看出错的异常，是我们居然是把department的json数据反序列化到employee对象上面，当然出错呀！</p>
<p>打开我们的cacheConfig类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class RedisConfig &#123;<br><br>    @Bean(&quot;employeeRedisTemplate&quot;)<br>    public RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate(<br>            RedisConnectionFactory redisConnectionFactory)<br>            throws UnknownHostException &#123;<br>        RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;Object, Employee&gt;();<br>        template.setConnectionFactory(redisConnectionFactory);<br>        Jackson2JsonRedisSerializer&lt;Employee&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);<br>        template.setDefaultSerializer(redisSerializer);<br>        return template;<br>    &#125;<br><br>    @Bean<br>    public RedisCacheManager cacheManager(RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate) &#123;<br>        RedisCacheManager cacheManager = new RedisCacheManager(employeeRedisTemplate);<br>        //设置是否使用前缀，前缀就是cacheNames。<br>        cacheManager.setUsePrefix(true);<br><br>        return cacheManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>我们的序列化泛型就是Employee对象，所以只能对Employee反序列化成功。</p>
<p>现在添加新的 RedisCacheManager 和 RedisTemplate<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class RedisConfig &#123;<br><br>    @Bean(&quot;employeeRedisTemplate&quot;)<br>    public RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate(<br>            RedisConnectionFactory redisConnectionFactory)<br>            throws UnknownHostException &#123;<br>        RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;Object, Employee&gt;();<br>        template.setConnectionFactory(redisConnectionFactory);<br>        Jackson2JsonRedisSerializer&lt;Employee&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);<br>        template.setDefaultSerializer(redisSerializer);<br>        return template;<br>    &#125;<br><br>    @Bean(&quot;departmentRedisTemplate&quot;)<br>    public RedisTemplate&lt;Object, Department&gt; departmentRedisTemplate(<br>            RedisConnectionFactory redisConnectionFactory)<br>            throws UnknownHostException &#123;<br>        RedisTemplate&lt;Object, Department&gt; template = new RedisTemplate&lt;Object, Department&gt;();<br>        template.setConnectionFactory(redisConnectionFactory);<br>        Jackson2JsonRedisSerializer&lt;Department&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Department&gt;(Department.class);<br>        template.setDefaultSerializer(redisSerializer);<br>        return template;<br>    &#125;<br><br>    @Bean(&quot;employeeCacheManager&quot;)<br>    public RedisCacheManager employeeCacheManager(RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate) &#123;<br>        RedisCacheManager cacheManager = new RedisCacheManager(employeeRedisTemplate);<br>        //设置是否使用前缀，前缀就是cacheNames。<br>        cacheManager.setUsePrefix(true);<br>        return cacheManager;<br>    &#125;<br><br>    @Bean(&quot;departmentCacheManager&quot;)<br>    public RedisCacheManager departmentCacheManager(RedisTemplate&lt;Object, Department&gt; departmentRedisTemplate) &#123;<br>        RedisCacheManager cacheManager = new RedisCacheManager(departmentRedisTemplate);<br>        //设置是否使用前缀，前缀就是cacheNames。<br>        cacheManager.setUsePrefix(true);<br>        return cacheManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>现在在EmployeeService中，设置CacheManager：</p>
<p>在类上面的，@CacheConfig中设置统一的CacheManager<br><img src="/images/QQ截图20181114202147.png"></p>
<p>在DepartmentService：<br><img src="/images/QQ截图20181114202330.png"></p>
<p>这样，Employee 和 Department 就会使用各自的CacheManager。</p>
<p>删除Redis中的所有数据。再次测试一下，启动应用。</p>
<p>启动应用的过程中，出错了！你敢信，我们看看<br><img src="/images/QQ截图20181114202538.png"></p>
<p>原来是，我们设置了两个CacheManager，需要确定一个默认的CacheManager。所以我们使用默认的CacheManager当做默认的。</p>
<p>在redisConfig中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class RedisConfig &#123;<br><br>    @Bean(&quot;employeeRedisTemplate&quot;)<br>    public RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate(<br>            RedisConnectionFactory redisConnectionFactory)<br>            throws UnknownHostException &#123;<br>        RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;Object, Employee&gt;();<br>        template.setConnectionFactory(redisConnectionFactory);<br>        Jackson2JsonRedisSerializer&lt;Employee&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);<br>        template.setDefaultSerializer(redisSerializer);<br>        return template;<br>    &#125;<br><br>    @Bean(&quot;departmentRedisTemplate&quot;)<br>    public RedisTemplate&lt;Object, Department&gt; departmentRedisTemplate(<br>            RedisConnectionFactory redisConnectionFactory)<br>            throws UnknownHostException &#123;<br>        RedisTemplate&lt;Object, Department&gt; template = new RedisTemplate&lt;Object, Department&gt;();<br>        template.setConnectionFactory(redisConnectionFactory);<br>        Jackson2JsonRedisSerializer&lt;Department&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Department&gt;(Department.class);<br>        template.setDefaultSerializer(redisSerializer);<br>        return template;<br>    &#125;<br><br>    @Bean(&quot;employeeCacheManager&quot;)<br>    public RedisCacheManager employeeCacheManager(RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate) &#123;<br>        RedisCacheManager cacheManager = new RedisCacheManager(employeeRedisTemplate);<br>        //设置是否使用前缀，前缀就是cacheNames。<br>        cacheManager.setUsePrefix(true);<br>        return cacheManager;<br>    &#125;<br><br>    @Bean(&quot;departmentCacheManager&quot;)<br>    public RedisCacheManager departmentCacheManager(RedisTemplate&lt;Object, Department&gt; departmentRedisTemplate) &#123;<br>        RedisCacheManager cacheManager = new RedisCacheManager(departmentRedisTemplate);<br>        //设置是否使用前缀，前缀就是cacheNames。<br>        cacheManager.setUsePrefix(true);<br>        return cacheManager;<br>    &#125;<br><br>    //默认的CacheManager,设置优先级最高<br>    //即，当不配置cacheManager=&quot;xxxx&quot;的时候，就使用这个缓存管理器<br>    @Primary<br>    @Bean<br>    public RedisCacheManager cacheManager(RedisTemplate&lt;Object, Object&gt; redisTemplate) &#123;<br>        RedisCacheManager cacheManager = new RedisCacheManager(redisTemplate);<br>        cacheManager.setUsePrefix(true);<br>        return cacheManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>重启应用：</p>
<p>应用启动成功，没有出错。</p>
<p>在浏览器中输入：<code>http://localhost:8080/empl/1</code></p>
<p>控制台打印sql语句，是到mysql数据库查询数据<br><img src="/images/QQ截图20181114203139.png"></p>
<p>再次访问：<code>http://localhost:8080/empl/1</code></p>
<p>控制台不打印sql语句，是从redis缓存中取数据。</p>
<p>在浏览器中输入：<code>http://localhost:8080/dept/1</code></p>
<p>控制台输出sql语句，是到mysql数据库中查询数据<br><img src="/images/QQ截图20181114203418.png"></p>
<p>再次访问：<code>http://localhost:8080/dept/1</code></p>
<p>不报错了，控制台不输出sql语句，是在redi数据库中获取数据。</p>
<p>以上就是整合 redis 到 SpringBoot 中。</p>
<hr>
<h3 id="使用编码的方式来使用Redis"><a href="#使用编码的方式来使用Redis" class="headerlink" title="使用编码的方式来使用Redis"></a>使用编码的方式来使用Redis</h3><p>以上都是使用注解的方式来使用缓存，现在我们来使用编码的方式来操作缓存。</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//@CacheConfig(cacheManager = &quot;departmentCacheManager&quot;)<br>@Service<br>public class DepartmentService &#123;<br><br>    @Autowired<br>    private DepartmentMapper departmentMapper;<br><br>    @Autowired<br>    private RedisTemplate departmentRedisTemplate;<br><br>    //@Cacheable(cacheNames = &quot;dept&quot;)<br>    public Department getDeptById(Integer id)&#123;<br>        Department department = departmentMapper.getDeptById(id);<br>        departmentRedisTemplate.opsForValue().set(&quot;dept&quot;+id,&quot;department&quot;);<br>        return department;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>将cahce的注解都注释掉，然后注入departmentRedisTemplate。</p>
<p>自己手动操作缓存。</p>
<p>重启应用，在浏览器中输入：<code>http://localhost:8080/dept/1</code><br><img src="/images/QQ截图20181114204406.png"></p>

    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/缓存/" rel="tag"><i class="fas fa-tags"></i>缓存</a>
        
        <a class="post-tag button" href="/tags/SpringBoot/" rel="tag"><i class="fas fa-tags"></i>SpringBoot</a>
        
      </div>
      
    </footer>
  </article>
  
  
<div class="reward" id="reward">
  <p>坚持原创技术分享，您的支持是我前进的动力！</p>
  <button id="reward-button" class="button" disable="enable">打赏</button>
  <div id="qr" class="qr" style="display: none;" aria-hidden="true">
    
    <div id="wechat">
      <img id="wechat_qr" src="/images/WeChatPay.png" alt="微信支付"/>
      <span>微信支付</span>
    </div>
    
    
    <div id="alipay">
      <img id="alipay_qr" src="/images/AliPay.png" alt="支付宝"/>
      <span>支付宝</span>
    </div>
    
    
  </div>
</div>


  
  
  <nav class="page-nav">
    <div class="page-nav-next page-nav-item">
      
      <a href="/2018/11/12/SpringBoot-day-09/" rel="next" title="SpringBoot_day_09"><i class="fas fa-angle-left"></i><span class="nav-title">SpringBoot_day_09</span></a>
      
    </div>
    <div class="page-nav-prev page-nav-item">
      
      <a href="/2018/11/15/Spring-Boot与消息/" rel="prev" title="Spring Boot与消息"><span class="nav-title">Spring Boot与消息</span><i class="fas fa-angle-right"></i></a>
      
    </div>
  </nav>
  
  
  

<div class="comments" id="comments">
  
  
  <div class="commentjs" id="comment-thread"></div>
  <link rel="stylesheet" href="/css/commentjs.css">
  <script defer type="text/javascript" src="/js/marked.min.js"></script>
  <script defer type="text/javascript" src="/js/timeago.min.js"></script>
  <script defer type="text/javascript" src="/js/highlight.min.js"></script>
  <script defer type="text/javascript" src="/js/commentjs.js"></script>
  <script type="text/javascript">
  $(document).ready(function () {
    getComments({
      "type": "github",
      "user": "liuzhuo19940206",
      "repo": "liuzhuo19940206.github.io",
      "client_id": "d67adf7d637efbea7a69",
      "client_secret": "e3958a48de708ffda0c1ff603f8b48793d43d1ae",
      "no_comment": "这个页面还没有评论，现在就去评论吧！",
      "go_to_comment": "去评论",
      "issue_title": "Spring Boot与缓存",
      "btn_class": "button",
      "comments_target": "#comment-thread"
    });
    marked.setOptions({
      "highlight": function (code, lang) {
        return hljs.highlightAuto(code).value;
      }
    });
    function mark() {
      var markdowns = document.getElementsByClassName("markdown");
      for (var i = 0; i < markdowns.length; ++i){
        if (markdowns[i].innerHTML) {
          markdowns[i].innerHTML = marked(markdowns[i].innerHTML);
        }
      }
    }
    window.addEventListener("DOMContentLoaded", mark, false);
    window.addEventListener("load", mark, false);
  });
  </script>
  
  
</div>



  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="搜索" class="form-control"/>
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/avatar.jpg" alt="刘卓">
  
  <h1 class="author-name">刘卓</h1>
  <h2 class="author-description">hello,every body!</h2>
  <div class="site-count">
    
    <div class="archives-count">
      <div class="site-count-title">归档</div>
      <div><a href="/archives/">71</a></div>
    </div>
    
    
    
    <span class="site-count-divider divider">|</span>
    
    <div class="categories-count">
      <div class="site-count-title">分类</div>
      <div><a href="/categories/">32</a></div>
    </div>
    
    
    
    <span class="site-count-divider divider">|</span>
    
    <div class="tags-count">
      <div class="site-count-title">标签</div>
      <div><a href="/tags/">28</a></div>
    </div>
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="https://weibo.com/p/1005053310889015/home" target="_blank"><i class="fas fa-rss"></i>Click</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    
    
    
    
    <hr>
    <div class="post-toc sidebar-item" id="toc-div">
      <div><i class="fas fa-list-ol"></i>文章目录</div>
      <div class="post-toc-content"><ol class="list-group toc"><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#JSR107"><span class="toc-text">JSR107</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#Spring缓存抽象"><span class="toc-text">Spring缓存抽象</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#几个重要概念-amp-缓存注解"><span class="toc-text">几个重要概念&amp;缓存注解</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#缓存使用"><span class="toc-text">缓存使用</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#搭建基本环境"><span class="toc-text">搭建基本环境</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#缓存的快速体验"><span class="toc-text">缓存的快速体验</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#SpringBoot的缓存原理："><span class="toc-text">SpringBoot的缓存原理：</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#缓存的运行流程"><span class="toc-text">缓存的运行流程</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#Cacheable属性的使用"><span class="toc-text">@Cacheable属性的使用</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#CachePut的使用"><span class="toc-text">@CachePut的使用</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#CacheEvict的使用"><span class="toc-text">@CacheEvict的使用</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#Caching的使用"><span class="toc-text">@Caching的使用</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#CacheConfig的使用"><span class="toc-text">@CacheConfig的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#整合Redis缓存"><span class="toc-text">整合Redis缓存</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#搭建redis环境"><span class="toc-text">搭建redis环境</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#整合redis"><span class="toc-text">整合redis</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#使用redis缓存"><span class="toc-text">使用redis缓存</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#使用编码的方式来使用Redis"><span class="toc-text">使用编码的方式来使用Redis</span></a></li></ol></li></ol></div>
    </div>
    
    
    
    <hr>
    <div class="social-link sidebar-item">
      <div><i class="far fa-address-card"></i>社交链接</p></div>
      <ul>
        
        <li><i class="fas fa-envelope"></i><a href="mailto:575920824@qq.com" target="_blank">E-Mail</a></li>
        
        <li><i class="fab fa-github"></i><a href="https://github.com/liuzhuo19940206" target="_blank">GitHub</a></li>
        
        <li><i class="fab fa-weibo"></i><a href="https://weibo.com/p/1005053310889015/home" target="_blank">Weibo</a></li>
        
      </ul>
    </div>
    
    
    <hr>
    <div class="blogroll sidebar-item">
      <div><i class="fas fa-link"></i>友情链接</div>
      <ul>
        
        <li><i class="fas fa-link"></i><a href="http://gakkij.top" target="_blank">Gakki酱</a></li>
        
        <li><i class="fas fa-link"></i><a href="https://github.com/" target="_blank">GitHub</a></li>
        
        <li><i class="fas fa-link"></i><a href="https://dev.tencent.com/user" target="_blank">Coding</a></li>
        
        <li><i class="fas fa-link"></i><a href="https://developer.mozilla.org/" target="_blank">MDN</a></li>
        
        <li><i class="fas fa-link"></i><a href="https://mozilla.github.io/nunjucks/" target="_blank">Nunjucks</a></li>
        
      </ul>
    </div>
    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #333333;">
  <div class="container">
    <div class="back-to-top">
      <button id="back-to-top"><i class="fas fa-angle-double-up" aria-label="回到顶部"></i></button>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">刘卓</span><span class="year"><i class="far fa-copyright"></i>2018/10/10 - 2018</span>
        </div>
        
        <div class="busuanzi">
          <span id="busuanzi_container_site_pv"><i class="fas fa-eye" aria-label="站点点击量" aria-hidden="false"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user" aria-label="站点用户数" aria-hidden="false"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv" aria-label="页面点击量" aria-hidden="false"></span></span>
        </div>
        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://github.com/liuzhuo19940206/liuzhuo19940206.github.io" target="_blank">GitHub Pages</a>
          
        </div>
        <div class="powered-by">
          由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动 
        </div>
      </div>
    </div>
  </div>
</footer>
<script>
(function(){
    var bp = document.createElement('script');
    bp.src = '//push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  </body>
</html>
