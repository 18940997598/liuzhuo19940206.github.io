<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>SpringBoot_day_08</title>
      <link href="/2018/11/11/SpringBoot-day-08/"/>
      <url>/2018/11/11/SpringBoot-day-08/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot与数据访问<br><a id="more"></a></p><h2 id="JDBC-默认支持的数据源"><a href="#JDBC-默认支持的数据源" class="headerlink" title="JDBC(默认支持的数据源)"></a>JDBC(默认支持的数据源)</h2><p>1）创建新的Springboot项目，添加web模块、mysql模块、jdbc模块<br><img src="/images/QQ截图20181111110045.png"><br><img src="/images/QQ截图20181111110143.png"><br><img src="/images/QQ截图20181111110336.png"></p><p>2) 连接我们的数据库：</p><p>打开我们的虚拟机，然后启动mysql的容器<br><img src="/images/QQ截图20181111110542.png"><br><img src="/images/QQ截图20181111110735.png"><br><img src="/images/QQ截图20181111110811.png"></p><p>3）在我们的项目中，添加数据源的配置信息。</p><p>这里使用yml文件，properties文件也一样。<br>在resources下：创建application.yml文件。<br><img src="/images/QQ截图20181111111923.png"><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">spring:<br>  datasource:<br>    username: root<br>    password: 123456<br>    driver-class-name: com.mysql.jdbc.Driver<br>    url: jdbc:mysql://10.6.11.17:3306/jdbc<br></code></pre></td></tr></table></figure></p><p>在mysql的客户端上面，创建jdbc数据库：<br><img src="/images/QQ截图20181111111412.png"></p><p>4）测试数据源是否配置成功<br>在test包下：<br><img src="/images/QQ截图20181111112125.png"></p><p>效果：</p><p>默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源</p><p>数据源的相关配置都在DataSourceProperties里面。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)<br>public class DataSourceProperties<br>implements BeanClassLoaderAware, EnvironmentAware, InitializingBean &#123;<br></code></pre></td></tr></table></figure></p><p>5) 自动配置的原理</p><p>org.springframework.boot.autoconfigure.jdbc：</p><p>1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用<br>spring.datasource.type指定自定义的数据源类型；</p><p>2、SpringBoot默认支持的数据源：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource<br></code></pre></td></tr></table></figure></p><p>3、自定义数据源类型<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">/**<br> * Generic DataSource configuration.<br> */<br>@ConditionalOnMissingBean(DataSource.class)<br>@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;)<br>static class Generic &#123;<br><br>@Bean<br>public DataSource dataSource(DataSourceProperties properties) &#123;<br>return properties.initializeDataSourceBuilder().build();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>4、自动运行sql语句的原理</p><p>DataSourceAutoConfiguration:中有一个<strong>DataSourceInitializer</strong>对象。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ConditionalOnClass(&#123; DataSource.class, EmbeddedDatabaseType.class &#125;)<br>@EnableConfigurationProperties(DataSourceProperties.class)<br>@Import(&#123; Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class &#125;)<br>public class DataSourceAutoConfiguration &#123;<br><br>@Bean<br>@ConditionalOnMissingBean<br>public DataSourceInitializer dataSourceInitializer(DataSourceProperties properties,<br>ApplicationContext applicationContext) &#123;<br>return new DataSourceInitializer(properties, applicationContext);<br>&#125;<br>  ···<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>DataSourceInitializer：ApplicationListener</strong><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class DataSourceInitializer implements ApplicationListener<br></code></pre></td></tr></table></figure></p><p>作用：<br>1）、runSchemaScripts();运行建表语句；</p><p>2）、runDataScripts();运行插入数据的sql语句；</p><p>默认只需要将文件命名为：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">schema‐*.sql、data‐*.sql<br>默认规则：schema.sql，schema‐all.sql；<br><br>自定义名字：<br>在配置文件中：<br>   schema:<br>      ‐ classpath:department.sql<br>      指定位置<br></code></pre></td></tr></table></figure></p><p>验证：<br>在resources下：创建默认命名规则的：schema-all.sql文件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">SET FOREIGN_KEY_CHECKS=0;<br><br>-- ----------------------------<br>-- Table structure for department<br>-- ----------------------------<br>DROP TABLE IF EXISTS `department`;<br>CREATE TABLE `department` (<br>  `id` int(11) NOT NULL AUTO_INCREMENT,<br>  `departmentName` varchar(255) DEFAULT NULL,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure></p><p><img src="/images/QQ截图20181111113520.png"></p><p>现在jdbc中还没有department表：<br><img src="/images/QQ截图20181111113648.png"></p><p>运行我们的Springboot项目：<br><img src="/images/QQ截图20181111113737.png"><br><img src="/images/QQ截图20181111113833.png"></p><p>刷新jdbc数据库：<br><img src="/images/QQ截图20181111113923.png"></p><hr><p>使用自定义的命名规则：<br>修改schema-all.sql 的名字为：department.sql<br>在application.yml文件中：<br><img src="/images/QQ截图20181111114934.png"></p><p>删除jdbc中的department表，然后再次启动Springboot项目：<br><img src="/images/QQ截图20181111115013.png"></p><p>5、操作数据库：Springboot自动配置了JdbcTemplate操作数据库<br><img src="/images/QQ截图20181111115134.png" style="width:50%"><br><img src="/images/QQ截图20181111115401.png"></p><p>说明Springboot已经帮我们配置好了JdbcTemplate模板引擎，我们可以直接使用：<br>创建HelloController：<br><img src="/images/QQ截图20181111120407.png"><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Controller<br>public class HelloController &#123;<br><br>    @Autowired<br>    private JdbcTemplate jdbcTemplate;<br><br>    @ResponseBody<br>    @RequestMapping(&quot;/query&quot;)<br>    public Map&lt;String, Object&gt; queryDepartment() &#123;<br>        List&lt;Map&lt;String, Object&gt;&gt; mapList = jdbcTemplate.queryForList(&quot;select * from department&quot;);<br>        //返回第一条数据<br>        return mapList.get(0);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>启动应用：<br><img src="/images/QQ截图20181111120130.png"></p><p>打开mysql的客户端：<br>添加一条数据：<br><img src="/images/QQ截图20181111120217.png"></p><p>打开浏览器：输入：<code>http://localhost:8080/query</code><br><img src="/images/QQ截图20181111120509.png"></p><hr><h2 id="整合Druid数据源-阿里的数据源连接池"><a href="#整合Druid数据源-阿里的数据源连接池" class="headerlink" title="整合Druid数据源(阿里的数据源连接池)"></a>整合Druid数据源(阿里的数据源连接池)</h2><p>1）导入druid的依赖<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!--导入druid的数据源--&gt;<br>&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;<br>&lt;dependency&gt;<br>&lt;groupId&gt;com.alibaba&lt;/groupId&gt;<br>&lt;artifactId&gt;druid&lt;/artifactId&gt;<br>&lt;version&gt;1.1.10&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>2) 切换数据源：<br>使用type来切换数据源<br><img src="/images/QQ截图20181111123613.png"><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">spring:<br>  datasource:<br>    username: root<br>    password: 123456<br>    driver-class-name: com.mysql.jdbc.Driver<br>    url: jdbc:mysql://10.6.11.17:3306/jdbc<br>    type: com.alibaba.druid.pool.DruidDataSource<br>#    schema:<br>#      - classpath:department.sql<br></code></pre></td></tr></table></figure></p><p>3) 运行测试类：<br><img src="/images/QQ截图20181111123753.png"><br><img src="/images/QQ截图20181111123907.png"><br>数据源切换成功。</p><p>4）添加druid的独有配置<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs undefined">spring:<br>  datasource:<br>    username: root<br>    password: 123456<br>    driver-class-name: com.mysql.jdbc.Driver<br>    url: jdbc:mysql://10.6.11.17:3306/jdbc<br>    type: com.alibaba.druid.pool.DruidDataSource<br><br>    #数据源其他配置<br>    initialSize: 5<br>    minIdle: 5<br>    maxActive: 20<br>    maxWait: 60000<br>    timeBetweenEvictionRunsMillis: 60000<br>    minEvictableIdleTimeMillis: 300000<br>    validationQuery: SELECT 1 FROM DUAL<br>    testWhileIdle: true<br>    testOnBorrow: false<br>    testOnReturn: false<br>    poolPreparedStatements: true<br><br>    #配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙<br>    filters: stat,wall,log4j<br>    maxPoolPreparedStatementPerConnectionSize: 20<br>    useGlobalDataSourceStat: true<br>    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500<br>    <br>#    schema:<br>#      - classpath:department.sql<br></code></pre></td></tr></table></figure></p><p>dubug一下，看是否是其他属性配置成功：</p><p>给contextLoads中的System.out.println(dataSource);打上断点<br><img src="/images/QQ截图20181111124326.png"></p><p>dubug运行该测试方法：<br><img src="/images/QQ截图20181111124538.png"></p><p>因为我们在application配置文件中配置的：spring-datasource:开头的配置信息，都是DataSourceProperties中的<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)<br>public class DataSourceProperties<br></code></pre></td></tr></table></figure></p><p>而DataSourceProperties类中，根本没有druid那些独有的配置信息：<br><img src="/images/QQ截图20181111124846.png"></p><p>5）自己配置druid数据源</p><p>在config包下，创建MyDruidConfig类：<br><img src="/images/QQ截图20181111125255.png"></p><p>这样就能将application配置文件中的druid的独有配置信息调入到我们的druid数据源当中了。</p><p>如果没有添加@ConfigurationProperties(prefix = “spring.datasource”)的话：<br>需要自己手动一个一个的配置<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean<br>DataSource druid() &#123;<br>    DruidDataSource druidDataSource = new DruidDataSource();<br>    druidDataSource.setInitialSize(5);<br>    druidDataSource.setMaxActive(10);<br>    ···<br>    return druidDataSource;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>再次dubug测试方法：<br><img src="/images/QQ截图20181111125737.png"></p><p>6）配置druid的监控</p><p>在MyDruidConfig类中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置Druid的监控<br>//1、配置一个管理后台的Servlet<br>@Bean<br>public ServletRegistrationBean statViewServlet() &#123;<br>    ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);<br><br>    Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();<br>    initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;);<br>    initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;);<br>    initParams.put(&quot;allow&quot;,&quot;&quot;);//默认就是允许所有访问<br>    initParams.put(&quot;deny&quot;,&quot;192.168.15.21&quot;);//不然访问<br><br>    bean.setInitParameters(initParams);<br>    return bean;<br>&#125;<br><br>//2、配置一个web监控的filter<br>@Bean<br>public FilterRegistrationBean webStatFilter() &#123;<br>    FilterRegistrationBean bean = new FilterRegistrationBean();<br>    bean.setFilter(new WebStatFilter());<br><br>    Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();<br>    initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;);//排除静态资源<br><br>    bean.setInitParameters(initParams);<br>    bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));<br>    <br>    return bean;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>启动Springboot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/druid</code><br><img src="/images/QQ截图20181111130651.png"></p><p>输入自己配置的用户名与密码：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;);<br>initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;);<br></code></pre></td></tr></table></figure></p><p><img src="/images/QQ截图20181111130816.png"></p><p>在浏览器中输入：<code>http://localhost:8080/query</code></p><p>然后点击SQL监控：<br><img src="/images/QQ截图20181111131006.png"></p><p>点击Web应用：就是我们的配置WebAppStat List过滤器<br><img src="/images/QQ截图20181111131202.png"></p><p>监控成功！！！</p><hr><h2 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h2><h3 id="前期准备阶段"><a href="#前期准备阶段" class="headerlink" title="前期准备阶段"></a>前期准备阶段</h3><p>1）创建新的项目，添加web、mysql、mybatis模块：<br><img src="/images/QQ截图20181111141702.png"></p><p>导入druid依赖：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!--导入druid的数据源--&gt;<br>&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;<br>&lt;dependency&gt;<br>&lt;groupId&gt;com.alibaba&lt;/groupId&gt;<br>&lt;artifactId&gt;druid&lt;/artifactId&gt;<br>&lt;version&gt;1.1.10&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>2）创建application.yml文件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs undefined">spring:<br>  datasource:<br>    username: root<br>    password: 123456<br>    driver-class-name: com.mysql.jdbc.Driver<br>    url: jdbc:mysql://10.6.11.17:3306/mybatis<br>    type: com.alibaba.druid.pool.DruidDataSource<br><br>    #数据源其他配置<br>    initialSize: 5<br>    minIdle: 5<br>    maxActive: 20<br>    maxWait: 60000<br>    timeBetweenEvictionRunsMillis: 60000<br>    minEvictableIdleTimeMillis: 300000<br>    validationQuery: SELECT 1 FROM DUAL<br>    testWhileIdle: true<br>    testOnBorrow: false<br>    testOnReturn: false<br>    poolPreparedStatements: true<br><br>    #配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙<br>    filters: stat,wall,log4j<br>    maxPoolPreparedStatementPerConnectionSize: 20<br>    useGlobalDataSourceStat: true<br>    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500<br><br>    schema:<br>      - classpath:sql/department.sql<br>      - classpath:sql/employee.sql<br></code></pre></td></tr></table></figure></p><p>3) 创建新的数据库mybatis：<br><img src="/images/QQ截图20181111142149.png"></p><p>4）在resours下：参加过sql文件夹<br>里面放入：department.sql 和 employee.sql文件：<br><img src="/images/QQ截图20181111142335.png" style="width:50%"></p><p>department.sql:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs undefined">/*<br>Navicat MySQL Data Transfer<br><br>Source Server         : 本地<br>Source Server Version : 50528<br>Source Host           : 127.0.0.1:3306<br>Source Database       : restful_crud<br><br>Target Server Type    : MYSQL<br>Target Server Version : 50528<br>File Encoding         : 65001<br><br>Date: 2018-03-05 10:41:40<br>*/<br><br>SET FOREIGN_KEY_CHECKS=0;<br><br>-- ----------------------------<br>-- Table structure for department<br>-- ----------------------------<br>DROP TABLE IF EXISTS `department`;<br>CREATE TABLE `department` (<br>  `id` int(11) NOT NULL AUTO_INCREMENT,<br>  `departmentName` varchar(255) DEFAULT NULL,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure></p><p>employee.sql文件:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs undefined">/*<br>Navicat MySQL Data Transfer<br><br>Source Server         : 本地<br>Source Server Version : 50528<br>Source Host           : 127.0.0.1:3306<br>Source Database       : restful_crud<br><br>Target Server Type    : MYSQL<br>Target Server Version : 50528<br>File Encoding         : 65001<br><br>Date: 2018-03-05 10:41:58<br>*/<br><br>SET FOREIGN_KEY_CHECKS=0;<br><br>-- ----------------------------<br>-- Table structure for employee<br>-- ----------------------------<br>DROP TABLE IF EXISTS `employee`;<br>CREATE TABLE `employee` (<br>  `id` int(11) NOT NULL AUTO_INCREMENT,<br>  `lastName` varchar(255) DEFAULT NULL,<br>  `email` varchar(255) DEFAULT NULL,<br>  `gender` int(2) DEFAULT NULL,<br>  `d_id` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure></p><p>5) 创建config：DruidConfig配置类：<br><img src="/images/QQ截图20181111142702.png"></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class DruidConfig &#123;<br><br>    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)<br>    @Bean<br>    DataSource druid() &#123;<br>        return new DruidDataSource();<br>    &#125;<br><br>    //配置Druid的监控<br>    //1、配置一个管理后台的Servlet<br>    @Bean<br>    public ServletRegistrationBean statViewServlet() &#123;<br>        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);<br><br>        Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();<br>        initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;);<br>        initParams.put(&quot;loginPassword&quot;, &quot;123456&quot;);<br>        initParams.put(&quot;allow&quot;, &quot;&quot;);//默认就是允许所有访问<br>        initParams.put(&quot;deny&quot;, &quot;192.168.15.21&quot;);//不然访问<br><br>        bean.setInitParameters(initParams);<br>        return bean;<br>    &#125;<br><br>    //2、配置一个web监控的filter<br>    @Bean<br>    public FilterRegistrationBean webStatFilter() &#123;<br>        FilterRegistrationBean bean = new FilterRegistrationBean();<br>        bean.setFilter(new WebStatFilter());<br><br>        Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();<br>        initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*&quot;);//排除静态资源<br><br>        bean.setInitParameters(initParams);<br>        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));<br><br>        return bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>6) 启动Springboot应用：</p><p>打开mysql的客户端：生成了两个表：<br><img src="/images/QQ截图20181111142926.png"></p><p>注释掉，application配置文件中的schema：(防止再次启动应用，表又归零！)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">#    schema:<br>#      - classpath:sql/department.sql<br>#      - classpath:sql/employee.sql<br></code></pre></td></tr></table></figure></p><p>7）创建bean对象：</p><p>根据数据库mybatis中的两个表，创建对应的JavaBean对象。<br><img src="/images/QQ截图20181111143428.png"></p><p>Employee：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Employee &#123;<br><br>    private Integer id;<br>    private String lastName;<br>    private Integer gender;<br>    private String email;<br>    private Integer dId;<br><br>   ··· get和set方法<br>&#125;<br></code></pre></td></tr></table></figure></p><p>Department:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Department &#123;<br><br>    private Integer id;<br>    private String departmentName;<br><br>    ··· get和set方法<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><h3 id="mybatis的使用"><a href="#mybatis的使用" class="headerlink" title="mybatis的使用"></a>mybatis的使用</h3><h4 id="注解版"><a href="#注解版" class="headerlink" title="注解版"></a>注解版</h4><p>1）创建mapper文件夹：DepartmentMapper（接口）<br><img src="/images/QQ截图20181111145746.png"></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Mapper<br>public interface DepartmentMapper &#123;<br><br>    @Select(&quot;select * from department where id=#&#123;id&#125;&quot;)<br>    public Department getDeptById(Integer id);<br><br>    @Delete(&quot;delete from department where id=#&#123;id&#125;&quot;)<br>    public int deleteDeptById(Integer id);<br><br>    //回显主键的id。<br>    @Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)<br>    @Insert(&quot;insert into department(departmentName) values(#&#123;departmentName&#125;)&quot;)<br>    public int insertDept(Department department);<br><br>    @Update(&quot;update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;&quot;)<br>    public int updateDept(Department department);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>2) 创建一个DepartmentController：<br><img src="/images/QQ截图20181111150310.png"><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RestController<br>public class DepartmentController &#123;<br><br>    @Autowired<br>    private DepartmentMapper departmentMapper;<br><br>    @GetMapping(&quot;/dept/&#123;id&#125;&quot;)<br>    public Department findDepartmentById(@PathVariable(&quot;id&quot;) Integer id) &#123;<br>        return departmentMapper.getDeptById(id);<br>    &#125;<br><br>    @GetMapping(&quot;/dept&quot;)<br>    public Department addDepartment(Department department) &#123;<br>        departmentMapper.insertDept(department);<br>        return department;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 启动Springboot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/dept/1</code><br><img src="/images/QQ截图20181111151409.png"></p><p>在浏览器中输入：<code>http://localhost:8080/dept?departmentName=aa</code><br><img src="/images/QQ截图20181111151555.png"><br><img src="/images/QQ截图20181111151633.png"></p><p>问题：</p><p>我们将mysql中的departmentName改为：department_name.<br><img src="/images/QQ截图20181111151808.png"></p><p>修改我们的DepartmentMapper中的departmentName为：department_name。<br><img src="/images/QQ截图20181111151946.png"></p><p>再次启动Springboot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/dept?departmentName=bb</code></p><p>如果你的mybat的依赖版本的1.3.2以上，会执行成功，因为默认支持驼峰命名了。如果失败的话，我们需要自定义mybatis的规则：</p><p>创建MybatisConfig配置类:<br><img src="/images/QQ截图20181111152708.png"></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class MybatisConfig &#123;<br><br>    @Bean<br>    public ConfigurationCustomizer customizer() &#123;<br>        return new ConfigurationCustomizer() &#123;<br>            @Override<br>            public void customize(org.apache.ibatis.session.Configuration configuration) &#123;<br>                //使用驼峰命名规则<br>                configuration.setMapUnderscoreToCamelCase(true);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者使用在配置文件中，配置驼峰命名规则。</p><hr><p>4）扫描多个mapper类：</p><p>在配合类上面加上：<br>@MapperScan(value = “com.liuzhuo.springboot.mapper”)</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">使用MapperScan批量扫描所有的Mapper接口；<br>@MapperScan(value = &quot;com.liuzhuo.springboot.mapper&quot;)<br>@SpringBootApplication<br>public class SpringBoot06DataMybatisApplication &#123;<br>public static void main(String[] args) &#123;    <br>   SpringApplication.run(SpringBoot06DataMybatisApplication.class, args);        <br>&#125;    <br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就必须要在每个mapper类上，加@Mapper注解了</p><h4 id="配置文件版"><a href="#配置文件版" class="headerlink" title="配置文件版"></a>配置文件版</h4><p>1）创建EmployeeMapper接口：<br><img src="/images/QQ截图20181111154909.png"><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//必须使用@Mapper或者@MapperScan。二者其一即可<br>public interface EmployeeMapper &#123;<br><br>    public Employee findEmplById(Integer id);<br><br>    public void insertEmpl(Employee employee);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 创建mybatis的全局配置文件：</p><p>在resours下创建mybatis/mapper文件夹：<br><img src="/images/QQ截图20181111155138.png" style="width:50%"></p><p>在mybatis文件夹下，创建mybatis的全局配置文件：<br>不会写的话，看mybatis的官网文档，mybatis已经被整合到github上面：<br><img src="/images/QQ截图20181111155348.png"><br><img src="/images/QQ截图20181111155424.png"><br><img src="/images/QQ截图20181111155456.png"></p><p><a href="http://www.mybatis.org/mybatis-3/" target="_blank" rel="noopener">mybatis-3的官方文档</a></p><p>其中的什么数据源，mapper的文件扫描，我们全部删除，我们已经使用application.yml文件配置了。</p><p>最终mybatis-config.xml：</p><p>就设置了一个使用驼峰命名法<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;<br>&lt;!DOCTYPE configuration<br>        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;<br>        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;<br>&lt;configuration&gt;<br>&lt;settings&gt;<br>    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;<br>&lt;/settings&gt;<br>&lt;/configuration&gt;<br></code></pre></td></tr></table></figure></p><p>3）创建mapper.xml文件：</p><p>在mapper文件夹下，创建employee-mapper.xml<br><img src="/images/QQ截图20181111160017.png" style="width:50%"></p><p>文件不会写，看官方文档：<br><img src="/images/QQ截图20181111160123.png"></p><p>最终employee-mapper.xml：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;<br>&lt;!DOCTYPE mapper<br>        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;<br>        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;<br>&lt;mapper namespace=&quot;com.liuzhuo.springboot.mapper.EmployeeMapper&quot;&gt;<br>    &lt;!--<br>        public Employee findEmplById(Integer id);<br>        public Employee insertEmpl(Employee employee);<br>    --&gt;<br>    &lt;select id=&quot;findEmplById&quot; resultType=&quot;com.liuzhuo.springboot.bean.Employee&quot;&gt;<br>        select * from employee where id = #&#123;id&#125;<br>    &lt;/select&gt;<br><br>    &lt;insert id=&quot;insertEmpl&quot; &gt;<br>        INSERT INTO employee(lastName,email,gender,d_id) VALUES (#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;,#&#123;dId&#125;)<br>    &lt;/insert&gt;<br>&lt;/mapper&gt;<br></code></pre></td></tr></table></figure></p><p>4) 在application.yml文件中，制定全局mybatis.xml和mapper.xml的映射：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mybatis:<br>  config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置<br>  mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置<br></code></pre></td></tr></table></figure></p><p>5) 创建EmployeeController：<br><img src="/images/QQ截图20181111161700.png"></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RestController<br>public class EmployeeController &#123;<br><br>    @Autowired<br>    private EmployeeMapper employeeMapper;<br><br>    @GetMapping(&quot;/empl/&#123;id&#125;&quot;)<br>    public Employee findEmplById(@PathVariable(&quot;id&quot;) Integer id) &#123;<br>        return employeeMapper.findEmplById(id);<br>    &#125;<br><br>    @GetMapping(&quot;/empl&quot;)<br>    public Employee insertEmpl(Employee employee) &#123;<br>        employeeMapper.insertEmpl(employee);<br>        return employee;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>6) 启动Springboot应用</p><p>在浏览器中输入：<code>http://localhost:8080/empl/1</code><br><img src="/images/QQ截图20181111161941.png"></p><p>在浏览器中输入：<code>http://localhost:8080/empl?lastName=jack&amp;&amp;email=4324324@qq.com&amp;&amp;gender=1&amp;&amp;dId=2</code><br><img src="/images/QQ截图20181111163225.png"></p><p>再次浏览器中输入：<code>http://localhost:8080/empl/1</code><br><img src="/images/QQ截图20181111163307.png"></p><p>最主要的就是在application配置文件中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mybatis:<br>  config-location: classpath:mybatis/mybatis-config.xml<br>  mapper-locations: classpath:mybatis/mapper/*.xml<br></code></pre></td></tr></table></figure></p><p>更多使用参照:<br><a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">mybatis-spring-boot-autoconfigure</a></p><hr><h2 id="整合SpringData-JPA"><a href="#整合SpringData-JPA" class="headerlink" title="整合SpringData JPA"></a>整合SpringData JPA</h2><h3 id="SpringData简介"><a href="#SpringData简介" class="headerlink" title="SpringData简介"></a>SpringData简介</h3><p><img src="/images/QQ截图20181111165834.png"></p><h3 id="整合SpringData-JPA-1"><a href="#整合SpringData-JPA-1" class="headerlink" title="整合SpringData JPA"></a>整合SpringData JPA</h3><p>JPA:ORM（Object Relational Mapping）</p><p>1）创建新的Springboot项目，添加web、mysql、jpa模块：<br><img src="/images/QQ截图20181111170202.png"></p><p>2）在application.yml配置文件中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">spring:<br>  datasource:<br>    username: root<br>    password: 123456<br>    driver-class-name: com.mysql.jdbc.Driver<br>    url: jdbc:mysql://10.6.11.17:3306/jpa<br>  jpa:<br>#  自动创建数据库的表<br>    hibernate:<br>      ddl-auto: update<br>#  显示sql语句<br>    show-sql: true<br></code></pre></td></tr></table></figure></p><p>3) 在mysql客户端中创建jpa数据库：<br><img src="/images/QQ截图20181111170624.png"></p><p>4）<strong>编写一个实体类（bean）和数据表进行映射，并且配置好映射关系</strong></p><p>在bean包下，创建User类:<br><img src="/images/QQ截图20181111171609.png"></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//使用JPA注解配置映射关系<br>@Entity  //表名是一个实体与数据库中的某个表对应<br>@Table(name = &quot;t_user&quot;) //表示User类与t_user表对象，不写的话，默认就类名小写的表名<br>public class User &#123;<br><br>    @Id //这是一个主键：javax.persistence.Id;<br>    @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键<br>    private Integer id;<br><br>    @Column(name = &quot;last_name&quot;, length = 50)//这是和数据表对应的一个列<br>    private String lastName;<br><br>    @Column //省略默认列名就是属性名<br>    private String email;<br>    <br>   ····get和set方法<br>&#125;<br></code></pre></td></tr></table></figure><p>5）编写一个Dao接口来操作实体类对应的数据表（Repository）：</p><p>继承JpaRepository类就行：&lt;T,U&gt;: T : 实体类， U : 主键类型<br><img src="/images/QQ截图20181111171846.png"></p><p>6）基本的配置（JpaProperties）<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">spring: <br> jpa:<br>    hibernate:<br>#     更新或者创建数据表结构<br>      ddl‐auto: update<br>#    控制台显示SQL<br>    show‐sql: true<br></code></pre></td></tr></table></figure></p><p>7) 编写UserController类<br><img src="/images/QQ截图20181111172435.png"><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RestController<br>public class UserController &#123;<br><br>    @Autowired<br>    private UserRepository userRepository;<br><br><br>    @GetMapping(&quot;/user/&#123;id&#125;&quot;)<br>    public User findUserById(@PathVariable(&quot;id&quot;) Integer id) &#123;<br>        User user = userRepository.findOne(id);<br>        return user;<br>    &#125;<br><br>    @GetMapping(&quot;/user&quot;)<br>    public User insertUser(User user) &#123;<br>        User save = userRepository.save(user);<br>        return save;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>8) 启动Springboot应用：<br>打开mysql的客户端：<br><img src="/images/QQ截图20181111172613.png"><br>自动帮我们创建了t_user表</p><p>在浏览器中输入：<code>http://localhost:8080/user/1</code><br><img src="/images/QQ截图20181111172801.png"></p><p>在浏览器中输入：<code>http://localhost:8080/user?lastName=zhangsan&amp;email=89028394@qq.com</code><br><img src="/images/QQ截图20181111172917.png"></p><p>控制台：（打印出了sql语句）<br><img src="/images/QQ截图20181111173008.png"></p><p>mysql客户端：<br><img src="/images/QQ截图20181111173129.png"></p><p>其他博客：</p><p><a href="https://blog.csdn.net/oChangWen/article/details/52788274?locationNum=3" target="_blank" rel="noopener">https://blog.csdn.net/oChangWen/article/details/52788274?locationNum=3</a></p><p><a href="https://blog.csdn.net/suo082407128/article/details/60963161" target="_blank" rel="noopener">https://blog.csdn.net/suo082407128/article/details/60963161</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot_day_07</title>
      <link href="/2018/11/09/SpringBoot-day-07/"/>
      <url>/2018/11/09/SpringBoot-day-07/</url>
      
        <content type="html"><![CDATA[<p>今天，学习Docker的相关知识<br><a id="more"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Docker</strong>是一个开源的应用容器引擎；是一个轻量级容器技术；</p><p>Docker支持将软件编译成一个镜像；然后在镜像中将各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；</p><p>运行中的这个镜像称为容器，容器启动是非常快速的。</p><p><img src="/images/QQ截图20181109095615.png" style="width:50%;heigth:50%"></p><hr><p><img src="/images/QQ截图20181109095947.png"></p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；</p><p>docker客户端(Client)：连接docker主机进行操作；</p><p>docker仓库(Registry)：用来保存各种打包好的软件镜像；</p><p>docker镜像(Images)：软件打包好的镜像；放在docker仓库中；</p><p>docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用<br><img src="/images/QQ截图20181109100109.png"></p><p>使用Docker的步骤：</p><p>1）、安装Docker</p><p>2）、去Docker仓库找到这个软件对应的镜像；</p><p>3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；</p><p>4）、对容器的启动停止就是对软件的启动停止；</p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><h3 id="安装linux虚拟机"><a href="#安装linux虚拟机" class="headerlink" title="安装linux虚拟机"></a>安装linux虚拟机</h3><p>因为，以后的服务器都是部署在linux上面的，所以我们需要使用linux虚拟机来学习Docker</p><p>1）VMWare、VirtualBox（安装）。</p><p>VMWare虚拟机：比较重量级，而且是收费的，可以破解。</p><p>VirtualBox：轻量级，免费。</p><p>大家，如果没有，提供一个软件的百度云给大家。<a href="https://pan.baidu.com/s/1K8J6ThB1ecpDoZU5IYRGDQ" target="_blank" rel="noopener">软件安装</a>，密码：0zeo</p><p>下载之后，打开<strong>软件</strong>的目录：<br><img src="/images/QQ截图20181109101823.png"></p><p>双击VirtualBox-5.1.26-117224-Win.exe.(安装linux虚拟机)</p><p>2）导入虚拟机文件centos7-atguigu.ova</p><p>打开虚拟机界面，点击管理：导入虚拟电脑。<br><img src="/images/QQ截图20181109102440.png" style="width:50%"><br><strong>一定要 勾选重新初始化所有的网卡的MAC地址</strong><br><img src="/images/QQ截图20181109102555.png" style="width:50%"><br>导入成功后：<br><img src="/images/QQ截图20181109102748.png"></p><p>3）双击启动linux虚拟机;使用 root/ 123456登陆</p><p>会出现未能启动虚拟电脑，由于物理网卡未找到：<br><img src="/images/QQ截图20181109103253.png" style="width:50%"></p><p>点击更改网络设置：<br><img src="/images/QQ截图20181109103407.png"><br><img src="/images/QQ截图20181109103712.png"></p><p>设置完毕后，虚拟机自动启动：<br><img src="/images/QQ截图20181109103900.png"></p><p>输入用户名：root，密码：123456<br><img src="/images/QQ截图20181109104044.png"></p><p>此时，已经登入成功了。</p><p>4）使用客户端连接linux服务器进行命令操作</p><p>为了操作方便，我们可以使用linux的客户端来远程操作linux虚拟机。</p><p>安装软件目录下的：SmarTTY-2.2.msi<br><img src="/images/QQ截图20181109104240.png"></p><p>安装完毕后，启动程序：<br><img src="/images/QQ截图20181109104615.png"></p><p>点击创建新的SSH连接：<br><img src="/images/QQ截图20181109104656.png"><br><img src="/images/QQ截图20181109104916.png"></p><p>虚拟机的ip地址：<br>在虚拟机中输入：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">ip addr<br></code></pre></td></tr></table></figure></p><p><img src="/images/QQ截图20181109105352.png"></p><p>查看本地的ip地址：<br><img src="/images/QQ截图20181109105439.png"></p><p><strong>发现是在一个网络里面，正确！！！</strong></p><p><img src="/images/QQ截图20181109105639.png"><br><img src="/images/QQ截图20181109105717.png"><br><img src="/images/QQ截图20181109105735.png"></p><p>到此，linux客户端连接成功，此时注意不要关闭linux的服务器。</p><h3 id="在linux虚拟机上安装docker"><a href="#在linux虚拟机上安装docker" class="headerlink" title="在linux虚拟机上安装docker"></a>在linux虚拟机上安装docker</h3><p>首先启动虚拟机：<br><img src="/images/QQ截图20181110095216.png"><br>输入用户名和密码：root/123456<br><img src="/images/QQ截图20181110095348.png"><br>查看ip地址：<br><code>ip addr</code><br><img src="/images/QQ截图20181110095509.png"><br>ip地址没有变的话，直接使用我们的linux客户端连接：<br><img src="/images/QQ截图20181110095639.png"><br>输入密码：<br><img src="/images/QQ截图20181110095732.png"><br>连接成功：<br><img src="/images/QQ截图20181110095759.png"></p><hr><p><strong>现在开始在linux上安装docker。</strong></p><p>步骤：</p><p>1）检查虚拟机的内核版本，必须是3.10及以上<br><code>uname ‐r</code><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">[root@localhost ~]# uname -r<br>3.10.0-327.el7.x86_64<br>[root@localhost ~]#<br></code></pre></td></tr></table></figure></p><p>我当前的版本是：3.10.0-327.el7.x86_64</p><p>如果你的不是，那就必须升级内核：<br><code>yum update</code></p><p>2) 安装docker(必须联网)<br><code>yum install docker</code><br><img src="/images/QQ截图20181110100256.png"></p><p>3）输入y确认安装<br><img src="/images/QQ截图20181110100405.png"><br><img src="/images/QQ截图20181110101217.png"><br><strong>出现Complete，表示安装完成！</strong><br><img src="/images/QQ截图20181110101347.png"></p><p>4）启动docker<br><code>systemctl start docker</code><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">[root@localhost ~]# systemctl start docker<br></code></pre></td></tr></table></figure></p><p>查看docker的版本：<br><code>docker -v</code><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">[root@localhost ~]# docker -v<br>Docker version 1.13.1, build 8633870/1.13.1<br></code></pre></td></tr></table></figure></p><p>5) linux开机就启动docker<br><code>systemctl enable docker</code><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">[root@localhost ~]# systemctl enable docker<br>Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.<br></code></pre></td></tr></table></figure></p><p>6) 停止docker<br><code>systemctl stop docker</code></p><h2 id="Docker常用命令-amp-操作"><a href="#Docker常用命令-amp-操作" class="headerlink" title="Docker常用命令&amp;操作"></a>Docker常用命令&amp;操作</h2><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><p><img src="/images/QQ截图20181110102850.png"></p><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">官方的docker仓库</a></p><p><font color="red"><strong>如果在启动的时候，出现问题</strong></font><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">[root@localhost ~]# systemctl start docker<br>Job for docker.service failed because the control process exited with error code. See &quot;systemctl status docker.service&quot; and &quot;journa<br>lctl -xe&quot; for details.<br></code></pre></td></tr></table></figure></p><p>然后根据提示进行systemctl status docker.service，打印出相关的日志：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><br>[root@localhost ~]# systemctl status docker.service<br>● docker.service - Docker Application Container Engine<br>   Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)<br>   Active: failed (Result: exit-code) since Fri 2018-04-27 21:25:13 EDT; 3min 32s ago<br>     Docs: http://docs.docker.com<br>  Process: 2390 ExecStart=/usr/bin/dockerd-current --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current --default-runtime=dock<br>er-runc --exec-opt native.cgroupdriver=systemd --userland-proxy-path=/usr/libexec/docker/docker-proxy-current --seccomp-profile=/etc/docker<br>/seccomp.json $OPTIONS $DOCKER_STORAGE_OPTIONS $DOCKER_NETWORK_OPTIONS $ADD_REGISTRY $BLOCK_REGISTRY $INSECURE_REGISTRY $REGISTRIES (code=e<br>xited, status=1/FAILURE)<br> Main PID: 2390 (code=exited, status=1/FAILURE)<br> <br>Apr 27 21:25:12 localhost.localdomain systemd[1]: Starting Docker Application Container Engine...<br>Apr 27 21:25:12 localhost.localdomain dockerd-current[2390]: time=&quot;2018-04-27T21:25:12.286650644-04:00&quot; level=warning msg=&quot;could no...ound&quot;<br>Apr 27 21:25:12 localhost.localdomain dockerd-current[2390]: time=&quot;2018-04-27T21:25:12.295209148-04:00&quot; level=info msg=&quot;libcontaine...2395&quot;<br>Apr 27 21:25:13 localhost.localdomain dockerd-current[2390]: time=&quot;2018-04-27T21:25:13.310268309-04:00&quot; level=warning msg=&quot;overlay2: the...<br>Apr 27 21:25:13 localhost.localdomain dockerd-current[2390]: Error starting daemon: SELinux is not supported with the overlay2 grap...alse<br>Apr 27 21:25:13 localhost.localdomain systemd[1]: docker.service: main process exited, code=exited, status=1/FAILURE<br>Apr 27 21:25:13 localhost.localdomain systemd[1]: Failed to start Docker Application Container Engine.<br>Apr 27 21:25:13 localhost.localdomain systemd[1]: Unit docker.service entered failed state.<br>Apr 27 21:25:13 localhost.localdomain systemd[1]: docker.service failed.<br>Hint: Some lines were ellipsized, use -l to show in full.<br></code></pre></td></tr></table></figure></p><p>其中：<code>Error starting daemon: SELinux is not supported with the overlay2 grap...alse</code></p><p>这是由于overlay2不支持造成的，所以我们要关闭它。</p><p>重新编辑docker配置文件：</p><p><code>vi /etc/sysconfig/docker</code></p><p>可以进行以下配置：</p><p>OPTIONS=’–selinux-enabled<strong>=false</strong>  –log-driver=journald –signature-verification=false’</p><p>将–selinux-enabled后面添加 =false 即可。<br><img src="/images/QQ截图20181110112203.png"></p><p>vi编辑器，使用i进入编辑状态，修改后：Esc，然后冒号：wq，保存退出。</p><p>然后进行重启操作：</p><p><code>systemctl  restart  docker</code></p><p>自此，Docker启动成功！</p><hr><p>我们以mysql为例：</p><p>1）查询mysql的镜像：<code>docker search mysql</code><br><img src="/images/QQ截图20181110112521.png"></p><p>INDEX：代表镜像的索引</p><p>NAME：镜像的名字</p><p>DESCRIPTION：镜像的描述信息</p><p>STARS：镜像被采纳的次数</p><p>OFFICIAL：是否官方（[OK]：官方，不写：非官方）</p><p>AUTOMATED：是否自动配置（[OK]：自动配置，不写：非自动配置）</p><p>这里搜索的镜像和官方<code>https://hub.docker.com/</code>上面搜索的一样：<br><img src="/images/QQ截图20181110112948.png"><br><img src="/images/QQ截图20181110113105.png"></p><p>2）下载mysql镜像：<code>docker pull mysql</code>(默认下载最近的版本)<br><img src="/images/QQ截图20181110115418.png"></p><p>如果下载镜像很慢，可以使用阿里云的镜像加速度：<br><a href="https://cr.console.aliyun.com/cn-hangzhou/mirrors" target="_blank" rel="noopener">登入阿里云</a><br><img src="/images/QQ截图20181110115602.png"></p><p>将其中的加速器地址，配置到/etc/docker/daemon.json中，然后重启docker</p><p>vi /etc/docker/daemon.json<br><img src="/images/QQ截图20181110115926.png"><br>重启docker：systemctl restart docker<br><img src="/images/QQ截图20181110120138.png"></p><hr><p>如果后面没有加tag，默认是下载最新的版本：latest。</p><p>如果想要下载其他版本，在官网上面查看自己想要下载的版本的tag：<br><img src="/images/QQ截图20181110114140.png"><br><img src="/images/QQ截图20181110114057.png"><br>比如想要下载5.6版本的mysql：<br><img src="/images/QQ截图20181110114239.png"></p><p><code>docker pull mysql:5.6</code><br><img src="/images/QQ截图2018111019173723.png"></p><p>3) 查看本地的镜像：<code>docker images</code><br><img src="/images/QQ截图20181110192115.png"><br>能发现，我们刚刚下载好的两个版本的mysql镜像</p><p>4) 删除镜像：<code>docker rmi image_id</code></p><p>其中的image_id：镜像的唯一id.</p><p>删除mysql：5.6的镜像：<br><img src="/images/QQ截图20181110194611.png"><br>查看剩余的镜像：（只剩下最新版本的mysql镜像）<br><img src="/images/QQ截图20181110194728.png"></p><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><p>软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）；<br><img src="/images/QQ截图20181110194920.png"><br><a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">更多命令</a></p><p>现在，我们以Tomcat为例来操作演示：</p><p>1）搜索镜像<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">[root@localhost ~]# docker search tomcat<br></code></pre></td></tr></table></figure></p><p>2) 拉取镜像<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">[root@localhost ~]# docker pull tomcat<br></code></pre></td></tr></table></figure></p><p>3) 根据镜像启动容器(第一次启动)</p><p><code>docker run ‐‐name mytomcat ‐d tomcat:latest</code><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">--name:自己定义的容器名字，随便写。<br>-d:后台运行<br></code></pre></td></tr></table></figure></p><p><img src="/images/QQ截图20181110200332.png"></p><p>4）查看<strong>运行中</strong>的容器</p><p><code>docker ps</code><br><img src="/images/QQ截图20181110200655.png"></p><p>5) 停止运行中的容器</p><p><code>docker stop  容器的id或自定义的名字</code><br><img src="/images/QQ截图20181110200858.png"></p><p>6) 查看所有的容器（运行或者不运行）</p><p><code>docker ps ‐a</code><br><img src="/images/QQ截图20181110201121.png"></p><p>7) 启动（暂停的）容器</p><p><code>docker start 容器id</code><br><img src="/images/QQ截图20181110201246.png"></p><p>8）删除一个容器</p><p><code>docker rm 容器id</code></p><p>注意删除镜像是 ：rmi</p><p><strong>而且删除容器之前，先要停止容器的运行！！！</strong><br><img src="/images/QQ截图20181110201454.png"></p><p>9）启动一个做了端口映射的tomcat</p><p><code>docker run ‐d ‐p 8888:8080 tomcat:latest</code></p><p>-d：后台运行<br>-p：将主机的端口映射到容器中的一个端口　　主机端口：容器内部的端口</p><p>为了演示简单关闭了linux的防火墙。</p><p>service firewalld status ：查看防火墙状态</p><p>service firewalld stop：关闭防火墙</p><p>如果不映射端口号的话，启动容器，访问Tomcat的主页，是没有作用的：<br><img src="/images/QQ截图20181110201808.png"><br><img src="/images/QQ截图20181110202000.png"></p><p>发现无法访问Tomcat，因为我们只能访问到虚拟机上面的docker，不能直接访问到docker中的Tomcat，所以需要端口号映射。<br><img src="/images/QQ截图20181110202325.png"></p><p>在浏览器中访问：<code>http://10.6.11.17:8888/</code><br><img src="/images/QQ截图20181110202506.png"></p><p>Tomcat访问成功！！！</p><p>我们也可以使用一个Tomcat镜像，开启多个Tomcat容器。<br><img src="/images/QQ截图20181110202657.png"><br>又开启了，8887和8889端口号映射的Tomcat容器。</p><p>在浏览器中输入：<code>http://10.6.11.17:8887/</code> 和 <code>http://10.6.11.17:8889/</code><br><img src="/images/QQ截图20181110202836.png"><br><img src="/images/QQ截图20181110202848.png"></p><p>10）查看容器的日志</p><p><code>docker logs container_name/container_id</code><br><img src="/images/QQ截图20181110203052.png"></p><hr><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>安装以后学习时，需要的镜像。</p><h3 id="安装MySQL示例"><a href="#安装MySQL示例" class="headerlink" title="安装MySQL示例"></a>安装MySQL示例</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">docker pull mysql<br></code></pre></td></tr></table></figure><p>错误的启动:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">[root@localhost ~]# docker run ‐‐name mysql01 ‐d mysql<br>42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846<br><br>mysql退出了<br>[root@localhost ~]# docker ps ‐a<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS          NAMES<br>42f09819908b        mysql               &quot;docker‐entrypoint.sh&quot;   34 seconds ago      Exited(1) 33 seconds ago                   mysql01<br><br>//错误日志<br>[root@localhost ~]# docker logs 42f09819908b<br>error: database is uninitialized and password option is not specified<br>  You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and<br>MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个<br></code></pre></td></tr></table></figure></p><p>查看官网：<br><img src="/images/QQ截图20181110205133.png"></p><p>正确的启动：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">[root@localhost ~]# docker run ‐‐name mysql01 ‐e MYSQL_ROOT_PASSWORD=123456 ‐d mysql<br>b874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f<br>[root@localhost ~]# docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS             PORTS               NAMES<br>b874c56bec49        mysql               &quot;docker‐entrypoint.sh&quot;   4 seconds ago       Up 3seconds        3306/tcp            mysql01<br></code></pre></td></tr></table></figure></p><p>打开mysql的客户端（navicat）：<br><img src="/images/QQ截图20181110205647.png"><br>点击：连接测试：<br><img src="/images/QQ截图20181110205718.png"></p><p>这是因为，我们没有做端口号映射：(‐p 3306:3306)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">[root@localhost ~]# docker run ‐p 3306:3306 ‐‐name mysql02 ‐e MYSQL_ROOT_PASSWORD=123456 ‐d mysql<br>ad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434<br>[root@localhost ~]# docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS             PORTS                    NAMES<br>ad10e4bc5c6a        mysql               &quot;docker‐entrypoint.sh&quot;   4 seconds ago       Up 2seconds        0.0.0.0:3306‐&gt;3306/tcp   mysql02<br></code></pre></td></tr></table></figure></p><p>这里将虚拟机linux的3306端口映射到docker容器的3306端口。</p><p>再次尝试：mysql的客户端打开，连接我们的mysql。</p><p>如果你是mysql安装的是8.0以上的版本：会出现2059 - authentication plugin ‘caching_sha2_password’ -navicat连接异常。<br><img src="/images/QQ截图20181110213957.png"></p><p>这个错误的原因是由于MySQL8.0之后的加密规则为caching_sha2_password.而在此之前的加密规则为mysql_native_password。</p><p>可以将加密规则改成mysql_native_password来。</p><p>解决方案：</p><p>1）进入mysql容器<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">docker exec -it 容器的id或容器的名字 /bin/bash<br></code></pre></td></tr></table></figure></p><p>必须在mysql启动的时候：输入上面的命令。<br><img src="/images/QQ截图20181110214454.png"></p><p>2）进入mysql：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mysql -u用户名 -p密码<br><br>比如：<br>mysql -uroot -p123456<br></code></pre></td></tr></table></figure></p><p><img src="/images/QQ截图20181110214906.png"></p><p>3）修改密码的加密方式：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;password&apos;;<br><br>这里的password：写你自己想要定制的密码：<br><br>比如：<br>ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;<br></code></pre></td></tr></table></figure></p><p><img src="/images/QQ截图20181110215258.png"></p><p>4）执行命令flush privileges使权限配置项立即生效<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">flush privileges;<br></code></pre></td></tr></table></figure></p><p><img src="/images/QQ截图20181110215401.png"></p><p>以上就修改密码的加密方式。</p><hr><p>再次测试我们的mysql客户端连接：<br><img src="/images/QQ截图20181110215450.png"></p><p>现在退出我们的容器：<br>使用：Ctrl+p+q</p><hr><p>几个其他的高级操作：(官网上面都有介绍)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">docker run ‐‐name mysql03 ‐v /conf/mysql:/etc/mysql/conf.d ‐e MYSQL_ROOT_PASSWORD=my‐secret‐pw ‐d mysql:tag<br><br>把主机的/conf/mysql文件夹挂载到  mysqldocker容器的/etc/mysql/conf.d文件夹里面<br>该mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）<br><br>docker run ‐‐name some‐mysql ‐e MYSQL_ROOT_PASSWORD=my‐secret‐pw ‐d mysql:tag ‐‐character‐set‐<br>server=utf8mb4 ‐‐collation‐server=utf8mb4_unicode_ci<br>指定mysql的一些配置参数：utf-8的编码<br></code></pre></td></tr></table></figure></p><h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><p>自行完成</p><h3 id="安装rabbitmq"><a href="#安装rabbitmq" class="headerlink" title="安装rabbitmq"></a>安装rabbitmq</h3><p>自行完成</p><h3 id="安装elasticsearch"><a href="#安装elasticsearch" class="headerlink" title="安装elasticsearch"></a>安装elasticsearch</h3><p>自行完成</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot_day_06</title>
      <link href="/2018/11/08/SpringBoot-day-06/"/>
      <url>/2018/11/08/SpringBoot-day-06/</url>
      
        <content type="html"><![CDATA[<p>今天，继续Web的开发，错误处理机制、配置嵌入式Servlet容器、使用外置的Servlet容器<br><a id="more"></a></p><h2 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h2><h3 id="SpringBoot默认的错误处理机制"><a href="#SpringBoot默认的错误处理机制" class="headerlink" title="SpringBoot默认的错误处理机制"></a>SpringBoot默认的错误处理机制</h3><p>默认效果：</p><p>1）浏览器，返回一个默认的错误页面</p><p><img src="/images/QQ截图20181108101934.png"></p><p>浏览器发送请求的请求头:</p><p><img src="/images/QQ截图20181108102024.png"></p><p>2) 如果是其他客户端，默认响应一个json数据</p><p><img src="/images/QQ截图20181108102057.png"></p><p>其他客户端发送请求的请求头:</p><p><img src="/images/QQ截图20181108102135.png"></p><p><strong>原理：</strong></p><p>可以参照ErrorMvcAutoConfiguration；错误处理的自动配置.</p><p>给容器中添加了以下组件:</p><p>1、DefaultErrorAttributes：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">帮我们在页面共享信息；<br>@Override<br>public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes,    <br>boolean includeStackTrace) &#123;            <br>Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;();        <br>errorAttributes.put(&quot;timestamp&quot;, new Date());        <br>addStatus(errorAttributes, requestAttributes);        <br>addErrorDetails(errorAttributes, requestAttributes, includeStackTrace);        <br>addPath(errorAttributes, requestAttributes);        <br>return errorAttributes;        <br>&#125;<br></code></pre></td></tr></table></figure></p><p>2、BasicErrorController：处理默认/error请求<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Controller<br>@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)<br>public class BasicErrorController extends AbstractErrorController &#123;<br>   <br>    @RequestMapping(produces = &quot;text/html&quot;)//产生html类型的数据；浏览器发送的请求来到这个方法处理<br>public ModelAndView errorHtml(HttpServletRequest request,HttpServletResponse response) &#123;          <br>  <br>HttpStatus status = getStatus(request);        <br>Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(        <br>request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));                <br>response.setStatus(status.value());        <br>       <br>    //去哪个页面作为错误页面；包含页面地址和页面内容<br>ModelAndView modelAndView = resolveErrorView(request, response, status, model);        <br>return (modelAndView == null ? new ModelAndView(&quot;error&quot;, model) : modelAndView);        <br>&#125;    <br><br>@RequestMapping    <br>@ResponseBody    //产生json数据，其他客户端来到这个方法处理；<br>public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;    <br><br>Map&lt;String, Object&gt; body = getErrorAttributes(request,        <br>isIncludeStackTrace(request, MediaType.ALL));                <br>HttpStatus status = getStatus(request);        <br>return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status);        <br>&#125;<br></code></pre></td></tr></table></figure></p><p>3、ErrorPageCustomizer：发送默认/error请求<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Value(&quot;$&#123;error.path:/error&#125;&quot;)    <br>private String path = &quot;/error&quot;;  系统出现错误以后，来到error请求进行处理；（web.xml注册的错误页面规则）<br></code></pre></td></tr></table></figure></p><p>4、DefaultErrorViewResolver：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status,    <br>Map&lt;String, Object&gt; model) &#123;            <br>ModelAndView modelAndView = resolve(String.valueOf(status), model);        <br>if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123;        <br>modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);            <br>&#125;        <br>return modelAndView;        <br> &#125; <br><br>   private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123;    <br>        //默认SpringBoot可以去找到一个页面？  error/404<br>       String errorViewName = &quot;error/&quot; + viewName;        <br>       <br>        //模板引擎可以解析这个页面地址就用模板引擎解析<br>       TemplateAvailabilityProvider provider = this.templateAvailabilityProviders        <br>       .getProvider(errorViewName, this.applicationContext);     <br>           <br>       if (provider != null) &#123;        <br>            //模板引擎可用的情况下返回到errorViewName指定的视图地址<br>           return new ModelAndView(errorViewName, model);            <br>        &#125;        <br>        //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面   error/404.html<br>       return resolveResource(errorViewName, model);        <br>    &#125;<br></code></pre></td></tr></table></figure></p><p><strong>步骤：</strong></p><p>一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error<br>请求；就会被BasicErrorController处理；</p><p>响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">protected ModelAndView resolveErrorView(HttpServletRequest request,<br>      HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123;<br>    //所有的ErrorViewResolver得到ModelAndView<br>    for (ErrorViewResolver resolver : this.errorViewResolvers) &#123;<br>      ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);<br>      if (modelAndView != null) &#123;<br>         return modelAndView;<br>      &#125;<br>   &#125;<br>   return null;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="如果定制错误响应"><a href="#如果定制错误响应" class="headerlink" title="如果定制错误响应"></a>如果定制错误响应</h3><h4 id="如何定制错误的页面"><a href="#如何定制错误的页面" class="headerlink" title="如何定制错误的页面"></a>如何定制错误的页面</h4><p>1) <strong>有模板引擎的情况下</strong></p><p>将错误页面命名为 : 错误状态码.html , 放在模板引擎文件夹里面的error文件夹下，发生此状态码的错误就会来到 对应的页面；</p><p>我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）；</p><p>页面能获取的信息:</p><ol><li>timestamp：时间戳</li><li>status：状态码</li><li>error：错误提示</li><li>exception：异常对象</li><li>message：异常消息</li><li>errors：JSR303数据校验的错误都在这里</li></ol><p>2) 没有模板引擎（模板引擎找不到这个错误页面），在静态资源文件夹下找</p><p>3) 以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">private final SpelView defaultErrorView = new SpelView(<br>&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Whitelabel Error Page&lt;/h1&gt;&quot;<br>+ &quot;&lt;p&gt;This application has no explicit mapping for /error, so you are seeing this as a fallback.&lt;/p&gt;&quot;<br>+ &quot;&lt;div id=&apos;created&apos;&gt;$&#123;timestamp&#125;&lt;/div&gt;&quot;<br>+ &quot;&lt;div&gt;There was an unexpected error (type=$&#123;error&#125;, status=$&#123;status&#125;).&lt;/div&gt;&quot;<br>+ &quot;&lt;div&gt;$&#123;message&#125;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;);<br><br>@Bean(name = &quot;error&quot;)<br>@ConditionalOnMissingBean(name = &quot;error&quot;)<br>public View defaultErrorView() &#123;<br>return this.defaultErrorView;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="如何定制错误的json数据"><a href="#如何定制错误的json数据" class="headerlink" title="如何定制错误的json数据"></a>如何定制错误的json数据</h4><p>1) 自定义异常处理&amp;返回定制json数据</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@ControllerAdvice<br>public class MyExceptionHandler &#123;<br><br>    @ResponseBody<br>    @ExceptionHandler(UserNotExistException.class)<br>    public Map&lt;String,Object&gt; handleException(Exception e)&#123;<br>        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();<br>        map.put(&quot;code&quot;,&quot;user.notexist&quot;);<br>        map.put(&quot;message&quot;,e.getMessage());<br>        return map;<br>    &#125;<br>&#125;<br>//没有自适应效果...<br>//即：浏览器和手机客户端都会返回json数据了<br></code></pre></td></tr></table></figure><p>2）转发到/error进行自适应响应效果处理<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">　　@ExceptionHandler(UserNotExistException.class)<br>    public String handleException(Exception e, HttpServletRequest request)&#123;<br><br>        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();<br>        //传入我们自己的错误状态码  4xx 5xx，否则就不会进入定制错误页面的解析流程<br>        /**<br>         * Integer statusCode = (Integer) request.getAttribute(&quot;javax.servlet.error.status_code&quot;);<br>         */<br>        request.setAttribute(&quot;javax.servlet.error.status_code&quot;,500);<br>        map.put(&quot;code&quot;,&quot;user.notexist&quot;);<br>        map.put(&quot;message&quot;,e.getMessage());<br>        <br>　　　　//将我们自己定义的数据放到request域中<br>　　　　request.setAttributes(&quot;ext&quot;,map);<br>        //转发到/error<br>        return &quot;forward:/error&quot;;<br>    &#125;<br></code></pre></td></tr></table></figure></p><p><strong>3) 将我们的定制数据携带出去</strong></p><p>出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由<br>getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）</p><p>1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中。</p><p>2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到</p><p>容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的。</p><p>自定义ErrorAttributes：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//给容器中加入我们自己定义的ErrorAttributes<br>@Component<br>public class MyErrorAttributes extends DefaultErrorAttributes &#123;<br>    @Override<br>    public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes,boolean includeStackTrace) &#123;<br><br>        Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes,includeStackTrace);<br>        map.put(&quot;company&quot;,&quot;atguigu&quot;);<br>        <br>        //从request域中获取我们自己定义的数据，0：代表request域<br>        Map&lt;String,Object&gt; ext = (Map&lt;String,Object&gt;)requestAttributes.getAttribute(&quot;ext&quot;,0);<br>        //放入要展示的map当中<br>        map.put(&quot;ext&quot;,ext);<br>        return map;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容：<br><img src="/images/QQ截图20181108111151.png"></p><h2 id="配置嵌入式Servlet容器"><a href="#配置嵌入式Servlet容器" class="headerlink" title="配置嵌入式Servlet容器"></a>配置嵌入式Servlet容器</h2><p>SpringBoot默认使用Tomcat作为嵌入式的Servlet容器<br><img src="/images/QQ截图20181108113617.png"></p><p>问题？</p><h3 id="如何定制和修改Servlet容器的相关配置"><a href="#如何定制和修改Servlet容器的相关配置" class="headerlink" title="如何定制和修改Servlet容器的相关配置"></a>如何定制和修改Servlet容器的相关配置</h3><p>1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">server.port=8081<br>server.context‐path=/crud<br>server.tomcat.uri‐encoding=UTF‐8<br><br>//通用的Servlet容器设置<br>server.xxx<br>//Tomcat的设置<br>server.tomcat.xxx<br></code></pre></td></tr></table></figure></p><p>2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean  //一定要将这个定制器加入到容器中<br>public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123;<br>    return new EmbeddedServletContainerCustomizer() &#123;<br>        //定制嵌入式的Servlet容器相关的规则<br>        @Override<br>        public void customize(ConfigurableEmbeddedServletContainer container) &#123;<br>            container.setPort(8083);<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="注册Servlet三大组件【Servlet、Filter、Listener】"><a href="#注册Servlet三大组件【Servlet、Filter、Listener】" class="headerlink" title="注册Servlet三大组件【Servlet、Filter、Listener】"></a>注册Servlet三大组件【Servlet、Filter、Listener】</h3><p>由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件.</p><p>注册三大组件用以下方式:</p><p>1) ServletRegistrationBean<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean<br>public ServletRegistrationBean myServlet()&#123;<br>    ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),&quot;/myServlet&quot;);<br>    return registrationBean;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) FilterRegistrationBean<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean<br>public FilterRegistrationBean myFilter()&#123;<br>    FilterRegistrationBean registrationBean = new FilterRegistrationBean();<br>    registrationBean.setFilter(new MyFilter());<br>    registrationBean.setUrlPatterns(Arrays.asList(&quot;/hello&quot;,&quot;/myServlet&quot;));<br>    return registrationBean;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) ServletListenerRegistrationBean<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean<br>public ServletListenerRegistrationBean myListener()&#123;<br>    ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener());<br>    return registrationBean;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>SpringBoot帮我们自动配置SpringMVC的时候，自动的注册SpringMVC的前端控制器；DispatcherServlet；</p><p>DispatcherServletAutoConfiguration中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)<br>@ConditionalOnBean(value = DispatcherServlet.class, name =<br>DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)<br>public ServletRegistrationBean dispatcherServletRegistration(<br>      DispatcherServlet dispatcherServlet) &#123;<br>   ServletRegistrationBean registration = new ServletRegistrationBean(<br>         dispatcherServlet, this.serverProperties.getServletMapping());<br>    //默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp<br>    //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径<br>   <br>   registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);<br>   registration.setLoadOnStartup(<br>         this.webMvcProperties.getServlet().getLoadOnStartup());<br>   if (this.multipartConfig != null) &#123;<br>      registration.setMultipartConfig(this.multipartConfig);<br>   &#125;<br>   return registration;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="替换为其他嵌入式Servlet容器"><a href="#替换为其他嵌入式Servlet容器" class="headerlink" title="替换为其他嵌入式Servlet容器"></a>替换为其他嵌入式Servlet容器</h3><p><img src="/images/QQ截图20181108114843.png" style="width:50%"></p><p>默认支持：</p><p>Tomcat（默认使用）<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependency&gt;<br>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>   &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;<br>   引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>Jetty<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!‐‐ 引入web模块 ‐‐&gt;<br>&lt;dependency&gt;<br>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>   &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;<br>   &lt;exclusions&gt;<br>      &lt;exclusion&gt;<br>         &lt;artifactId&gt;spring‐boot‐starter‐tomcat&lt;/artifactId&gt;<br>         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>      &lt;/exclusion&gt;<br>   &lt;/exclusions&gt;<br><br>&lt;/dependency&gt;<br>&lt;!‐‐引入其他的Servlet容器‐‐&gt;<br>&lt;dependency&gt;<br>   &lt;artifactId&gt;spring‐boot‐starter‐jetty&lt;/artifactId&gt;<br>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>Undertow<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!‐‐ 引入web模块 ‐‐&gt;<br>&lt;dependency&gt;<br>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>   &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;<br>   &lt;exclusions&gt;<br>      &lt;exclusion&gt;<br>         &lt;artifactId&gt;spring‐boot‐starter‐tomcat&lt;/artifactId&gt;<br>         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>      &lt;/exclusion&gt;<br>   &lt;/exclusions&gt;<br>&lt;/dependency&gt;<br><br>&lt;!‐‐引入其他的Servlet容器‐‐&gt;<br>&lt;dependency&gt;<br>   &lt;artifactId&gt;spring‐boot‐starter‐undertow&lt;/artifactId&gt;<br>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><h3 id="嵌入式Servlet容器自动配置原理"><a href="#嵌入式Servlet容器自动配置原理" class="headerlink" title="嵌入式Servlet容器自动配置原理"></a>嵌入式Servlet容器自动配置原理</h3><p>EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)<br>@Configuration<br>@ConditionalOnWebApplication<br>@Import(BeanPostProcessorsRegistrar.class)<br>//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件<br>//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：<br>//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作<br>public class EmbeddedServletContainerAutoConfiguration &#123;<br>   <br>　　　　@Configuration<br>@ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖；    <br>@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search =<br>SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的<br>Servlet容器工厂；作用：创建嵌入式的Servlet容器<br>public static class EmbeddedTomcat &#123;    <br>@Bean        <br>public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory()<br>&#123;<br>       <br>return new TomcatEmbeddedServletContainerFactory();            <br>&#125;        <br>  &#125;    <br>   <br>/**<br> * Nested configuration if Jetty is being used.    <br> */    <br>@Configuration    <br>@ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class,    <br>WebAppContext.class &#125;)            <br>@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search =<br>SearchStrategy.CURRENT)<br>   <br>public static class EmbeddedJetty &#123;    <br>@Bean        <br>public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123;        <br>return new JettyEmbeddedServletContainerFactory();            <br>&#125;        <br>&#125; <br><br><br>/**    <br> * Nested configuration if Undertow is being used.    <br> */    <br>@Configuration    <br>@ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;)    <br>@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search =<br>SearchStrategy.CURRENT)<br>   <br>public static class EmbeddedUndertow &#123;    <br>@Bean        <br>public UndertowEmbeddedServletContainerFactory<br>undertowEmbeddedServletContainerFactory() &#123;<br>       <br>return new UndertowEmbeddedServletContainerFactory();            <br>&#125;        <br>  &#125;<br></code></pre></td></tr></table></figure></p><p>1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public interface EmbeddedServletContainerFactory &#123;<br>   //获取嵌入式的Servlet容器<br>   EmbeddedServletContainer getEmbeddedServletContainer(<br>         ServletContextInitializer... initializers);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/QQ截图20181108130503.png" style="width:50%"></p><p>2）、EmbeddedServletContainer：（嵌入式的Servlet容器）<br><img src="/images/QQ截图20181108130718.png" style="width:50%"></p><p>3）、<strong>以TomcatEmbeddedServletContainerFactory为例</strong><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>public EmbeddedServletContainer getEmbeddedServletContainer(<br>      ServletContextInitializer... initializers) &#123;<br>   //创建一个Tomcat<br>   Tomcat tomcat = new Tomcat();<br>   <br>    //配置Tomcat的基本环节<br>   File baseDir = (this.baseDirectory != null ? this.baseDirectory<br>         : createTempDir(&quot;tomcat&quot;));<br>   tomcat.setBaseDir(baseDir.getAbsolutePath());<br>   Connector connector = new Connector(this.protocol);<br>   tomcat.getService().addConnector(connector);<br>   customizeConnector(connector);<br>   tomcat.setConnector(connector);<br>   tomcat.getHost().setAutoDeploy(false);<br>   configureEngine(tomcat.getEngine());<br>   for (Connector additionalConnector : this.additionalTomcatConnectors) &#123;<br>      tomcat.getService().addConnector(additionalConnector);<br>   &#125;<br>   prepareContext(tomcat.getHost(), initializers);<br>   <br>    //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器<br>   return getTomcatEmbeddedServletContainer(tomcat);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4）、我们对嵌入式容器的配置修改是怎么生效？<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">ServerProperties、EmbeddedServletContainerCustomizer<br></code></pre></td></tr></table></figure></p><p><strong>EmbeddedServletContainerCustomizer</strong>：定制器帮我们修改了Servlet容器的配置？</p><p>怎么修改的原理？</p><p>5) 容器中导入了<strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//初始化之前<br>@Override<br>public Object postProcessBeforeInitialization(Object bean, String beanName)<br>      throws BeansException &#123;<br>    //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件<br>   if (bean instanceof ConfigurableEmbeddedServletContainer) &#123;<br>       //<br>      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);<br>   &#125;<br>   return bean;<br>&#125;<br>private void postProcessBeforeInitialization(<br>ConfigurableEmbeddedServletContainer bean) &#123;            <br>    //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值；<br>    for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123;<br>        customizer.customize(bean);<br>    &#125;<br>&#125;<br>private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123;<br>    if (this.customizers == null) &#123;<br>        // Look up does not include the parent context<br>        this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(<br>            this.beanFactory<br>            //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer<br>            //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件<br>            .getBeansOfType(EmbeddedServletContainerCustomizer.class,<br>                            false, false)<br>            .values());<br>        Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE);<br>        this.customizers = Collections.unmodifiableList(this.customizers);<br>    &#125;<br>    return this.customizers;<br>&#125;<br>ServerProperties也是定制器<br></code></pre></td></tr></table></figure></p><p>步骤：</p><p>1）、SpringBoot根据导入的嵌入式容器依赖情况，给容器中添加相应的<br>EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】</p><p>2）、容器中某个组件要创建对象就会惊动后置处理器；<br>EmbeddedServletContainerCustomizerBeanPostProcessor；<br>只要是嵌入式的Servlet容器工厂，后置处理器就工作；</p><p>3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法。</p><h3 id="嵌入式Servlet容器启动原理"><a href="#嵌入式Servlet容器启动原理" class="headerlink" title="嵌入式Servlet容器启动原理"></a>嵌入式Servlet容器启动原理</h3><p>什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat；</p><p>获取嵌入式的Servlet容器工厂：</p><p>1）、SpringBoot应用启动运行run方法</p><p>2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一<br>个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：<br>AnnotationConfigApplicationContext</p><p>3）、refresh(context);<strong>刷新刚才创建好的ioc容器；</strong><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public void refresh() throws BeansException, IllegalStateException &#123;<br>   synchronized (this.startupShutdownMonitor) &#123;<br>      // Prepare this context for refreshing.<br>      prepareRefresh();<br>      // Tell the subclass to refresh the internal bean factory.<br>      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<br>      // Prepare the bean factory for use in this context.<br>      prepareBeanFactory(beanFactory);<br>      try &#123;<br>         // Allows post‐processing of the bean factory in context subclasses.<br>         postProcessBeanFactory(beanFactory);<br>         // Invoke factory processors registered as beans in the context.<br>         invokeBeanFactoryPostProcessors(beanFactory);<br>         // Register bean processors that intercept bean creation.<br>         registerBeanPostProcessors(beanFactory);<br>         // Initialize message source for this context.<br>         initMessageSource();<br>         // Initialize event multicaster for this context.<br>         initApplicationEventMulticaster();<br>         // Initialize other special beans in specific context subclasses.<br>         onRefresh();<br>         // Check for listener beans and register them.<br>         registerListeners();<br>         // Instantiate all remaining (non‐lazy‐init) singletons.<br>         finishBeanFactoryInitialization(beanFactory);<br>         // Last step: publish corresponding event.<br>         finishRefresh();<br>      &#125;<br>      catch (BeansException ex) &#123;<br>         if (logger.isWarnEnabled()) &#123;<br>            logger.warn(&quot;Exception encountered during context initialization ‐ &quot; +<br>                  &quot;cancelling refresh attempt: &quot; + ex);<br>         &#125;<br>         // Destroy already created singletons to avoid dangling resources.<br>         destroyBeans();<br>         // Reset &apos;active&apos; flag.<br>         cancelRefresh(ex);<br>         // Propagate exception to caller.<br>         throw ex;<br>      &#125;<br>      finally &#123;<br>         // Reset common introspection caches in Spring&apos;s core, since we<br>         // might not ever need metadata for singleton beans anymore...<br>         resetCommonCaches();<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4）、 onRefresh(); web的ioc容器重写了onRefresh方法</p><p>5）、webIoC容器会创建嵌入式的Servlet容器；<strong>createEmbeddedServletContainer();</strong></p><p>6）、<strong>获取嵌入式的Servlet容器工厂</strong>：</p><p>EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();</p><p>从ioc容器中获取EmbeddedServletContainerFactory 组件；<strong>TomcatEmbeddedServletContainerFactory</strong>创建<br>对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置；</p><p>7）、<strong>使用容器工厂获取嵌入式的Servlet容器</strong>：</p><p>this.embeddedServletContainer = containerFactory.getEmbeddedServletContainer(getSelfInitializer());</p><p>8）、嵌入式的Servlet容器创建对象并启动Servlet容器</p><p><strong>先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来</strong></p><p><b>IOC容器启动创建嵌入式的Servlet容器</b></p><hr><h3 id="使用外置的Servlet容器"><a href="#使用外置的Servlet容器" class="headerlink" title="使用外置的Servlet容器"></a>使用外置的Servlet容器</h3><p>嵌入式Servlet容器：应用打成可执行的jar</p><p>优点：简单、便携</p><p>缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】<br>自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）；</p><p>外置的Servlet容器：外面安装Tomcat—应用war包的方式打包.</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1）创建一个War工程：<br><img src="/images/QQ截图20181108141118.png"><br><img src="/images/QQ截图20181108141218.png"><br><img src="/images/QQ截图20181108141327.png"><br><img src="/images/QQ截图20181108141425.png"><br><img src="/images/QQ截图20181108141535.png"><br><img src="/images/QQ截图20181108141805.png"></p><p>2）将项目结构构造成War的目录结构</p><p>打开项目的结构设置：（点击Web）<br><img src="/images/QQ截图20181108141932.png"></p><p><strong>添加webapp目录 和 web.xml文件</strong><br><img src="/images/QQ截图20181108142443.png"></p><p>完成后：<br><img src="/images/QQ截图20181108142615.png" style="width:50%"></p><p>打开pom.xml文件</p><p>检查是不是war：<br><img src="/images/QQ截图20181108142726.png"></p><p><strong>检查tomcat的依赖的scope是不是provided</strong><br><img src="/images/QQ截图20181108142816.png"></p><p>3）添加外部的Tomcat的容器<br><img src="/images/QQ截图20181108143051.png"><br><img src="/images/QQ截图20181108143152.png"><br><img src="/images/QQ截图20181108143441.png"></p><p>发现上面一个警告，因为还没有配置部署的项目：点击Deployment<br><img src="/images/QQ截图20181108143551.png"><br><img src="/images/QQ截图20181108143640.png"></p><p>4）启动外部的Tomcat容器：<br><img src="/images/QQ截图20181108143747.png"></p><p>启动完成后：<br><img src="/images/QQ截图20181108143904.png"><br><img src="/images/QQ截图20181108143941.png"></p><p>5）添加jsp页面，看看是否能成功</p><p>在webapp下面，直接创建index.jsp页面<br><img src="/images/QQ截图20181108144117.png"></p><p>启动应用，在浏览器中输入：<code>http://localhost:8080/</code> 或者 <code>http://localhost:8080/index.jsp</code><br><img src="/images/QQ截图20181108144330.png"></p><p>6) 编写控制器层：</p><p>一般我们的jsp.xml页面放置在WEB-INF下面，因为这样可以屏蔽直接在浏览器中输入地址直接访问我们的页面。</p><p>不信的话，我们在WEB-INF下面放置一个success.jsp页面：<br><img src="/images/QQ截图20181108144634.png"></p><p>重启应用，在浏览器中输入：<code>http://localhost:8080/WEB-INF/success.jsp</code><br><img src="/images/QQ截图20181108144754.png"></p><p>WEB-INF下面的资源，必须靠容器来帮我们访问，即：用控制层的重定向或者转发来寻找资源。</p><p>修改index.jsp页面：<br>添加一个a标签，发送/success的get请求：<br><img src="/images/QQ截图20181108150427.png"></p><p>创建controller包，并创建HelloController类：<br><img src="/images/QQ截图20181108145418.png"></p><p>重启应用，点击success的超链接<br><img src="/images/QQ截图20181108145532.png"><br><img src="/images/QQ截图20181108150604.png"></p><p>出现500，/success请求路径解析异常，因为我们没有配置视图解析器，return “success” 又会重新执行<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@GetMapping(&quot;/success&quot;)<br>public String success() &#123;<br>    return &quot;success&quot;;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>该方法，就会循环调用，出现异常。</p><p>所以，需要在配置文件中，配置view的前缀路径，和后缀名。<br><img src="/images/QQ截图20181108151153.png"></p><p>重启应用，点击success超链接：<br><img src="/images/QQ截图20181108151253.png"></p><p>以上就是使用Springboot打包成war包的开发流程：</p><p><strong>注意：此时不能使用Springboot的主类应用启动方式，只能使用Tomcat容器的启动方式！！！</strong></p><hr><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器；</p><p>war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器；</p><p>war包的启动原理，还是要归结于servlet3.0标准。</p><p>如果大家不清楚的话，看我的另一篇<a href="http://gakkil.top/2018/10/28/Servlet3-0/" target="_blank" rel="noopener">serlvet3.0</a>里面有详细的过程。</p><p>规则：</p><p>1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例：</p><p>2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为<br>javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名</p><p>3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；</p><p>流程：</p><p>1）、启动Tomcat</p><p>2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-<br>INF\services\javax.servlet.ServletContainerInitializer：</p><p>Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer<br><img src="/images/QQ截图20181108154339.png"></p><p>3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型<br>的类都传入到onStartup方法的Set集合中；为这些WebApplicationInitializer类型的类创建实例；<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@HandlesTypes(WebApplicationInitializer.class)<br>public class SpringServletContainerInitializer<br></code></pre></td></tr></table></figure></p><p>4）、每一个WebApplicationInitializer都调用自己的onStartup；<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">for (WebApplicationInitializer initializer : initializers) &#123;<br>initializer.onStartup(servletContext);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>WebApplicationInitializer继承树：<br><img src="/images/QQ截图20181108155531.png"></p><p>我们发现了SpringBootServletInitializer是WebApplicationInitializer一个实现类。</p><p>5）我们项目中的ServletInitializer继承了SpringBootServletInitializer：(idea自己帮我们创建的一个类，名字无所谓，继承SpringBootServletInitializer即可)<br><img src="/images/QQ截图20181108155741.png"></p><p>所以服务启动的时候，会创建ServletInitializer实例并调用onStartup方法。我们没有重写onStartup方法，所以会调用父类SpringBootServletInitializer的onStartup方法。</p><p>6）SpringBootServletInitializer执行onStartup的时候会调用createRootApplicationContext：创建容器<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs undefined">protected WebApplicationContext createRootApplicationContext(<br>      ServletContext servletContext) &#123;<br>    //1、创建SpringApplicationBuilder<br>   SpringApplicationBuilder builder = createSpringApplicationBuilder();<br>   StandardServletEnvironment environment = new StandardServletEnvironment();<br>   environment.initPropertySources(servletContext, null);<br>   builder.environment(environment);<br>   builder.main(getClass());<br>   ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);<br>   if (parent != null) &#123;<br>      this.logger.info(&quot;Root context already created (using as parent).&quot;);<br>      servletContext.setAttribute(<br>            WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null);<br>      builder.initializers(new ParentContextApplicationContextInitializer(parent));<br>   &#125;<br>   builder.initializers(<br>         new ServletContextApplicationContextInitializer(servletContext));<br>   builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class);<br>   <br>    //2.调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来<br>   builder = configure(builder);<br>   <br>    //3.使用builder创建一个Spring应用<br>   SpringApplication application = builder.build();<br>   if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils<br>         .findAnnotation(getClass(), Configuration.class) != null) &#123;<br>      application.getSources().add(getClass());<br>   &#125;<br>   Assert.state(!application.getSources().isEmpty(),<br>         &quot;No SpringApplication sources have been defined. Either override the &quot;<br>               + &quot;configure method or add an @Configuration annotation&quot;);<br>   // Ensure error pages are registered<br>   if (this.registerErrorPageFilter) &#123;<br>      application.getSources().add(ErrorPageFilterConfiguration.class);<br>   &#125;<br>    //4.启动Spring应用<br>   return run(application);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>7） Spring的应用就启动并且创建IOC容器<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public ConfigurableApplicationContext run(String... args) &#123;<br>   StopWatch stopWatch = new StopWatch();<br>   stopWatch.start();<br>   ConfigurableApplicationContext context = null;<br>   FailureAnalyzers analyzers = null;<br>   configureHeadlessProperty();<br>   SpringApplicationRunListeners listeners = getRunListeners(args);<br>   listeners.starting();<br>   try &#123;<br>      ApplicationArguments applicationArguments = new DefaultApplicationArguments(<br>            args);<br>      ConfigurableEnvironment environment = prepareEnvironment(listeners,<br>            applicationArguments);<br>      Banner printedBanner = printBanner(environment);<br>      context = createApplicationContext();<br>      analyzers = new FailureAnalyzers(context);<br>      prepareContext(context, environment, listeners, applicationArguments,<br>            printedBanner);<br>      <br>       //刷新IOC容器<br>      refreshContext(context);<br>      afterRefresh(context, applicationArguments);<br>      listeners.finished(context, null);<br>      stopWatch.stop();<br>      if (this.logStartupInfo) &#123;<br>         new StartupInfoLogger(this.mainApplicationClass)<br>               .logStarted(getApplicationLog(), stopWatch);<br>      &#125;<br>      return context;<br>   &#125;<br>   catch (Throwable ex) &#123;<br>      handleRunFailure(context, listeners, analyzers, ex);<br>      throw new IllegalStateException(ex);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><font color="#EE2C2C"><strong>总结：启动Servlet容器，再启动SpringBoot应用</strong></font>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot_day_05</title>
      <link href="/2018/11/06/SpringBoot-day-05/"/>
      <url>/2018/11/06/SpringBoot-day-05/</url>
      
        <content type="html"><![CDATA[<p>今天，学习Springboot中的SpringMVC的自动配置原理<br><a id="more"></a></p><p><a href="https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications" target="_blank" rel="noopener">Springboot的官方参考文档</a></p><h2 id="Spring-MVC-auto-configuration"><a href="#Spring-MVC-auto-configuration" class="headerlink" title="Spring MVC auto-configuration"></a>Spring MVC auto-configuration</h2><p>Spring Boot 自动配置好了SpringMVC</p><p>以下是SpringBoot对SpringMVC的默认配置:（<strong>WebMvcAutoConfiguration</strong>）</p><h3 id="ContentNegotiatingViewResolver-and-BeanNameViewResolver"><a href="#ContentNegotiatingViewResolver-and-BeanNameViewResolver" class="headerlink" title="ContentNegotiatingViewResolver and  BeanNameViewResolver"></a>ContentNegotiatingViewResolver and  BeanNameViewResolver</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean<br>@ConditionalOnBean(View.class)<br>@ConditionalOnMissingBean<br>public BeanNameViewResolver beanNameViewResolver() &#123;<br>BeanNameViewResolver resolver = new BeanNameViewResolver();<br>resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10);<br>return resolver;<br>&#125;<br><br>@Bean<br>@ConditionalOnBean(ViewResolver.class)<br>@ConditionalOnMissingBean(name = &quot;viewResolver&quot;, value = ContentNegotiatingViewResolver.class)<br>public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) &#123;<br>ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();<br>resolver.setContentNegotiationManager(<br>beanFactory.getBean(ContentNegotiationManager.class));<br>// ContentNegotiatingViewResolver uses all the other view resolvers to locate<br>// a view so it should have a high precedence<br>resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);<br>return resolver;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　1) 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何<br>　　渲染（转发？重定向？））</p><p>　　2) ContentNegotiatingViewResolver：组合所有的视图解析器的；</p><p>　　3) 如何定制：<font color="#FF3E96"><strong>我们可以自己给容器中添加一个视图解析器；ContentNegotiatingViewResolver会自动将其组合进来；</strong></font></p><h3 id="Support-for-serving-static-resources-including-support-for-WebJars"><a href="#Support-for-serving-static-resources-including-support-for-WebJars" class="headerlink" title="Support for serving static resources, including support for WebJars"></a>Support for serving static resources, including support for WebJars</h3><p>　　静态资源文件夹路径,webjars（上一天，我们已经学过了）</p><h3 id="Static-index-html-support"><a href="#Static-index-html-support" class="headerlink" title="Static  index.html support"></a>Static  index.html support</h3><p>　　静态首页index.html访问.</p><h3 id="Custom-Favicon-support"><a href="#Custom-Favicon-support" class="headerlink" title="Custom  Favicon support"></a>Custom  Favicon support</h3><p>　　favicon.ico图标的访问。</p><h3 id="自动注册了-Converter、GenericConverter、Formatter-beans"><a href="#自动注册了-Converter、GenericConverter、Formatter-beans" class="headerlink" title="自动注册了 Converter、GenericConverter、Formatter beans."></a>自动注册了 Converter、GenericConverter、Formatter beans.</h3><p>　　1）Converter：转换器； public String hello(User user)：类型转换使用Converter。</p><p>　　2）Formatter：格式化器； 2017.12.17===Date。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean        <br>@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date‐format&quot;)//在文件中配置日期格式化的规则<br>public Formatter&lt;Date&gt; dateFormatter() &#123;        <br>return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件            <br>&#125;<br></code></pre></td></tr></table></figure></p><p>　　3）<font color="#FF3E96"><strong>自己添加的格式化器转换器，我们只需要放在容器中即可.</strong></font></p><h3 id="HttpMessageConverters"><a href="#HttpMessageConverters" class="headerlink" title="HttpMessageConverters"></a>HttpMessageConverters</h3><p>　　1) HttpMessageConverter: SpringMVC用来转换Http请求和响应的；User—Json；</p><p>　　2) HttpMessageConverters:是从容器中获取所有的HttpMessageConverter；</p><p>　　3) <font color="#FF3E96"><strong>自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）</strong></font><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class MyConfiguration &#123;<br><br>    @Bean<br>    public HttpMessageConverters customConverters() &#123;<br>        HttpMessageConverter&lt;?&gt; additional = ...<br>        HttpMessageConverter&lt;?&gt; another = ...<br>        return new HttpMessageConverters(additional, another);//多参数<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="MessageCodesResolver"><a href="#MessageCodesResolver" class="headerlink" title="MessageCodesResolver"></a>MessageCodesResolver</h3><p>　　定义错误代码生成规则 (参考官方文档)</p><h3 id="ConfigurableWebBindingInitializer"><a href="#ConfigurableWebBindingInitializer" class="headerlink" title="ConfigurableWebBindingInitializer"></a>ConfigurableWebBindingInitializer</h3><p>　　1）数据绑定的功能</p><p>　　2）<font color="#FF3E96"><strong>我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）</strong></font><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">初始化WebDataBinder；<br>请求数据=====JavaBean；<br></code></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><font color="red"><strong>org.springframework.boot.autoconfigure.web：web的所有自动场景；</strong></font><p><strong>如果，你想使用Springboot的默认配置的Web功能，然后添加自己额外的Web组件，就：添加一个@Configuration的配置类，然后继承WebMvcConfigurerAdapter抽象类。（不能添加@EnableWebMvc注解）</strong></p><p><strong>如果，你不想使用Springboot的默认Web功能，那么，就：添加一个@Configuration的配置类，并且加上@EnableWebMvc注解，那么就你完全自定义SpringMVC组件。</strong></p><p>官网文档中，这么说明的：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration<br>(interceptors, formatters, view controllers etc.) you can add your own  @Configuration class of type<br>WebMvcConfigurerAdapter , but without  @EnableWebMvc . If you wish to provide custom instances of<br>RequestMappingHandlerMapping ,  RequestMappingHandlerAdapter or  ExceptionHandlerExceptionResolver<br>you can declare a  WebMvcRegistrationsAdapter instance providing such components.<br>If you want to take complete control of Spring MVC, you can add your own  @Configuration annotated with<br>@EnableWebMvc .<br></code></pre></td></tr></table></figure></p><hr><h2 id="扩展SpringMVC"><a href="#扩展SpringMVC" class="headerlink" title="扩展SpringMVC"></a>扩展SpringMVC</h2><p>我们以前开发SpringMVC的时候，都会在xml中配置如下设置（自定义配置）：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;mvc:view‐controller path=&quot;/hello&quot; view‐name=&quot;success&quot;/&gt;<br><br>&lt;mvc:interceptors&gt;<br>        &lt;mvc:interceptor&gt;<br>            &lt;mvc:mapping path=&quot;/hello&quot;/&gt;<br>            &lt;bean&gt;&lt;/bean&gt;<br>        &lt;/mvc:interceptor&gt;<br>    &lt;/mvc:interceptors&gt;<br></code></pre></td></tr></table></figure></p><p>那么现在呢？</p><font color="#FF3E96">编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc;</font><p>既保留了所有的Springboot自动配置，也能用我们扩展的配置；</p><p>在我们的昨天的项目中，在com.liuzhuo.springboot包下，创建config包，并且创建Myconfig类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class Myconfig extends WebMvcConfigurerAdapter &#123;<br><br>    @Override<br>    public void addViewControllers(ViewControllerRegistry registry) &#123;<br>        //super.addViewControllers(registry);<br><br>        //浏览器发送 /liuzhuo 请求来到 success<br>        registry.addViewController(&quot;/liuzhuo&quot;).setViewName(&quot;sucess&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>然后在resources下的templates中：创建sucess.html文件：<br><img src="/images/QQ截图20181106141537.png"></p><p>启动Springboot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/liuzhuo</code><br><img src="/images/QQ截图20181106141651.png"></p><p>说明：我们自己配置的映射url成功。</p><p>此时，我们不仅可以使用Springboot的默认Web的配置，还能使用自己额外添加的控制器映射。</p><hr><p>为什么，此时我们既能使用Springboot的默认配置，又能使用自己的配置呢？</p><p><strong>原理：</strong></p><p>1）查看WebMvcAutoConfiguration是SpringMVC的自动配置类</p><p>2）在WebMvcAutoConfiguration中，能发现一个静态内部类：WebMvcAutoConfigurationAdapter<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// Defined as a nested config to ensure WebMvcConfigurerAdapter is not read when not<br>// on the classpath<br>@Configuration<br>@Import(EnableWebMvcConfiguration.class)<br>@EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)<br>public static class WebMvcAutoConfigurationAdapter extends WebMvcConfigurerAdapter &#123;<br></code></pre></td></tr></table></figure></p><p>该类上面有一个注解：@Import(EnableWebMvcConfiguration.class)。说明导入了EnableWebMvcConfiguration类。</p><p>3）打开EnableWebMvcConfiguration类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration<br></code></pre></td></tr></table></figure></p><p>继承了DelegatingWebMvcConfiguration类，打开DelegatingWebMvcConfiguration类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;<br><br>      private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();<br><br>      //从容器中获取所有的WebMvcConfigurer    <br>      @Autowired(required = false)<br>      public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123;<br>          if (!CollectionUtils.isEmpty(configurers)) &#123;<br>              this.configurers.addWebMvcConfigurers(configurers);<br>             //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；      <br>             @Override    <br>             // public void addViewControllers(ViewControllerRegistry registry) &#123;<br>              //    for (WebMvcConfigurer delegate : this.delegates) &#123;<br>               //       delegate.addViewControllers(registry);<br>               //   &#125;<br>              &#125;<br>          &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 容器中所有的WebMvcConfigurer都会一起起作用</p><p>5) 我们的配置类也会被调用</p><p>效果：SpringMVC的自动配置和我们的扩展配置都会起作用</p><h2 id="全面接管SpringMVC"><a href="#全面接管SpringMVC" class="headerlink" title="全面接管SpringMVC"></a>全面接管SpringMVC</h2><p>SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了</p><p><strong>我们需要在配置类中添加@EnableWebMvc即可</strong></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能<br>@EnableWebMvc<br>@Configuration<br>public class MyMvcConfig extends WebMvcConfigurerAdapter &#123;<br>    @Override<br>    public void addViewControllers(ViewControllerRegistry registry) &#123;<br>       // super.addViewControllers(registry);<br>        //浏览器发送 /atguigu 请求来到 success<br>        registry.addViewController(&quot;/atguigu&quot;).setViewName(&quot;success&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接启动我们的应用：<br>在浏览器中输入：<code>http://localhost:8080/</code><br><img src="/images/QQ截图20181106143304.png"></p><p>默认的静态主页失效了。去掉@EnableWebMvc，静态主页映射就会成功。</p><p>静态主页映射：META-INF/resources、resourcs、static、public下的index.html都会映射：/**</p><hr><p>为啥配置了@EnableWebMvc注解，SpringBoot的默认配置会失效呢？</p><p><strong>原理：</strong></p><p>1）打开@EnableWebMvc注解：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Retention(RetentionPolicy.RUNTIME)<br>@Target(ElementType.TYPE)<br>@Documented<br>@Import(DelegatingWebMvcConfiguration.class)<br>public @interface EnableWebMvc &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>导入了DelegatingWebMvcConfiguration类。</p><p>2）打开DelegatingWebMvcConfiguration类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;<br><br>private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();<br><br><br>@Autowired(required = false)<br>public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123;<br>if (!CollectionUtils.isEmpty(configurers)) &#123;<br>this.configurers.addWebMvcConfigurers(configurers);<br>&#125;<br>&#125;<br><br>   ···<br><br>｝<br></code></pre></td></tr></table></figure></p><p>DelegatingWebMvcConfiguration类：配置了SpringMVC的基本设置。</p><p>3）打开WebMvcAutoConfiguration：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ConditionalOnWebApplication<br>@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class,<br>WebMvcConfigurerAdapter.class &#125;)<br>//容器中没有这个组件的时候，这个自动配置类才生效<br>@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)<br>@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)<br>@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class,<br>ValidationAutoConfiguration.class &#125;)<br>public class WebMvcAutoConfiguration &#123;<br></code></pre></td></tr></table></figure></p><p>上面的一个条件注解：@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</p><p>当没有WebMvcConfigurationSupport存在时，WebMvcAutoConfiguration自动配置才会生效。</p><p>而DelegatingWebMvcConfiguration就是WebMvcConfigurationSupport。</p><p>所以@EnableWebMvc将WebMvcConfigurationSupport组件导入进来，从而使WebMvcAutoConfiguration自动配置失效。</p><hr><p><strong>总结：</strong></p><p>推荐我们使用 SpringBoot的默认配置 + 自定义的配置，即：@Configuration + 继承WebMvcConfigurerAdapter 的配置类的形式。</p><p>我们完全自定义的模式：适合于简单、不负责的Web应用。</p><h2 id="如何修改SpringBoot的默认配置"><a href="#如何修改SpringBoot的默认配置" class="headerlink" title="如何修改SpringBoot的默认配置"></a>如何修改SpringBoot的默认配置</h2><p>模式：</p><p>1）、 SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）<br>　　　如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户<br>　　　配置的和自己默认的组合起来；</p><p>2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置</p><p>3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</p><h2 id="CRUD-restful实战"><a href="#CRUD-restful实战" class="headerlink" title="CRUD-restful实战"></a>CRUD-restful实战</h2><p><a href="https://pan.baidu.com/s/1_H3h5Vsw47R30mjldS68bA" target="_blank" rel="noopener">下载资料</a></p><p>下载完毕后。找到文档中的restful-crud-实验<br><img src="/images/QQ截图20181106150457.png"></p><h3 id="默认访问首页"><a href="#默认访问首页" class="headerlink" title="默认访问首页"></a>默认访问首页</h3><p>1）首先将目录下的静态页面，xxx.html导入到我们的项目中的template目录下：<br><img src="/images/QQ截图20181106150713.png" style="width:50%"></p><p>2）asserts目录放到static目录下：<br><img src="/images/QQ截图20181106150756.png" style="width:50%"></p><p>3) 将dao、entities放到com.liuzhuo.springboot包下：<br><img src="/images/QQ截图20181106151100.png" style="width:50%"></p><p>然后点击DepartmentDao、EmployeeDao，重写导入我们的Department、Employee的包名。</p><hr><p>4）启动应用：</p><p>在浏览器中输入：<code>http://localhost:8080/</code><br><img src="/images/QQ截图20181106151352.png"></p><p>发现出现的页面是：static下的index.html页面，而不是template下的index.html页面。<br><img src="/images/QQ截图20181106151609.png" style="width:50%"></p><p>因为静态主页会加载：META-INF/resources、resourcs、static、public下的index.html</p><p>所以，我们不要重新映射我们的主页。</p><p>在我们的config下的Myconfig配置中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class Myconfig extends WebMvcConfigurerAdapter &#123;<br><br>    @Override<br>    public void addViewControllers(ViewControllerRegistry registry) &#123;<br>        //super.addViewControllers(registry);<br>        registry.addViewController(&quot;/liuzhuo&quot;).setViewName(&quot;sucess&quot;);<br><br>        //添加主页的映射<br>        registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;);<br>        registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;);<br>        registry.addViewController(&quot;/login.html&quot;).setViewName(&quot;login&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>然后，将templates下的index.html 改为 login.html</p><p>重新启动应用：</p><p>在浏览器中输入：<br><code>http://localhost:8080/</code><br><code>http://localhost:8080/login.html</code><br><code>http://localhost:8080/index.html</code></p><p>都是以下的页面：<br><img src="/images/QQ截图20181106152941.png"></p><p>5）因为我们使用thymeleaf，所以需要在每个页面头部添加命名空间：</p><p>   <code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; &gt;<br></code></pre></td></tr></table></figure></p><p>6) 在我们的静态页面中使用了bootstrap，所以需要bootstrap的webjar：<br><img src="/images/QQ截图20181106153622.png"><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!--bootstrap的jar包--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.webjars&lt;/groupId&gt;<br>    &lt;artifactId&gt;bootstrap&lt;/artifactId&gt;<br>    &lt;version&gt;4.0.0&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>在我们的login.html页面的中。找到引用bootstrap的地方：</p><p>th:href=”@{/webjars/bootstrap/4.0.0/css/bootstrap.css}”</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!-- Bootstrap core CSS --&gt;<br>&lt;link href=&quot;asserts/css/bootstrap.min.css&quot; th:href=&quot;@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;&quot; rel=&quot;stylesheet&quot;&gt;<br></code></pre></td></tr></table></figure><p>查看有么有配置对？ctrl + 鼠标左键：能跳转到该文件处。</p><p>使用thymeleaf的th:href=”@{}”的好处：当我们给项目添加根目录时，也能自动帮我们添加上跟目录。</p><p>在application.properties中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">server.context-path=/curd<br></code></pre></td></tr></table></figure></p><p>启动应用：<br>浏览器中输入：<code>http://localhost:8080/</code><br><img src="/images/QQ截图20181106154552.png"></p><p>输入：<code>http://localhost:8080/curd</code><br><img src="/images/QQ截图20181106154631.png"></p><p>右键审查元素：<br><img src="/images/QQ截图20181106154730.png"></p><p><strong>能看到：link 中 href：自动帮我们添加上了curd的根目录</strong></p><p>7）修改我们的css配置路径：</p><p>在login.html中：<br>th:href=”@{/asserts/css/signin.css}”<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!-- Custom styles for this template --&gt;<br>&lt;link href=&quot;asserts/css/signin.css&quot; th:href=&quot;@&#123;/asserts/css/signin.css&#125;&quot; rel=&quot;stylesheet&quot;&gt;<br></code></pre></td></tr></table></figure></p><p>页面中的其他引入资源，依次类推改写完毕即可。</p><hr><h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p>以前，我们在SpringMVC中编写国际化时的步骤：</p><p>1）<strong>编写国际化配置文件</strong></p><p>2）使用ResourceBundleMessageSource管理国际化资源文件</p><p>3） 在页面使用fmt:message取出国际化内容（jsp引擎）</p><p>现在，使用Springboot开发的国际化的步骤：</p><p>1） 编写国际化配置文件，抽取页面需要显示的国际化消息</p><p>在resources下创建i18n文件来放置我们的国际化的配置文件。（国际化文件只能是properties）</p><p>然后创建login.properties（默认的国际化配置）、login_en_US.properties。</p><p>idea会帮我们自动生成 Resource Bundle ‘login’ 文件夹：<br><img src="/images/QQ截图20181106161921.png" style="width:50%"></p><p>然后，我们在 Resource Bundle ‘login’ 上面右键：new<br><img src="/images/QQ截图20181106162042.png"></p><p>点击加号：<br><img src="/images/QQ截图20181106162131.png" style="width:50%"></p><p>填写: 语言_国家（en_US）<br><img src="/images/QQ截图20181106162648.png" style="width:50%"></p><p>最后生成的效果：有三个国家化的配置文件：<br><img src="/images/QQ截图20181106162810.png" style="width:50%"></p><p>填写我们需要国际化的部分：</p><p>观察login页面，发现，我们需要五次国家化的部分。</p><p>login.tip (登入的标题)<br>login.username （用户名）<br>login.password （密码）<br>login.remembear （记住密码）<br>login.bt （登入按钮）</p><p>然后，随便点击一个国家化文件。在下角处切换视图：<strong>Resource Bund</strong><br><img src="/images/QQ截图20181106163314.png"></p><p>点击在该视图模式下的，左上角的加号：<br><img src="/images/QQ截图20181106163455.png"></p><p>填写key：<br><img src="/images/QQ截图20181106163605.png"></p><p>填写value：<br><img src="/images/QQ截图20181106165518.png"></p><p>依次类推：把<br>login.username （用户名）<br>login.password （密码）<br>login.remembear （记住密码）<br>login.bt （登入按钮）</p><p>添加上。</p><hr><p>2） SpringBoot自动配置好了管理国际化资源文件的组件(<strong>MessageSourceAutoConfiguration</strong>)</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@ConfigurationProperties(prefix = &quot;spring.messages&quot;)<br>public class MessageSourceAutoConfiguration &#123;<br>   <br>    /**<br> * Comma‐separated list of basenames (essentially a fully‐qualified classpath    <br> * location), each following the ResourceBundle convention with relaxed support for    <br> * slash based locations. If it doesn&apos;t contain a package qualifier (such as    <br> * &quot;org.mypackage&quot;), it will be resolved from the classpath root.    <br> */    <br>    private String basename = &quot;messages&quot;;      <br>    //我们的配置文件可以直接放在类路径下叫messages.properties；<br>   <br>        @Bean<br>public MessageSource messageSource() &#123;    <br>ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();        <br>   if (StringUtils.hasText(this.basename)) &#123;        <br>             //设置国际化资源文件的基础名（去掉语言国家代码的）<br>    messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(            <br>    StringUtils.trimAllWhitespace(this.basename)));                    <br>&#125;        <br>if (this.encoding != null) &#123;        <br>   messageSource.setDefaultEncoding(this.encoding.name());            <br>&#125;        <br>messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale);        <br>messageSource.setCacheSeconds(this.cacheSeconds);        <br>messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat);        <br>return messageSource;        <br>&#125;<br></code></pre></td></tr></table></figure><p>如果，我们的国际化文件的名字就是messages的话，而放在类路径下的话，我们直接就可以使用了。</p><p>但是，现在我们使用了i18n文件，所以，我们需要在application.properties配置文件中：配置国际化的信息：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">spring.messages.basename=i18n.login<br></code></pre></td></tr></table></figure></p><p>i18n文件夹，login是文件的名字。</p><p>3）修改login.html中的需要国际化的部分</p><p>我们从thymeleaf的官方文档中，看到了如果使用国际化的话，使用 <strong>#{}</strong><br><img src="/images/QQ截图20181106171830.png"></p><p>4）启动应用：<br><img src="/images/QQ截图20181106172121.png"></p><p>切换我们的地域语言：打开浏览器的设置（我使用的谷歌浏览器）<br><img src="/images/QQ截图20181106172353.png"></p><p>刷新浏览器：<br><img src="/images/QQ截图20181106172433.png"></p><p>以上为止，我们的国际化就搞定成功了。</p><p>效果：根据浏览器语言设置的信息切换了国际化。</p><hr><p><strong>原理：</strong></p><p>国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）；</p><p>打开WebMvcAutoConfiguration类：寻找与国际化有关的类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean<br>@ConditionalOnMissingBean<br>@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)<br>public LocaleResolver localeResolver() &#123;<br>if (this.mvcProperties<br>.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123;<br>return new FixedLocaleResolver(this.mvcProperties.getLocale());<br>&#125;<br>AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();<br>localeResolver.setDefaultLocale(this.mvcProperties.getLocale());<br>return localeResolver;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>通过此类：我们能发现，Springboot给我们配置的默认的国家化Locale的是一个AcceptHeaderLocaleResolver。</p><p>AcceptHeaderLocaleResolver：是通过每次请求时，在请求头在获取请求的语言来进行国际化识别的。</p><p>启动我们的应用：<br><img src="/images/QQ截图20181106174300.png"><br><img src="/images/QQ截图20181106174349.png" style="width:50%"></p><p>我们发现了Accept-Language：zh-CN.</p><p>修改我们的浏览器的语言：<br><img src="/images/QQ截图20181106174539.png"></p><p>再次访问我们的登入页面：<br><img src="/images/QQ截图20181106174658.png" style="width:50%"><br>我们发现了Accept-Language：en-US.</p><p>这就是Springboot的默认的国际化原理。</p><hr><p>我们想要自己自定义国际化配置，该怎么办呢？</p><p>Springboot的默认国际化：localeResolver上面有一个注解：@ConditionalOnMissingBean</p><p>意思就是：当我们的容器中不存在localeResolver，才会使用默认的AcceptHeaderLocaleResolver。</p><p>所以，我们只需要向容器中，添加我们的localeResolver即可，默认的localeResolver就会失效。</p><hr><p>1）在component包下：创建MyLocaleResolver类(实现LocaleResolver)：</p><p><img src="/images/QQ截图20181106175524.png"></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyLocaleResolver implements LocaleResolver &#123;<br><br><br>    @Override<br>    public Locale resolveLocale(HttpServletRequest request) &#123;<br><br>        //获取请求的参数信息<br>        String language = request.getParameter(&quot;language&quot;);<br>        //获取默认的地域信息。<br>        Locale locale = Locale.getDefault();<br><br>        if (!StringUtils.isEmpty(language)) &#123;<br>            String[] split = language.split(&quot;_&quot;);<br>            //第一个参数：语言信息<br>            //第二个参数：国家信息<br>            locale = new Locale(split[0], split[1]);<br>        &#125;<br>        return locale;<br>    &#125;<br><br>    @Override<br>    public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2）将我们的LocaleResolver添加到容器中：</p><p>在Myconfig类中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean<br>public LocaleResolver localeResolver() &#123;<br>    return new MyLocaleResolver();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3）修改login.html页面：<br><img src="/images/QQ截图20181106180204.png"></p><p>4）启动应用：</p><p>点击底下的：中文<br><img src="/images/QQ截图20181106180248.png"></p><p>点击底下的：English<br><img src="/images/QQ截图20181106180353.png"></p><p>我们自定义的国际化解析器成功！</p><hr><p><strong>发现：在此时，不管我们将浏览器中的语言设置什么，我们的默认登入都是中文的</strong></p><p>因为，此时：我们使用的是自己的LocaleResovler：</p><p>当获取的language：String language = request.getParameter(“language”);<br>为空时，我们的Locale locale = Locale.getDefault();是获取的是本地的，我们这里就是中文。<br>不再是使用请求头中的那种方式了。</p><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p>1）修改我们的登入页面：login.html</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;form class=&quot;form-signin&quot; action=&quot;dashboard.html&quot; th:action=&quot;@&#123;/user/login&#125;&quot; method=&quot;post&quot;&gt;<br></code></pre></td></tr></table></figure><p>登入的action改为：/user/login。请求方式：post。</p><p>2）在controller包下，创建LoginController：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Controller<br>public class LoginController &#123;<br><br>    //@RequestMapping(value = &quot;/user/login&quot;,method = RequestMethod.POST)<br>    @PostMapping(value = &quot;/user/login&quot;)<br>    public String login(@RequestParam(&quot;username&quot;) String username,<br>                        @RequestParam(&quot;password&quot;) String password,<br>                        Map&lt;String, Object&gt; map) &#123;<br><br>        if (!StringUtils.isEmpty(username) &amp;&amp;<br>                !StringUtils.isEmpty(password) &amp;&amp;<br>                &quot;admin&quot;.equals(username) &amp;&amp;<br>                &quot;123456&quot;.equals(password)) &#123;<br>            //登入成功！<br>            return &quot;dashboard&quot;;<br>        &#125; else &#123;<br>            //登入失败！<br>            map.put(&quot;msg&quot;, &quot;登入用户名或密码错误！&quot;);<br>            return &quot;login&quot;;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 启动项目：</p><p>输入用户名和密码<br><img src="/images/QQ截图20181106213523.png"></p><p>报错了：<br><img src="/images/QQ截图20181106213554.png"></p><p>原来是我们的login.html页面，没有给username和password添加name属性！<br>现在添加上：<br><img src="/images/QQ截图20181106213732.png"></p><p>重启项目，并添加正确的用户名和密码（admin，123456）<br><img src="/images/QQ截图20181106213924.png"></p><p><strong>注意：</strong></p><p>1）此时有可能还是刚刚的错误，因为thymeleaf默认是开启缓存功能的，所以我们开发的时候，要记住关闭缓存的功能<br>在配置文件中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">spring.thymeleaf.cache=false<br></code></pre></td></tr></table></figure></p><p>2）我们在项目启动的时候，修改页面后，直接刷新页面，还是不会变的，要在修改后的页面处：ctrl+F9（重新编译页面）</p><p>使用（1）和（2）之后，就可以在项目启动的时候，直接修改页面也能得到最新的体验了。</p><hr><p>现在，我们输入错误的用户名和密码：不会出现错误的信息。</p><p>怎么添加错误的信息在页面上呢？</p><p>给login.html页面添加一个</p><p>标签<br><img src="/images/QQ截图20181106214738.png"></p><p>当msg不为空时，才会出现错误的<code>&lt;p&gt;标签。</code></p><p>重启项目：输入错误的用户名和密码<br><img src="/images/QQ截图20181106214945.png"></p><p>现在错误提示也完成了，再次输入正确的用户名和密码，<strong>现在一不小心按了F5，刷新了页面</strong><br><img src="/images/QQ截图20181106215200.png"></p><p>发现出现了是否重新提交表单的情况，因为我们的后端是转发到登入成功页面的，地址栏还是之前的登入页面的地址，所以刷新会出现这种情况。</p><p>现在修改后端的代码，将其改为重定向。</p><p>在LoginController中：<br><img src="/images/QQ截图20181106215826.png"><br>在Myconfig中：<br><img src="/images/QQ截图20181106215631.png"></p><p>重启我们的应用：输入正确的用户名和密码<br><img src="/images/QQ截图20181107095619.png"></p><p>什么？404？main.html没有找到？why？</p><p>当我们看到地址栏时，发现我们重定向时：是在/user下重定向的，所以找不到main.html。</p><p><strong>所以，在控制器Controller中：<code>return &quot;redirect:main.html&quot;;</code> main的前面不加<code>/</code>的话<br>会在@PostMapping(value = “/user/login”)中去掉最后一个路径下重定向，即在/user下重定向。<br>如果是@PostMapping(value = “/user/liuzhuo/login”)的话，就在/user/liuzhuo下重定向。</strong></p><p>怎样在我们的根路径下重定向呢？即在我们的<code>/crud</code>根路径下重定向。只需在main的前面加<code>/</code>即可：<br><code>return &quot;redirect:/main.html&quot;;</code></p><p>修改完毕后，重启我们的应用：输入正确的用户名和密码：<br><img src="/images/QQ截图20181107100653.png"></p><p>发现样式也正确了。因为是重定向而来的。<strong>此时刷新页面，也不会重发请求了。</strong></p><h3 id="拦截器进行登陆检查"><a href="#拦截器进行登陆检查" class="headerlink" title="拦截器进行登陆检查"></a>拦截器进行登陆检查</h3><p>此时，我们在另一个浏览器中：直接输入<code>http://localhost:8080/curd/main.html</code>.<br><img src="/images/QQ截图20181107101109.png"></p><p>发现，没有登入就直接进来了，这是因为加拦截器的缘故。</p><p>1）在component包下：创建LoginHandleInterceptor：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class LoginHandleInterceptor implements HandlerInterceptor &#123;<br><br>    //在方法执行之前，调用。<br>    @Override<br>    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;<br>        //从session中获取是否有loginUser属性的值<br>        Object loginUser = request.getSession().getAttribute(&quot;loginUser&quot;);<br>        if (StringUtils.isEmpty(loginUser)) &#123;<br>            //没有成功登入过。<br>            //转发登入页面<br>            request.getRequestDispatcher(&quot;/login.html&quot;).forward(request, response);<br>            return false;<br>        &#125; else &#123;<br>            //成功登入过<br>            return true;<br>        &#125;<br><br>    &#125;<br><br>    @Override<br>    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;<br><br>    &#125;<br><br>    @Override<br>    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2）将我们自己定义的拦截器添加到拦截器链中：</p><p>　　在Myconfig类中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>public void addInterceptors(InterceptorRegistry registry) &#123;<br>    //super.addInterceptors(registry);<br>    //添加拦截器我们自定义的拦截器<br>    registry.addInterceptor(new LoginHandleInterceptor())<br>            .addPathPatterns(&quot;/**&quot;) //拦截路径：/**:拦截所有的请求<br>            .excludePathPatterns(&quot;/&quot;,&quot;/index.html&quot;,&quot;/login.html&quot;,&quot;/user/login&quot;);//排除登入和登入请求的拦截路径<br>&#125;<br></code></pre></td></tr></table></figure></p><p><b><code>这里虽然是拦截了所有的请求（/**），但是静态资源是不会被拦截的，Springboot已经帮我们排除掉了，所以放心使用.</code></b></p><p>3) 在我们的登入控制器LoginController中添加session的操作：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">if (!StringUtils.isEmpty(username) &amp;&amp;<br>        !StringUtils.isEmpty(password) &amp;&amp;<br>        &quot;admin&quot;.equals(username) &amp;&amp;<br>        &quot;123456&quot;.equals(password)) &#123;<br>    //登入成功！<br>    //将用户名放入到session当中<br>    session.setAttribute(&quot;loginUser&quot;, username);<br>    //重定向到我们指定的登入成功的页面<br>    return &quot;redirect:/main.html&quot;;<br></code></pre></td></tr></table></figure></p><p>4) 重启我们的应用。</p><p>在谷歌浏览器中，成功登入成功后，直接输入：<code>http://localhost:8080/curd/main.html</code><br><img src="/images/QQ截图20181107103005.png"></p><p>发现，可以直接直接访问，因为已经成功登入过了，在session中已经保存了我们的用户信息。</p><p>在另外的浏览器中，直接输入：<code>http://localhost:8080/curd/main.html</code><br><img src="/images/QQ截图20181107103240.png"></p><p>会转发到我们的登入页面，因为是转发，所以地址栏不变。</p><hr><h3 id="CRUD-员工列表"><a href="#CRUD-员工列表" class="headerlink" title="CRUD-员工列表"></a>CRUD-员工列表</h3><p>实验要求：</p><p>1) RestfulCRUD：CRUD满足Rest风格</p><p>URI： /资源名称/资源标识 　HTTP请求方式区分对资源CRUD操作<br><img src="/images/QQ截图20181107114154.png"></p><p>2) 实验的请求架构<br><img src="/images/QQ截图20181107114230.png"></p><p>3) 员工列表：</p><p><strong>thymeleaf公共页面元素抽取</strong></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">1、抽取公共片段<br>&lt;div th:fragment=&quot;copy&quot;&gt;<br>   &amp;copy; 2011 The Good Thymes Virtual Grocery<br>&lt;/div&gt;<br><br>2、引入公共片段<br>&lt;div th:insert=&quot;~&#123;footer :: copy&#125;&quot;&gt;&lt;/div&gt;<br>~&#123;templatename::selector&#125;：模板名::选择器<br>~&#123;templatename::fragmentname&#125;:模板名::片段名<br><br>模板名就是：aaa.html中的aaa<br>片段名就是：th:fragment=&quot;bbb&quot;中的bbb<br>选择器就是：id选择器，class选择器等<br><br>3、默认效果：<br>insert的公共片段在div标签中<br>如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：<br>行内写法必须加上：[[~&#123;&#125;]] ：不转义特殊字符（/n） 、  [(~&#123;&#125;)] ：转义特殊字符<br></code></pre></td></tr></table></figure><p>三种引入公共片段的th属性：</p><p>th:insert：将公共片段整个插入到声明引入的元素中</p><p>th:replace：将声明引入的元素替换为公共片段</p><p>th:include：将被引入的片段的内容包含进这个标签中</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;footer th:fragment=&quot;copy&quot;&gt;<br>&amp;copy; 2011 The Good Thymes Virtual Grocery<br>&lt;/footer&gt;<br><br><br>引入方式:<br>&lt;div th:insert=&quot;footer :: copy&quot;&gt;&lt;/div&gt;<br>&lt;div th:replace=&quot;footer :: copy&quot;&gt;&lt;/div&gt;<br>&lt;div th:include=&quot;footer :: copy&quot;&gt;&lt;/div&gt;<br><br>效果:<br>&lt;div&gt;<br>    &lt;footer&gt;<br>    &amp;copy; 2011 The Good Thymes Virtual Grocery<br>    &lt;/footer&gt;<br>&lt;/div&gt;<br><br><br>&lt;footer&gt;<br>&amp;copy; 2011 The Good Thymes Virtual Grocery<br>&lt;/footer&gt;<br><br><br>&lt;div&gt;<br>&amp;copy; 2011 The Good Thymes Virtual Grocery<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>1) 将登入成功后的dashboard.html页面中的顶部和左边的侧单栏抽取出来：</p><p>在templates下：创建page文件夹，并创建两个html页面：<br><img src="/images/QQ截图20181107154114.png" style="width:50%"></p><p>top.html页面：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>    &lt;nav th:fragment=&quot;top&quot; class=&quot;navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0&quot;&gt;<br>        &lt;a class=&quot;navbar-brand col-sm-3 col-md-2 mr-0&quot; href=&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;&gt;[[$&#123;session.loginUser&#125;]]&lt;/a&gt;<br>        &lt;input class=&quot;form-control form-control-dark w-100&quot; type=&quot;text&quot; placeholder=&quot;Search&quot; aria-label=&quot;Search&quot;&gt;<br>        &lt;ul class=&quot;navbar-nav px-3&quot;&gt;<br>            &lt;li class=&quot;nav-item text-nowrap&quot;&gt;<br>                &lt;a class=&quot;nav-link&quot; href=&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;&gt;退出&lt;/a&gt;<br>            &lt;/li&gt;<br>        &lt;/ul&gt;<br>    &lt;/nav&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></p><p>主要是其中的<code>&lt;nav&gt;&lt;/nav&gt;</code>片段，这个片段是dashboard.html中的顶部的片段复制过来的。</p><p>其中主要是在<code>&lt;nav&gt;</code>中加入了<strong>th:fragment=”top”</strong>属性</p><p>slide.html页面：<br><img src="/images/QQ截图20181107154633.png"></p><p>其中的<code>&lt;nav&gt;</code>片段：是dashboard.html中的左边的侧单栏的部分复制过来的。</p><p>其中，主要加入了：<strong>id：slide</strong> 的属性。</p><p>2）修改dashboard.html页面的顶部与左边部分：<br><img src="/images/QQ截图20181107155129.png"></p><p>3）启动应用，运行发现顶部与左部运行完好。</p><hr><p>现在，我们开始完成员工信息的部分；即：左单栏的Customer部分。</p><p>1）将templates下的list.html页面放到empl目录下，这样分文件夹管理更加合理<br><img src="/images/QQ截图20181107155615.png" style="width:50%"></p><p>2）修改dashboard.html中的Customer部分的action属性：<br>因为左部已经抽取到slide.html页面，所以到slide.html页面中修改：</p><p>修改之前：<br><img src="/images/QQ截图20181107155857.png"></p><p>修改之后：将Customer改为员工信息，修改a标签的href<br><img src="/images/QQ截图20181107160209.png"></p><p>3）controller包下，创建EmployeeController：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Controller<br>public class EmployeeController &#123;<br><br>    @Autowired<br>    private EmployeeDao employeeDao;<br><br>    @GetMapping(&quot;/emp&quot;)<br>    public String list(Model model) &#123;<br>        Collection&lt;Employee&gt; employees = employeeDao.getAll();<br>        model.addAttribute(&quot;employees&quot;, employees);<br>        return &quot;empl/list&quot;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 启动应用<br><img src="/images/QQ截图20181107160734.png"></p><p>点击：员工信息</p><p><img src="/images/QQ截图20181107160813.png"></p><p>此时员工信息里面还是Customer，因为没有抽取出公共部分。</p><p>修改list.html的顶部与左部，与dashboard.html类似。自己完成。</p><p>完成后的效果：<br><img src="/images/QQ截图20181107161524.png"></p><p>但是，我们发现此时<strong>左部的高亮部分还是Dashboard</strong></p><p>5）怎么修改高亮为员工信息呢？</p><p>thymeleaf模板引擎中，查看官方文档，发现可以有参数化的片段布局：8.2 Parameterizable fragment signatures<br><a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#parameterizable-fragment-signatures" target="_blank" rel="noopener">官方参考</a></p><p>引入片段的时候传入参数：</p><p><code>&lt;div th:replace=&quot;commons/bar::#sidebar(activeUri=&#39;emps&#39;)&quot;&gt;&lt;/div&gt;</code></p><p>即：就是在我们引入的同时，在后面加一个括号，里面填写：key=value。</p><p>修改dashboard.html页面：<br><img src="/images/QQ截图20181107164137.png"></p><p>修改list.html页面：<br><img src="/images/QQ截图20181107164221.png"></p><p>修改slide.html页面：</p><p>在Dashboard处：<br><img src="/images/QQ截图20181107164336.png"></p><p>在员工信息处：<br><img src="/images/QQ截图20181107164425.png"></p><p>重启我们的应用：</p><p>点击Dashboard，Dashboard高亮。</p><p><img src="/images/QQ截图20181107164640.png"></p><p>点击员工信息，员工信息高亮。</p><p><img src="/images/QQ截图20181107164704.png"></p><hr><p>6）将员工信息换成我们的后端传递过来的数据：</p><p>在list页面中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;main role=&quot;main&quot; class=&quot;col-md-9 ml-sm-auto col-lg-10 pt-3 px-4&quot;&gt;<br>    &lt;h2&gt;&lt;button class=&quot;btn btn-sm btn-success&quot;&gt;员工添加&lt;/button&gt;&lt;/h2&gt;<br>    &lt;div class=&quot;table-responsive&quot;&gt;<br>        &lt;table class=&quot;table table-striped table-sm&quot;&gt;<br>            &lt;thead&gt;<br>            &lt;tr&gt;<br>                &lt;th&gt;id&lt;/th&gt;<br>                &lt;th&gt;lastName&lt;/th&gt;<br>                &lt;th&gt;email&lt;/th&gt;<br>                &lt;th&gt;gender&lt;/th&gt;<br>                &lt;th&gt;department&lt;/th&gt;<br>                &lt;th&gt;birth&lt;/th&gt;<br>                &lt;th&gt;操作&lt;/th&gt;<br>            &lt;/tr&gt;<br>            &lt;/thead&gt;<br>            &lt;tbody&gt;<br>            &lt;tr th:each=&quot;empl:$&#123;employees&#125;&quot;&gt;<br>                &lt;td th:text=&quot;$&#123;empl.id&#125;&quot;&gt;1001&lt;/td&gt;<br>                &lt;td&gt;[[$&#123;empl.lastName&#125;]]&lt;/td&gt;<br>                &lt;td th:text=&quot;$&#123;empl.email&#125;&quot;&gt;5589584@qq.com&lt;/td&gt;<br>                &lt;td th:text=&quot;$&#123;empl.gender&#125;==&apos;0&apos;?&apos;女&apos;:&apos;男&apos;&quot;&gt;男&lt;/td&gt;<br>                &lt;td th:text=&quot;$&#123;empl.department.departmentName&#125;&quot;&gt;商业提升部&lt;/td&gt;<br>                &lt;td th:text=&quot;$&#123;#dates.format(empl.birth, &apos;yyyy-MM-dd HH:mm:ss&apos;)&#125;&quot;&gt;2018/11/1&lt;/td&gt;<br>                &lt;td&gt;<br>                    &lt;button class=&quot;btn btn-sm btn-primary&quot;&gt;编辑&lt;/button&gt;<br>                    &lt;button class=&quot;btn btn-sm btn-danger&quot;&gt;删除&lt;/button&gt;<br>                &lt;/td&gt;<br>            &lt;/tr&gt;<br>            &lt;/tbody&gt;<br>        &lt;/table&gt;<br>    &lt;/div&gt;<br>&lt;/main&gt;<br></code></pre></td></tr></table></figure></p><p>ctrl+F9:<br><img src="/images/QQ截图20181107170503.png"></p><h3 id="员工列表的添加"><a href="#员工列表的添加" class="headerlink" title="员工列表的添加"></a>员工列表的添加</h3><p>首先将员工信息的url换成/empls:代表获取所有的员工信息，而/empl：代表添加员工的信息。</p><p>1.将员工添加的按钮换成a标签：<br><img src="/images/QQ截图20181107172030.png"></p><p>2.在EmployeeController中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Autowired<br>private DepartmentDao departmentDao;<br><br><br>@GetMapping(&quot;/empl&quot;)<br>public String add(Model model) &#123;<br><br>    //获取所有的部门信息：<br>    Collection&lt;Department&gt; departments = departmentDao.getDepartments();<br>    model.addAttribute(&quot;departments&quot;, departments);<br>    return &quot;empl/employee&quot;;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3.在templates下的empl中添加employee.html页面：</p><p>首先，直接复制list.html为employee.html。</p><p>然后，修改其中的main标签部分：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;main role=&quot;main&quot; class=&quot;col-md-9 ml-sm-auto col-lg-10 pt-3 px-4&quot;&gt;<br>    &lt;form&gt;<br>        &lt;div class=&quot;form‐group&quot;&gt;<br>            &lt;label&gt;LastName&lt;/label&gt;<br>            &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt;<br>        &lt;/div&gt;<br>        &lt;br&gt;<br>        &lt;div class=&quot;form‐group&quot;&gt;<br>             &lt;label&gt;Email&lt;/label&gt;<br>             &lt;input type=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan@atguigu.com&quot;&gt;<br>        &lt;/div&gt;<br>        &lt;br&gt;<br>        &lt;div class=&quot;form‐group&quot;&gt;<br>            &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt;<br>            &lt;div class=&quot;form‐check form‐check‐inline&quot;&gt;<br>                 &lt;input class=&quot;form‐check‐input&quot; type=&quot;radio&quot; name=&quot;gender&quot;   value=&quot;1&quot;&gt;<br>                 &lt;label class=&quot;form‐check‐label&quot;&gt;男&lt;/label&gt;<br>            &lt;/div&gt;<br>            &lt;div class=&quot;form‐check form‐check‐inline&quot;&gt;<br>                 &lt;input class=&quot;form‐check‐input&quot; type=&quot;radio&quot; name=&quot;gender&quot;   value=&quot;0&quot;&gt;<br>                 &lt;label class=&quot;form‐check‐label&quot;&gt;女&lt;/label&gt;<br>            &lt;/div&gt;<br>        &lt;/div&gt;<br>        &lt;br&gt;<br>        &lt;div class=&quot;form‐group&quot;&gt;<br>             &lt;label&gt;department&lt;/label&gt;<br>             &lt;select class=&quot;form-control&quot;&gt;<br>                &lt;option&gt;1&lt;/option&gt;<br>                &lt;option&gt;2&lt;/option&gt;<br>                &lt;option&gt;3&lt;/option&gt;<br>                &lt;option&gt;4&lt;/option&gt;<br>                &lt;option&gt;5&lt;/option&gt;<br>             &lt;/select&gt;<br>        &lt;/div&gt;<br>        &lt;br&gt;<br>        &lt;div class=&quot;form‐group&quot;&gt;<br>             &lt;label&gt;Birth&lt;/label&gt;<br>             &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt;<br>        &lt;/div&gt;<br>        &lt;br&gt;<br>        &lt;button type=&quot;submit&quot; class=&quot;btn btn-sm btn-primary&quot;&gt;添加&lt;/button&gt;<br>    &lt;/form&gt;<br><br>&lt;/main&gt;<br></code></pre></td></tr></table></figure></p><p>4.重启应用：<br><img src="/images/QQ截图20181107174348.png"></p><p>5.此时的department部分还是死数据：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div class=&quot;form‐group&quot;&gt;<br>     &lt;label&gt;department&lt;/label&gt;<br>     &lt;select class=&quot;form-control&quot;&gt;<br>        &lt;option th:value=&quot;$&#123;dept.id&#125;&quot; th:text=&quot;$&#123;dept.departmentName&#125;&quot; th:each=&quot;dept:$&#123;departments&#125;&quot;&gt;1&lt;/option&gt;<br>     &lt;/select&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></p><p>刷新页面：<br><img src="/images/QQ截图20181107174754.png"></p><p>6.给form表单添加action和method属性：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;form th:action=&quot;@&#123;/empl&#125;&quot; method=&quot;post&quot;&gt;<br></code></pre></td></tr></table></figure></p><p>7.书写添加员工的控制器<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//添加员工<br>@PostMapping(&quot;/empl&quot;)<br>public String addEmployee(Employee employee) &#123;<br><br>    System.out.println(employee);<br>    //添加员工<br>    employeeDao.save(employee);<br><br>    return &quot;redirect:/empls&quot;;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>8.重启应用，点击添加：<br><img src="/images/QQ截图20181107183750.png"><br><img src="/images/QQ截图20181107183847.png"></p><p>添加失败？因为我们的表单里面木有给属性添加name。<br>现在全部加上。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;input type=&quot;text&quot; th:name=&quot;lastName&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt;<br><br>   &lt;input type=&quot;email&quot; th:name=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan@atguigu.com&quot;&gt;<br><br>   &lt;select class=&quot;form-control&quot; th:name=&quot;department.id&quot;&gt;<br><br> &lt;input type=&quot;text&quot; th:name=&quot;birth&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt;<br></code></pre></td></tr></table></figure><p>然后再次尝试添加：<br><img src="/images/QQ截图20181107184848.png"></p><p>添加成功！！！</p><p><strong>注意：这里填写生日的格式必须是 xxxx/xx/xx 的形式。其他形式就会出错，因为Springboot默认格式化的日期格式就是xxxx/xx/xx 的形式</strong></p><p>如果，我们想改日期的格式呢？</p><p>打开WebMvcAutoConfiguration类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean<br>@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date-format&quot;)<br>public Formatter&lt;Date&gt; dateFormatter() &#123;<br>return new DateFormatter(this.mvcProperties.getDateFormat());<br>&#125;<br></code></pre></td></tr></table></figure></p><p>默认帮我们配置好的时间格式转化器。</p><p>点击：getDateFormat()：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public String getDateFormat() &#123;<br>return this.dateFormat;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>再点击：this.dateFormat<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">/**<br> * Date format to use (e.g. dd/MM/yyyy).<br> */<br>private String dateFormat;<br></code></pre></td></tr></table></figure></p><p>说明默认的确实是：dd/MM/yyyy的形式。</p><p>想要修改默认的格式：只需要在application.properties文件中修改spring.mvc.date-format=xxxx即可：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">#修改日期的格式<br>spring.mvc.date-format=yyyy-MM-dd<br></code></pre></td></tr></table></figure></p><hr><h3 id="员工列表的编辑"><a href="#员工列表的编辑" class="headerlink" title="员工列表的编辑"></a>员工列表的编辑</h3><p>修改添加二合一表单</p><p>1）首先修改编辑按钮：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;a th:href=&quot;@&#123;/empl/&#125;+$&#123;empl.id&#125;&quot; class=&quot;btn btn-sm btn-primary&quot;&gt;编辑&lt;/a&gt;<br></code></pre></td></tr></table></figure></p><p>2) EmployeeController中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//去编辑员工的页面<br>@GetMapping(&quot;/empl/&#123;id&#125;&quot;)<br>public String toEditPage(@PathVariable(&quot;id&quot;) Integer id, Model model) &#123;<br><br>    //获取员工的信息：<br>    Employee employee = employeeDao.get(id);<br>    model.addAttribute(&quot;employee&quot;,employee);<br><br>    //获取所有的部门信息：<br>    Collection&lt;Department&gt; departments = departmentDao.getDepartments();<br>    model.addAttribute(&quot;departments&quot;, departments);<br><br>    //重定向到编辑员工的页面（add页面一样，共用）<br>    return &quot;empl/employee&quot;;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 在employee.html页面中回显员工的信息。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;form th:action=&quot;@&#123;/empl&#125;&quot; method=&quot;post&quot;&gt;<br>    &lt;div class=&quot;form‐group&quot;&gt;<br>        &lt;label&gt;LastName&lt;/label&gt;<br>        &lt;input type=&quot;text&quot; th:value=&quot;$&#123;employee.lastName&#125;&quot; th:name=&quot;lastName&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt;<br>    &lt;/div&gt;<br>    &lt;br&gt;<br>    &lt;div class=&quot;form‐group&quot;&gt;<br>         &lt;label&gt;Email&lt;/label&gt;<br>         &lt;input type=&quot;email&quot; th:value=&quot;$&#123;employee.email&#125;&quot; th:name=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan@atguigu.com&quot;&gt;<br>    &lt;/div&gt;<br>    &lt;br&gt;<br>    &lt;div class=&quot;form‐group&quot;&gt;<br>        &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt;<br>        &lt;div class=&quot;form‐check form‐check‐inline&quot;&gt;<br>             &lt;input class=&quot;form‐check‐input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:checked=&quot;$&#123;employee.gender&#125;==1&quot;&gt;<br>             &lt;label class=&quot;form‐check‐label&quot;&gt;男&lt;/label&gt;<br>        &lt;/div&gt;<br>        &lt;div class=&quot;form‐check form‐check‐inline&quot;&gt;<br>             &lt;input class=&quot;form‐check‐input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:checked=&quot;$&#123;employee.gender&#125;==0&quot;&gt;<br>             &lt;label class=&quot;form‐check‐label&quot;&gt;女&lt;/label&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>    &lt;br&gt;<br>    &lt;div class=&quot;form‐group&quot;&gt;<br>         &lt;label&gt;department&lt;/label&gt;<br>         &lt;select class=&quot;form-control&quot; th:name=&quot;department.id&quot;&gt;<br>        &lt;option th:selected=&quot;$&#123;employee.department.id&#125;==$&#123;dept.id&#125;&quot; th:value=&quot;$&#123;dept.id&#125;&quot; th:text=&quot;$&#123;dept.departmentName&#125;&quot; th:each=&quot;dept:$&#123;departments&#125;&quot;&gt;1<br>        &lt;/option&gt;<br>         &lt;/select&gt;<br>    &lt;/div&gt;<br>    &lt;br&gt;<br>    &lt;div class=&quot;form‐group&quot;&gt;<br>         &lt;label&gt;Birth&lt;/label&gt;<br>         &lt;input type=&quot;text&quot; th:value=&quot;$&#123;#dates.format(employee.birth, &apos;yyyy-MM-dd HH:mm:ss&apos;)&#125;&quot; th:name=&quot;birth&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt;<br>    &lt;/div&gt;<br>    &lt;br&gt;<br>    &lt;button type=&quot;submit&quot; class=&quot;btn btn-sm btn-primary&quot;&gt;添加&lt;/button&gt;<br>&lt;/form&gt;<br></code></pre></td></tr></table></figure></p><p>4) 重启应用，点击编辑<br><img src="/images/QQ截图20181107193709.png"></p><p><img src="/images/QQ截图20181107193721.png"></p><p>回显成功。</p><p>此时，再次点击添加时：<br><img src="/images/QQ截图20181107193842.png"></p><p>控制台：<br><img src="/images/QQ截图20181107193935.png"></p><p>这是因为，我们点击添加的时候，model对象中根本没有employee对象，所以employee.html中的：<br><strong>th:value=”${employee.lastName}”等都会出现空指针异常。</strong></p><p>5）再次修改employee.html页面：添加判断语句</p><p>${employee!=null}?</p><p>例如：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">th:value=&quot;$&#123;employee!=null&#125;?$&#123;employee.lastName&#125;&quot;<br></code></pre></td></tr></table></figure></p><p>此时：再次点击员工添加，就不会出现问题了。</p><p>6）button的按钮修改<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;button type=&quot;submit&quot; th:text=&quot;$&#123;employee!=null&#125;?&apos;修改&apos;:&apos;添加&apos;&quot; class=&quot;btn btn-sm btn-primary&quot;&gt;添加&lt;/button&gt;<br></code></pre></td></tr></table></figure></p><p>7）form表单的method的修改：</p><p>当是添加操作时，就是method=post提交。<br>当是修改操作时，就是method=put提交。</p><p>以前是SpringMVC的时候，想要使用put提交。</p><ol><li>SpringMVC中配置HiddenHttpMethodFilter;</li><li>页面创建一个post表单</li><li>创建一个input项，name=”_method”;值就是我们指定的请求方式</li></ol><p>Springboot已经默认帮我们配置好了HiddenHttpMethodFilter。在WebMvcAutoConfiguration中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean<br>@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)<br>public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() &#123;<br>return new OrderedHiddenHttpMethodFilter();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>所以，现在我们只需要添加一个input项，name=”_method”的标签即可：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;input type=&quot;hidden&quot; name=&quot;_method&quot;  value=&quot;put&quot; th:if=&quot;$&#123;employee!=null&#125;&quot;/&gt;<br>&lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:value=&quot;$&#123;employee.id&#125;&quot; th:if=&quot;$&#123;employee!=null&#125;&quot;/&gt;<br></code></pre></td></tr></table></figure></p><p>8) EmployeeController中添加编辑的逻辑：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//修改员工<br>@PutMapping(&quot;/empl&quot;)<br>public String EditEmployee(Employee employee) &#123;<br>    System.out.println(employee);<br>    //修改员工<br>    employeeDao.save(employee);<br>    return &quot;redirect:/empls&quot;;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>9) 随便点击一个员工进行修改：<br><img src="/images/QQ截图20181107195757.png"><br><img src="/images/QQ截图20181107195859.png"><br><img src="/images/QQ截图20181107195923.png"></p><p>修改成功！！！</p><h3 id="员工列表的删除"><a href="#员工列表的删除" class="headerlink" title="员工列表的删除"></a>员工列表的删除</h3><p>1）修改删除的按钮以delete的方式提交</p><p>不能简单的将button按钮标签改为a标签，因为a标签默认是get方式提交。</p><p>我们使用js的方式来提交表单：<br><img src="/images/QQ截图20181107202935.png"></p><p>2）添加js代码：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;script type=&quot;text/javascript&quot;&gt;<br>    $(&quot;.deleteBtn&quot;).click(function () &#123;<br>        var del_url = $(this).attr(&quot;del_url&quot;);<br>        $(&quot;#deleteEmpForm&quot;).attr(&quot;action&quot;, del_url).submit();<br>        //改变form默认的提交方式<br>        return false;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>3) EmployeeController中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//删除员工信息<br>@DeleteMapping(&quot;/empl/&#123;id&#125;&quot;)<br>public String deleteEmlp(@PathVariable(&quot;id&quot;) Integer id) &#123;<br>    //删除指定员工id的员工<br>    employeeDao.delete(id);<br>    return &quot;redirect:/empls&quot;;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 重启应用，试试删除按钮</p><hr>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot_day_04</title>
      <link href="/2018/11/05/SpringBoot-day-04/"/>
      <url>/2018/11/05/SpringBoot-day-04/</url>
      
        <content type="html"><![CDATA[<p>今天，我们开始Springboot的Web开发<br><a id="more"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>使用SpringBoot:</p><p><strong>1）、创建SpringBoot应用，选中我们需要的模块；</strong></p><p><strong>2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来.</strong></p><p><strong>3）、自己编写业务代码；</strong></p><p>想要使用SpringBoot的自动配置的功能，我们必须熟知SpringBoot的自动配置的原理。</p><p><strong>自动配置原理：</strong></p><p>这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx</p><p>自动配置原理，一般我们需要看：spring-boot-autoconfigure<br><img src="/images/QQ截图20181105134252.png" style="width:50%"></p><p>然后再看我们想要的模块里面的：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">xxxxAutoConfiguration：帮我们给容器中自动配置组件；<br>xxxxProperties:配置类来封装配置文件的内容；<br></code></pre></td></tr></table></figure></p><p>比如：Web模块，看DispatchServletAutoConfiguration<br><img src="/images/QQ截图20181105134739.png" style="width:50%"></p><h2 id="SpringBoot对静态资源的映射规则"><a href="#SpringBoot对静态资源的映射规则" class="headerlink" title="SpringBoot对静态资源的映射规则"></a>SpringBoot对静态资源的映射规则</h2><p>创建我们的今天的Web项目：（添加Web模块）<br><img src="/images/QQ截图20181105141110.png"></p><p>在：spring-boot-autoconfigurejar下：</p><p>web下的WebMvcAutoConfiguration：专门为我们配置了默认的Web应用的配置：<br><img src="/images/QQ截图20181105141946.png"></p><p><strong>设置：静态资源的相关配置的类：</strong></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)<br>public class ResourceProperties implements ResourceLoaderAware, InitializingBean &#123;<br><br>private static final String[] SERVLET_RESOURCE_LOCATIONS = &#123; &quot;/&quot; &#125;;<br><br>private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123;<br>&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,<br>&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;;<br><br>private static final String[] RESOURCE_LOCATIONS;<br><br>static &#123;<br>RESOURCE_LOCATIONS = new String[CLASSPATH_RESOURCE_LOCATIONS.length<br>+ SERVLET_RESOURCE_LOCATIONS.length];<br>System.arraycopy(SERVLET_RESOURCE_LOCATIONS, 0, RESOURCE_LOCATIONS, 0,<br>SERVLET_RESOURCE_LOCATIONS.length);<br>System.arraycopy(CLASSPATH_RESOURCE_LOCATIONS, 0, RESOURCE_LOCATIONS,<br>SERVLET_RESOURCE_LOCATIONS.length, CLASSPATH_RESOURCE_LOCATIONS.length);<br>&#125;<br>   <br>   ·····<br><br>  //可以设置和静态资源有关的参数，缓存时间等<br></code></pre></td></tr></table></figure><p><strong>设置静态资源映射的默认方法：</strong></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;<br>if (!this.resourceProperties.isAddMappings()) &#123;<br>logger.debug(&quot;Default resource handling disabled&quot;);<br>return;<br>&#125;<br>Integer cachePeriod = this.resourceProperties.getCachePeriod();<br>if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123;<br>customizeResourceHandlerRegistration(registry<br>.addResourceHandler(&quot;/webjars/**&quot;)<br>.addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)<br>.setCachePeriod(cachePeriod));<br>&#125;<br>String staticPathPattern = this.mvcProperties.getStaticPathPattern();<br>if (!registry.hasMappingForPattern(staticPathPattern)) &#123;<br>customizeResourceHandlerRegistration(<br>registry.addResourceHandler(staticPathPattern)<br>.addResourceLocations(<br>this.resourceProperties.getStaticLocations())<br>.setCachePeriod(cachePeriod));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="所有-webjars-，都去-classpath-META-INF-resources-webjars-找资源；"><a href="#所有-webjars-，都去-classpath-META-INF-resources-webjars-找资源；" class="headerlink" title="所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；"></a>所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；</h3><p>webjars：以jar包的方式引入静态资源.</p><p><a href="https://www.webjars.org/" target="_blank" rel="noopener">webjars官网</a></p><p>例子：引入jQuery的静态资源。</p><p>打开webjars官网，找到jQuery的Maven配置信息：<br><img src="/images/QQ截图20181105143244.png"></p><p>将拷贝的jQuery的Maven配置，导入到我们的项目中。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependency&gt;<br>    &lt;groupId&gt;org.webjars&lt;/groupId&gt;<br>    &lt;artifactId&gt;jquery&lt;/artifactId&gt;<br>    &lt;version&gt;3.3.1-1&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>在我们的依赖jar中，找到jQuery的依赖：<br><img src="/images/QQ截图20181105143645.png" style="width:50%"></p><p>发现，这个依赖的jar的目录格式，也是classpath:/META-INF/resources/webjars/</p><font color="red">所以：当我们访问/webjars/**的url时，SpringBoot会帮我们在classpath:/META-INF/resources/webjars/选择webjars的静态jar资源。</font><p>启动我们的项目：</p><p>在浏览器中输入：<code>http://localhost:8080/webjars/jquery/3.3.1-1/jquery.js</code><br><img src="/images/QQ截图20181105144226.png"></p><p>webjar的静态资源访问成功！</p><h3 id="访问当前项目的任何资源，都去（静态资源的文件夹）找映射"><a href="#访问当前项目的任何资源，都去（静态资源的文件夹）找映射" class="headerlink" title="/**  访问当前项目的任何资源，都去（静态资源的文件夹）找映射"></a>/**  访问当前项目的任何资源，都去（静态资源的文件夹）找映射</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">String staticPathPattern = this.mvcProperties.getStaticPathPattern();<br>if (!registry.hasMappingForPattern(staticPathPattern)) &#123;<br>customizeResourceHandlerRegistration(<br>registry.addResourceHandler(staticPathPattern)<br>.addResourceLocations(<br>this.resourceProperties.getStaticLocations())<br>.setCachePeriod(cachePeriod));<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，注册了 staticPathPattern 和 this.resourceProperties.getStaticLocations() 的静态资源访问。</p><p>点击：staticPathPattern：<code>private String staticPathPattern = &quot;/**&quot;;</code> </p><p>点击：getStaticLocations()：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123;<br>&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,<br>&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;;<br></code></pre></td></tr></table></figure></p><font color="red"><strong>总结</strong>：</font><p>对于：/** 的静态资源的访问。</p><p>会到以下的路径寻找静态资源：</p><p><strong>“classpath:/META‐INF/resources/“,</strong></p><p><strong>“classpath:/resources/“,</strong></p><p><strong>“classpath:/static/“,</strong></p><p><strong>“classpath:/public/“</strong></p><p>这里的”classpath”：就相当于我们项目的java、resources目录。</p><p>印证我们的默认的静态资源访问：</p><p>在以上的目录中随意放一张照片：<br><img src="/images/QQ截图20181105150445.png" style="width:50%"></p><p>三张，不同的照片，但是名字都是123.jpg的照片。</p><p>启动项目，在浏览器中输入：<code>http://localhost:8080/123.jpg</code></p><p><img src="/images/QQ截图20181105150124.png"></p><p>出现的是”META-INF/resources”下的123.jpg照片。 </p><p>删除”META-INF/resources”下的123.jpg照片. 再次访问是”classpath:/resources/“下的123.jpg</p><p>依次类推：再是”classpath:/static/“、”classpath:/public/“。</p><font color="red"><strong>优先级是：从上到下，依次递减</strong></font><hr><h3 id="欢迎页-静态资源文件夹下的所有index-html页面；被”-”映射"><a href="#欢迎页-静态资源文件夹下的所有index-html页面；被”-”映射" class="headerlink" title="欢迎页: 静态资源文件夹下的所有index.html页面；被”/**”映射"></a>欢迎页: 静态资源文件夹下的所有index.html页面；被”/**”映射</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean<br>public WelcomePageHandlerMapping welcomePageHandlerMapping(<br>ResourceProperties resourceProperties) &#123;<br>return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(),<br>this.mvcProperties.getStaticPathPattern());<br>&#125;<br></code></pre></td></tr></table></figure><p>getWelcomePage():<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">private String[] getStaticWelcomePageLocations() &#123;<br>String[] result = new String[this.staticLocations.length];<br>for (int i = 0; i &lt; result.length; i++) &#123;<br>String location = this.staticLocations[i];<br>if (!location.endsWith(&quot;/&quot;)) &#123;<br>location = location + &quot;/&quot;;<br>&#125;<br>result[i] = location + &quot;index.html&quot;;<br>&#125;<br>return result;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>getStaticPathPattern():<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">private String staticPathPattern = &quot;/**&quot;;<br></code></pre></td></tr></table></figure></p><p><b>即对:　/**　 的访问。SpringBoot会自动到刚刚我们的提到的静态资源的文件夹下找index.html的页面</b></p><p>localhost:8080/ 找index页面</p><hr><h3 id="所有的-favicon-ico-都是在静态资源文件下找"><a href="#所有的-favicon-ico-都是在静态资源文件下找" class="headerlink" title="所有的 **/favicon.ico 都是在静态资源文件下找"></a>所有的 **/favicon.ico 都是在静态资源文件下找</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean<br>public SimpleUrlHandlerMapping faviconHandlerMapping() &#123;<br>SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();<br>mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1);<br>mapping.setUrlMap(Collections.singletonMap(&quot;**/favicon.ico&quot;,<br>faviconRequestHandler()));<br>return mapping;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>JSP、Velocity、Freemarker、Thymeleaf<br><img src="/images/QQ截图20181105153402.png"></p><p>Springboot默认是不支持jsp模板引擎的，因为SpringBoot是打成jar包，使用嵌入式的Tomcat容器。</p><p>这里，我们使用SpringBoot官方推荐的Thymeleaf模板引擎。语法更简单，功能更强大</p><h3 id="引入thymeleaf"><a href="#引入thymeleaf" class="headerlink" title="引入thymeleaf"></a>引入thymeleaf</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!-- Springboot默认是：2.1.6 的版本 --&gt;  <br>&lt;dependency&gt;        <br>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            <br>  &lt;artifactId&gt;spring‐boot‐starter‐thymeleaf&lt;/artifactId&gt;            <br>&lt;/dependency&gt; <br>       <br>&lt;!-- 切换thymeleaf版本 --&gt;<br>&lt;properties&gt;<br>   &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt;        <br>   &lt;!‐‐ 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 ‐‐&gt;           <br>   &lt;thymeleaf‐layout‐dialect.version&gt;2.2.2&lt;/thymeleaf‐layout‐dialect.version&gt;        <br>  &lt;/properties&gt;<br></code></pre></td></tr></table></figure><p><strong>注意，SpringBoot默认导入的thymeleaf只是2.1.6的版本，如果想切换更高的版本，查看thymeleaf的github中的发行版</strong></p><p><a href="https://github.com/thymeleaf/thymeleaf/releases" target="_blank" rel="noopener">thymeleaf版本</a></p><p><strong>thymeleaf‐layout‐dialect.version：布局的版本，请注意，如果使用thymeleaf3以上的版本，那么布局的版本必须是2.0.0以上</strong>：<br><img src="/images/QQ截图20181105155420.png"></p><h3 id="Thymeleaf使用"><a href="#Thymeleaf使用" class="headerlink" title="Thymeleaf使用"></a>Thymeleaf使用</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)<br>public class ThymeleafProperties &#123;<br><br>private static final Charset DEFAULT_ENCODING = Charset.forName(&quot;UTF‐8&quot;);   <br> <br>private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(&quot;text/html&quot;); <br>   <br>public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;    <br><br>public static final String DEFAULT_SUFFIX = &quot;.html&quot;;    <br><br>   //<br>&#125;<br></code></pre></td></tr></table></figure><p>Springboot默认的themleaf配置：</p><p>使用UTF-8字码，媒体类型：text/html，模板解析的前缀：classpath:/templates/，模板解析的后缀：.html</p><p>即：只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染；</p><p>使用：</p><p>1、导入thymeleaf的名称空间：(在idea中会有相应的提示功能)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;<br></code></pre></td></tr></table></figure></p><p>2、使用thymeleaf语法</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF‐8&quot;&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;h1&gt;成功！&lt;/h1&gt;<br>    &lt;!‐‐th:text 将div里面的文本内容设置为 ‐‐&gt;<br>    &lt;div th:text=&quot;$&#123;hello&#125;&quot;&gt;这是显示欢迎信息&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><p><a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html" target="_blank" rel="noopener">thymeleaf参考手册</a></p><p>1）th:text；改变当前元素里面的文本内容；</p><p>th：任意html属性；来替换原生属性的值<br><img src="/images/QQ截图20181105163700.png"></p><p>2）表达式</p><p><strong>Simple expressions:（表达式语法）</strong></p><p>Variable Expressions: ${…}：获取变量值；OGNL；</p><p>1）、获取对象的属性、调用方法   </p><p>例如：＄{user.name}</p><p>2）、使用内置的基本对象：</p><p>　　　#ctx : the context object<br>　　　#vars: the context variables.<br>　　　#locale : the context locale.<br>　　　#request : (only in Web Contexts) the HttpServletRequest object.<br>　　　#response : (only in Web Contexts) the HttpServletResponse object.<br>　　　#session : (only in Web Contexts) the HttpSession object.<br>　　　#servletContext : (only in Web Contexts) the ServletContext object.</p><p>例如：${session.foo}</p><p>3）、内置的一些工具对象：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">#execInfo : information about the template being processed.<br>#messages : methods for obtaining externalized messages inside variables expressions<br>#uris : methods for escaping parts of URLs/URIs<br>#conversions : methods for executing the configured conversion service (if any).<br>#dates : methods for java.util.Date objects: formatting, component extraction, etc.<br>#calendars : analogous to #dates , but for java.util.Calendar objects.<br>#numbers : methods for formatting numeric objects.<br>#strings : methods for String objects: contains, startsWith, prepending/appending, etc.<br>#objects : methods for objects in general.<br>#bools : methods for boolean evaluation.<br>#arrays : methods for arrays.<br>#lists : methods for lists.<br>#sets : methods for sets.<br>#maps : methods for maps.<br>#aggregates : methods for creating aggregates on arrays or collections.<br>#ids : methods for dealing with id attributes that might be repeated<br></code></pre></td></tr></table></figure></p><hr><p><strong>Selection Variable Expressions: *{…}：选择表达式：和 ${} 在功能上是一样；</strong><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined"> 补充：配合 th:object=&quot;$&#123;session.user&#125;：    <br><br> &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt;<br>    &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;<br>    &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;<br>    &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;<br> &lt;/div&gt;<br> ---------------------------等价----------------------------------------<br>&lt;div&gt;<br>    &lt;p&gt;Name: &lt;span th:text=&quot;$&#123;session.user.firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;<br>    &lt;p&gt;Surname: &lt;span th:text=&quot;$&#123;session.user.lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;<br>    &lt;p&gt;Nationality: &lt;span th:text=&quot;$&#123;session.user.nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;<br> &lt;/div&gt;<br></code></pre></td></tr></table></figure></p><hr><p>其他表达式：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Message Expressions: #&#123;...&#125;：获取国际化内容<br><br>Link URL Expressions: @&#123;...&#125;：定义URL；<br>@&#123;/order/process(execId=$&#123;execId&#125;,execType=&apos;FAST&apos;)&#125; <br>       <br>Fragment Expressions: ~&#123;...&#125;：片段引用表达式<br>&lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt;<br><br>Literals（字面量）<br>      Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,…<br>      Number literals: 0 , 34 , 3.0 , 12.3 ,…<br>      Boolean literals: true , false<br>      Null literal: null<br>      Literal tokens: one , sometext , main ,…<br>Text operations:（文本操作）<br>    String concatenation: +<br>    Literal substitutions: |The name is $&#123;name&#125;|<br>Arithmetic operations:（数学运算）<br>    Binary operators: + , ‐ , * , / , %<br>    Minus sign (unary operator): ‐<br>Boolean operations:（布尔运算）<br>    Binary operators: and , or<br>    Boolean negation (unary operator): ! , not<br>Comparisons and equality:（比较运算）<br>    Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )<br>    Equality operators: == , != ( eq , ne )<br>Conditional operators:条件运算（三元运算符）<br>    If‐then: (if) ? (then)<br>    If‐then‐else: (if) ? (then) : (else)<br>    Default: (value) ?: (defaultvalue)<br>Special tokens:<br>    No‐Operation: _<br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot_day_03</title>
      <link href="/2018/11/04/SpringBoot-day-03/"/>
      <url>/2018/11/04/SpringBoot-day-03/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot的日志框架与配置<br><a id="more"></a></p><h1 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h1><p>小张；开发一个大型系统；<br>1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？<br>2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar；<br>3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？<br>4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar；<br>5、JDBC—数据库驱动；<br>写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar；<br>给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层；</p><hr><p><strong>市面上的日志框架</strong></p><p>JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j….</p><p><img src="/images/QQ截图20181104094606.png"></p><p>左边选一个门面（抽象层）、右边来选一个实现；</p><p>日志门面： SLF4J；</p><p>日志实现：Logback；</p><p>SpringBoot：底层是Spring框架，Spring框架默认是用JCL；</p><p><strong>SpringBoot选用 SLF4j和logback.</strong></p><h1 id="SLF4j使用"><a href="#SLF4j使用" class="headerlink" title="SLF4j使用"></a>SLF4j使用</h1><h2 id="如何在系统中使用SLF4j"><a href="#如何在系统中使用SLF4j" class="headerlink" title="如何在系统中使用SLF4j"></a>如何在系统中使用SLF4j</h2><p><a href="https://www.slf4j.org/" target="_blank" rel="noopener">SLF4j参考文档</a></p><p>以后开发的时候，日志记录方法的调用，<strong>不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；</strong></p><p>给系统里面导入slf4j的jar和 logback的实现jar</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">import org.slf4j.Logger;<br>import org.slf4j.LoggerFactory;<br>public class HelloWorld &#123;<br>  public static void main(String[] args) &#123;<br>    Logger logger = LoggerFactory.getLogger(HelloWorld.class);<br>    logger.info(&quot;Hello World&quot;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>图示:<br><img src="/images/QQ截图20181104095906.png"></p><p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是要用日志实现框架自己本身的配置文件；</strong></p><p>比如使用slf4j 和 logback，就用logback的配置文件，使用slf4j 和 log4j,就使用log4j的配置文件。而不是使用slf4j的配置文件。</p><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>a系统（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx</p><p>我们自己的a系统想要使用slf4j+logback做日志框架，但是我们的a系统是基于Spring、HIbernate等其他框架的，而这些其他框架底层使用的是其他日志框架，Spring使用的是commons-logging，Hibernate使用的是jboss-logging。</p><p>现在，我们想统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出，能做到吗？</p><p>slf4j官网给出了答案，<a href="https://www.slf4j.org/legacy.html" target="_blank" rel="noopener">参考答案</a></p><p><img src="/images/QQ截图20181104101357.png"></p><p><strong>如何让系统中所有的日志都统一到slf4j?</strong></p><font color="red">1、将系统中其他日志框架的日志jar包先排除出去；<br><br>2、用中间包来替换原有的日志框架的jar；<br><br>3、导入slf4j其他的实现。</font><h1 id="SpringBoot日志关系"><a href="#SpringBoot日志关系" class="headerlink" title="SpringBoot日志关系"></a>SpringBoot日志关系</h1><p>创建一个新的Springboot的应用，只需要Web模块即可。<br><img src="/images/QQ截图20181104103732.png"></p><p>现在，我们来查看一下Springboot的依赖关系。</p><p>查看依赖关系</p><p>1）使用idea的自带的maven管理器工具<br><img src="/images/QQ截图20181104103856.png" style="width:50%"></p><p>这样不够直观。</p><p>2）查看依赖图</p><p>在pom文件中，右键点击Diagrams -&gt; show dependencies<br><img src="/images/QQ截图20181104104228.png"><br><img src="/images/QQ截图20181104104542.png"></p><p>首先查看spring‐boot‐starter，因为这是Springboot的应用都必须依赖的jar包。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependency&gt;<br>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>然后发现，在spring‐boot‐starter下，有spring‐boot‐starter‐logging。</p><p>说明SpringBoot使用它来做日志功能<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependency&gt;<br>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>再来看spring-boot-starter-logging底层依赖：<br><img src="/images/QQ截图20181104105357.png"></p><p>总结：</p><p>1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录</p><p>2）、SpringBoot也把其他的日志都替换成了slf4j；</p><p>3）、中间替换包？<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@SuppressWarnings(&quot;rawtypes&quot;)<br>public abstract class LogFactory &#123;<br>    static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J =<br>&quot;http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j&quot;;<br>    static LogFactory logFactory = new SLF4JLogFactory();<br></code></pre></td></tr></table></figure></p><p><img src="/images/QQ截图20181104105601.png" style="width:50%"></p><p>其实这些jar包，本身还是原来的日志框架的jar包，只是在使用的过程中，偷换成了slf4j的日志框架，就和适配器模式很像。</p><p><strong>这些操作，Springboot已经帮我们做好了，我们只需要在引入其他框架的时候，移除掉他们本身的日志框架就行了。</strong></p><p>4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？</p><p>　　　我们挑Spring来做一个列子：</p><p>　　　Spring框架用的是commons-logging；</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependency&gt;        <br>&lt;groupId&gt;org.springframework&lt;/groupId&gt;            <br>&lt;artifactId&gt;spring‐core&lt;/artifactId&gt;            <br>&lt;exclusions&gt;            <br>&lt;exclusion&gt;                <br>&lt;groupId&gt;commons‐logging&lt;/groupId&gt;                    <br>&lt;artifactId&gt;commons‐logging&lt;/artifactId&gt;                    <br>&lt;/exclusion&gt;                <br>&lt;/exclusions&gt;            <br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>发现，Springboot也帮我们剔除掉了，Springboot真方便！！！</p><font color="red"><strong>SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要<br>把这个框架依赖的日志框架排除掉即可；</strong></font><h1 id="日志使用"><a href="#日志使用" class="headerlink" title="日志使用"></a>日志使用</h1><h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h2><p>直接运行，我们刚刚创建的项目：<br><img src="/images/QQ截图20181104112034.png"></p><p>发现，Springboot已经帮我们创建好了默认的配置。默认情况下，Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台。在运行应用程序和其他例子时，你应该已经看到很多INFO级别的日志了。</p><p>从上图可以看到，日志输出内容元素具体如下：</p><ul><li>时间日期：精确到毫秒</li><li>日志级别：ERROR, WARN, INFO, DEBUG or TRACE</li><li>进程ID</li><li>分隔符：－－－ 标识实际日志的开始</li><li>线程名：方括号括起来（可能会截断控制台输出）</li><li>Logger名：通常使用源代码的类名</li><li>日志内容</li></ul><p>使用：</p><p>在测试类中：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RunWith(SpringRunner.class)<br>@SpringBootTest<br>public class SpringBoot03LoggingApplicationTests &#123;<br><br>//日志记录器<br>Logger logger = LoggerFactory.getLogger(getClass());<br><br>@Test<br>public void contextLoads() &#123;<br><br>//System.out.println();  我们不再使用这种方法来记录了<br><br>//日志的级别，trace&lt;debug&lt;info&lt;warn&lt;error<br>//只会打印本级别和比本级别更高的日志<br>logger.trace(&quot;这是trace日志···&quot;);<br>logger.debug(&quot;这是debug日志···&quot;);<br>//Springboot默认的级别是info级别<br>logger.info(&quot;这是info日志···&quot;);<br>logger.warn(&quot;这是warn日志···&quot;);<br>logger.error(&quot;这error日志···&quot;);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行测试方法：<br><img src="/images/QQ截图20181104113131.png"></p><p>只打印了info级别以及以上的。说明Springboot默认的日志级别是info。</p><p>1) 修改日志的级别。</p><p>在application.properties文件中。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">logging.level.com.liuzhuo=trace<br></code></pre></td></tr></table></figure></p><p>再次运行测试方法：<br><img src="/images/QQ截图20181104113410.png"></p><p>格式为：logging.level.* = LEVEL</p><ul><li>logging.level：日志级别控制前缀，*为包名或Logger名</li><li>LEVEL：选项TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF</li></ul><p>举例：</p><ul><li>logging.level.com.liuzhuo=DEBUG：com.liuzhuo包下所有class以DEBUG级别输出</li><li>logging.level.root=WARN：root日志以WARN级别输出</li></ul><p>2) 日志文件的输出</p><p>默认情况下，Spring Boot将日志输出到控制台，不会写到日志文件。如果要编写除控制台输出之外的日志文件，则需在application.properties中设置logging.file或logging.path属性。</p><ul><li>logging.file，设置文件，可以是绝对路径，也可以是相对路径。如：logging.file=my.log</li><li>logging.path，设置目录，会在该目录下创建spring.log文件，并写入日志内容，如：logging.path=/var/log</li></ul><p>logging.file=xxx.log，会在项目的根目录下生成xxx.log文件<br>logging.file=G:/xxx.log，会在G盘下生xxx.log文件</p><p>logging.path=/aaa/bbb，会在项目的磁盘下，创建aaa/bbb文件夹，然后生成spring.log日志文件，<strong>日志文件的名字都是spring.log</strong></p><font color="red">注：二者不能同时使用，如若同时使用，则只有logging.file生效</font><p><strong>默认情况下，日志文件的大小达到10MB时会切分一次，产生新的日志文件，默认级别为：ERROR、WARN、INFO</strong></p><p>3) 日志输出格式的设置</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># 在控制台输出的日志的格式<br>logging.pattern.console=%d&#123;yyyy‐MM‐dd&#125; [%thread] %‐5level %logger&#123;50&#125; ‐ %msg%n<br># 指定文件中日志输出的格式<br>logging.pattern.file=%d&#123;yyyy‐MM‐dd&#125; === [%thread] === %‐5level === %logger&#123;50&#125; ==== %msg%n<br></code></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">日志输出格式：<br><br>%d表示日期时间，        <br>%thread表示线程名，        <br>%‐5level：级别从左显示5个字符宽度        <br>%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。         <br>%msg：日志消息，        <br>%n是换行符  <br>      <br>    ‐‐&gt;<br><br>%d&#123;yyyy‐MM‐dd HH:mm:ss.SSS&#125; [%thread] %‐5level %logger&#123;50&#125; ‐ %msg%n<br></code></pre></td></tr></table></figure><h2 id="指定配置"><a href="#指定配置" class="headerlink" title="指定配置"></a>指定配置</h2><p>在使用我们自己定义的日志配置文件之前，我们先来看看，为啥我们不用配置日志文件，Springboot中也能使用日志功能？</p><p>1) 打开org.springframework.boot:spring-boot:1.5.17.RELEASE<br>2) 打开org.springframework.boot<br>3) 打开logging、logback、base.xml<br><img src="/images/QQ截图20181104150319.png" style="width:50%"><br><img src="/images/QQ截图20181104150519.png" style="width:50%"></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br><br>&lt;!--<br>Base logback configuration provided for compatibility with Spring Boot 1.1<br>--&gt;<br><br>&lt;included&gt;<br>&lt;include resource=&quot;org/springframework/boot/logging/logback/defaults.xml&quot; /&gt;<br>&lt;property name=&quot;LOG_FILE&quot; value=&quot;$&#123;LOG_FILE:-$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;&#125;/spring.log&#125;&quot;/&gt;<br>&lt;include resource=&quot;org/springframework/boot/logging/logback/console-appender.xml&quot; /&gt;<br>&lt;include resource=&quot;org/springframework/boot/logging/logback/file-appender.xml&quot; /&gt;<br>&lt;root level=&quot;INFO&quot;&gt;<br>&lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;<br>&lt;appender-ref ref=&quot;FILE&quot; /&gt;<br>&lt;/root&gt;<br>&lt;/included&gt;<br></code></pre></td></tr></table></figure><p>我们发现，Springboot已经帮我们默认配置好了。</p><p>我们看到root下的 level的等于INFO，所以Springboot默认是info级别。</p><p>再看<code>&lt;include resource=&quot;org/springframework/boot/logging/logback/defaults.xml&quot; /&gt;</code><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br><br>&lt;!--<br>Default logback configuration provided for import, equivalent to the programmatic<br>initialization performed by Boot<br>--&gt;<br><br>&lt;included&gt;<br>&lt;conversionRule conversionWord=&quot;clr&quot; converterClass=&quot;org.springframework.boot.logging.logback.ColorConverter&quot; /&gt;<br>&lt;conversionRule conversionWord=&quot;wex&quot; converterClass=&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot; /&gt;<br>&lt;conversionRule conversionWord=&quot;wEx&quot; converterClass=&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot; /&gt;<br>&lt;property name=&quot;CONSOLE_LOG_PATTERN&quot; value=&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;/&gt;<br>&lt;property name=&quot;FILE_LOG_PATTERN&quot; value=&quot;$&#123;FILE_LOG_PATTERN:-%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; $&#123;LOG_LEVEL_PATTERN:-%5p&#125; $&#123;PID:- &#125; --- [%t] %-40.40logger&#123;39&#125; : %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;/&gt;<br><br>&lt;appender name=&quot;DEBUG_LEVEL_REMAPPER&quot; class=&quot;org.springframework.boot.logging.logback.LevelRemappingAppender&quot;&gt;<br>&lt;destinationLogger&gt;org.springframework.boot&lt;/destinationLogger&gt;<br>&lt;/appender&gt;<br><br>&lt;logger name=&quot;org.apache.catalina.startup.DigesterFactory&quot; level=&quot;ERROR&quot;/&gt;<br>&lt;logger name=&quot;org.apache.catalina.util.LifecycleBase&quot; level=&quot;ERROR&quot;/&gt;<br>&lt;logger name=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; level=&quot;WARN&quot;/&gt;<br>&lt;logger name=&quot;org.apache.sshd.common.util.SecurityUtils&quot; level=&quot;WARN&quot;/&gt;<br>&lt;logger name=&quot;org.apache.tomcat.util.net.NioSelectorPool&quot; level=&quot;WARN&quot;/&gt;<br>&lt;logger name=&quot;org.crsh.plugin&quot; level=&quot;WARN&quot;/&gt;<br>&lt;logger name=&quot;org.crsh.ssh&quot; level=&quot;WARN&quot;/&gt;<br>&lt;logger name=&quot;org.eclipse.jetty.util.component.AbstractLifeCycle&quot; level=&quot;ERROR&quot;/&gt;<br>&lt;logger name=&quot;org.hibernate.validator.internal.util.Version&quot; level=&quot;WARN&quot;/&gt;<br>&lt;logger name=&quot;org.springframework.boot.actuate.autoconfigure.CrshAutoConfiguration&quot; level=&quot;WARN&quot;/&gt;<br>&lt;logger name=&quot;org.springframework.boot.actuate.endpoint.jmx&quot; additivity=&quot;false&quot;&gt;<br>&lt;appender-ref ref=&quot;DEBUG_LEVEL_REMAPPER&quot;/&gt;<br>&lt;/logger&gt;<br>&lt;logger name=&quot;org.thymeleaf&quot; additivity=&quot;false&quot;&gt;<br>&lt;appender-ref ref=&quot;DEBUG_LEVEL_REMAPPER&quot;/&gt;<br>&lt;/logger&gt;<br>&lt;/included&gt;<br></code></pre></td></tr></table></figure></p><p>我们能看到<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;property name=&quot;CONSOLE_LOG_PATTERN&quot; value=&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;/&gt;<br></code></pre></td></tr></table></figure></p><p>这里就是配置控制台输出日志格式的配置，我们写在application.propertiese中的logging.pattern.console=xxx.就会覆盖这个配置中的内容，如果不配置的话，就使用默认的配置，就是冒号后面的一串：<code>-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} xxxxx</code></p><hr><p>现在我们已经了解到了Springboot的默认日志文件的配置了。当我们具体使用日志框架时，需要使用哪个配置文件呢？</p><p>打开Spring的官网，<a href="https://docs.spring.io/spring-boot/docs/1.5.17.RELEASE/reference/htmlsingle/#boot-features-logging" target="_blank" rel="noopener">logging参考文献</a></p><p>找到：<strong>26.5 Custom log configuration</strong></p><p><img src="/images/QQ截图20181104194411.png"></p><p>从图中，我们可以看出，使用logback日志框架，就使用logback-spring.xml、logback.xml等配置文件。</p><p>其他的日志框架，类似logback。</p><p><strong>给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了。</strong></p><p>现在，我们在类路径下，即resources下，放入一个logback.xml的日志配置文件。<br><img src="/images/QQ截图20181104195557.png"></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;!--<br>scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。<br>scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒当scan为true时，此属性生效。默认的时间间隔为1分钟。<br>debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。<br>--&gt;<br>&lt;configuration scan=&quot;false&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt;<br>    &lt;!-- 定义日志的根目录 --&gt;<br>    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/app/log&quot; /&gt;<br>    &lt;!-- 定义日志文件名称 --&gt;<br>    &lt;property name=&quot;appName&quot; value=&quot;atguigu-springboot&quot;&gt;&lt;/property&gt;<br>    &lt;!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 --&gt;<br>    &lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;<br>        &lt;!--<br>        日志输出格式：<br>%d表示日期时间，<br>%thread表示线程名，<br>%-5level：级别从左显示5个字符宽度<br>%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 <br>%msg：日志消息，<br>%n是换行符<br>        --&gt;<br>        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;<br>            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt;<br>        &lt;/layout&gt;<br>    &lt;/appender&gt;<br><br>    &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt;  <br>    &lt;appender name=&quot;appLogAppender&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;<br>        &lt;!-- 指定日志文件的名称 --&gt;<br>        &lt;file&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;.log&lt;/file&gt;<br>        &lt;!--<br>        当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名<br>        TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。<br>        --&gt;<br>        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;<br>            &lt;!--<br>            滚动时产生的文件的存放位置及文件名称 %d&#123;yyyy-MM-dd&#125;：按天进行日志滚动 <br>            %i：当文件大小超过maxFileSize时，按照i进行文件滚动<br>            --&gt;<br>            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log&lt;/fileNamePattern&gt;<br>            &lt;!-- <br>            可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每天滚动，<br>            且maxHistory是365，则只保存最近365天的文件，删除之前的旧文件。注意，删除旧文件是，<br>            那些为了归档而创建的目录也会被删除。<br>            --&gt;<br>            &lt;MaxHistory&gt;365&lt;/MaxHistory&gt;<br>            &lt;!-- <br>            当日志文件超过maxFileSize指定的大小是，根据上面提到的%i进行日志文件滚动 注意此处配置SizeBasedTriggeringPolicy是无法实现按文件大小进行滚动的，必须配置timeBasedFileNamingAndTriggeringPolicy<br>            --&gt;<br>            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;<br>                &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;<br>            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;<br>        &lt;/rollingPolicy&gt;<br>        &lt;!-- 日志输出格式： --&gt;     <br>        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;<br>            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [ %thread ] - [ %-5level ] [ %logger&#123;50&#125; : %line ] - %msg%n&lt;/pattern&gt;<br>        &lt;/layout&gt;<br>    &lt;/appender&gt;<br><br>    &lt;!-- <br>logger主要用于存放日志对象，也可以定义日志类型、级别<br>name：表示匹配的logger类型前缀，也就是包的前半部分<br>level：要记录的日志级别，包括 TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR<br>additivity：作用在于children-logger是否使用 rootLogger配置的appender进行输出，<br>false：表示只用当前logger的appender-ref，true：<br>表示当前logger的appender-ref和rootLogger的appender-ref都有效<br>    --&gt;<br>    &lt;!-- hibernate logger --&gt;<br>    &lt;logger name=&quot;com.atguigu&quot; level=&quot;debug&quot; /&gt;<br>    &lt;!-- Spring framework logger --&gt;<br>    &lt;logger name=&quot;org.springframework&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt;&lt;/logger&gt;<br><br><br><br>    &lt;!-- <br>    root与logger是父子关系，没有特别定义则默认为root，任何一个类只会和一个logger对应，<br>    要么是定义的logger，要么是root，判断的关键在于找到这个logger，然后判断这个logger的appender和level。 <br>    --&gt;<br>    &lt;root level=&quot;info&quot;&gt;<br>        &lt;appender-ref ref=&quot;stdout&quot; /&gt;<br>        &lt;appender-ref ref=&quot;appLogAppender&quot; /&gt;<br>    &lt;/root&gt;<br>&lt;/configuration&gt;<br></code></pre></td></tr></table></figure><p>现在，我们修改一下日志的输出格式：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined"> &lt;!-- 日志输出格式： --&gt;     <br>&lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;<br>    &lt;pattern&gt;%d&#123;yyyy-MM-dd&#125; -----&gt; [ %thread ] -----&gt; [ %-5level ] [ %logger&#123;50&#125; : %line ] -----&gt; %msg%n&lt;/pattern&gt;<br>&lt;/layout&gt;<br></code></pre></td></tr></table></figure></p><p><strong>把时间的时分秒去掉，然后把分隔符改为箭头。</strong></p><p>启动Springboot项目：<br><img src="/images/QQ截图20181104200138.png"></p><p>我们的日志配置文件设置成功了。</p><hr><p>我们注意到了，官网上面写了logback.xml和logback-spring.xml两种配置文件的<strong>书写方式。</strong></p><font color="red"><strong>官网推荐我们使用logback-spring.xml命名的配置文件。</strong></font><p>logback.xml: 是直接被日志框架识别，在Spring应用启动之前。不会走Spring的流程。</p><p><strong>logback-spring.xml:</strong> 日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot<br>的高级Profile功能</p><p>可以使用：在哪个环境下生效。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;springProfile name=&quot;staging&quot;&gt;<br>    &lt;!‐‐ configuration to be enabled when the &quot;staging&quot; profile is active ‐‐&gt;<br>   可以指定某段配置只在某个环境下生效  <br>&lt;/springProfile&gt;<br></code></pre></td></tr></table></figure><p>如：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;<br>        &lt;!‐‐<br>        日志输出格式：<br> %d表示日期时间，            <br> %thread表示线程名，            <br> %‐5level：级别从左显示5个字符宽度            <br> %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。             <br> %msg：日志消息，            <br> %n是换行符            <br>        ‐‐&gt;<br>        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;<br>            &lt;springProfile name=&quot;dev&quot;&gt;<br>                &lt;pattern&gt;%d&#123;yyyy‐MM‐dd HH:mm:ss.SSS&#125; ‐‐‐‐&gt; [%thread] ‐‐‐&gt; %‐5level %logger&#123;50&#125; ‐ %msg%n&lt;/pattern&gt;<br>            &lt;/springProfile&gt;<br>            &lt;springProfile name=&quot;!dev&quot;&gt;<br>                &lt;pattern&gt;%d&#123;yyyy‐MM‐dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %‐5level %logger&#123;50&#125; ‐ %msg%n&lt;/pattern&gt;<br>            &lt;/springProfile&gt;<br>        &lt;/layout&gt;<br>    &lt;/appender&gt;<br></code></pre></td></tr></table></figure></p><p>在dev环境下：使用上面的输出格式。</p><p>在非dev环境下：使用下面的输出格式。</p><p>现在运行Springboot项目：<br><img src="/images/QQ截图20181104201524.png"></p><p><strong>发现，日志框架出现错误了。因为我们的日志配置文件的名字还没有改。</strong></p><p>现在修改logback.xml —&gt; logback-spring.xml.</p><p>再次启动Springboot应用：<br><img src="/images/QQ截图20181104201940.png"></p><p>发现，启动的是非dev环境的日志控制台输出格式。</p><p>我们在配置Springboot为dev环境。</p><p>1）application.properties.</p><p>spring.profiles.active=dev</p><p>2) 配置命令行参数：<br><code>--spring.profiles.active=dev</code><br><img src="/images/QQ截图20181104202332.png"></p><p>使用上面两种方法都可以改变Springboot的环境。</p><p>然后启动Springboot应用：<br><img src="/images/QQ截图20181104202559.png"></p><h1 id="切换日志框架"><a href="#切换日志框架" class="headerlink" title="切换日志框架"></a>切换日志框架</h1><h2 id="切换成log4j"><a href="#切换成log4j" class="headerlink" title="切换成log4j"></a>切换成log4j</h2><p>现在，我们使用的是slf4j+logback。但是我们想换成slf4j + log4j怎么办？</p><p><strong>这里，说明一下，就是因为log4j有问题，所以才会推出logback日志框架的，这里只是做个例子演示日志框架的切换，实际情况下，直接使用logback日志框架就行。</strong></p><p>切换日志框架，我们直接参考slf4j的官网的那个图，就行。<br><img src="/images/QQ截图20181104204428.png"></p><p>现在打开我们的依赖图层：<br><img src="/images/QQ截图20181104204742.png"></p><p>去掉图中画红色框框的logback的依赖。</p><p>快速移除依赖：在想要移除的依赖上面，右键Exclude<br><img src="/images/QQ截图20181104205023.png"></p><p>移除完毕后：<br><img src="/images/QQ截图20181104205144.png" style="width:50%"></p><p>打开pom.xml文件：<br><img src="/images/QQ截图20181104205307.png"></p><p>现在需要添加log4j的依赖。</p><p>直接在pom.xml文件中添加：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependency&gt;<br>&lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br>&lt;artifactId&gt;slf4j-log412&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p><img src="/images/QQ截图20181104205726.png"></p><p>启动Springboot应用：<br><img src="/images/QQ截图20181104205838.png"><br><strong>发出警告，因为在类路径下，没有log4j.properties的配置文件。</strong></p><p>在resources下，添加log4j.properties的配置文件<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs undefined">### set log levels ###<br>log4j.rootLogger = debug ,  stdout ,  D ,  E<br><br>### 输出到控制台 ###<br>log4j.appender.stdout = org.apache.log4j.ConsoleAppender<br>log4j.appender.stdout.Target = System.out<br>log4j.appender.stdout.layout = org.apache.log4j.PatternLayout<br>log4j.appender.stdout.layout.ConversionPattern =  %d&#123;ABSOLUTE&#125; %5p %c&#123; 1 &#125;:%L - %m%n<br><br>#### 输出到日志文件 ###<br>#log4j.appender.D = org.apache.log4j.DailyRollingFileAppender<br>#log4j.appender.D.File = logs/log.log<br>#log4j.appender.D.Append = true<br>#log4j.appender.D.Threshold = DEBUG ## 输出DEBUG级别以上的日志<br>#log4j.appender.D.layout = org.apache.log4j.PatternLayout<br>#log4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n<br>#<br>#### 保存异常信息到单独文件 ###<br>#log4j.appender.D = org.apache.log4j.DailyRollingFileAppender<br>#log4j.appender.D.File = logs/error.log ## 异常日志文件名<br>#log4j.appender.D.Append = true<br>#log4j.appender.D.Threshold = ERROR ## 只输出ERROR级别以上的日志!!!<br>#log4j.appender.D.layout = org.apache.log4j.PatternLayout<br>#log4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n<br></code></pre></td></tr></table></figure></p><p>再次启动应用，就会打印出日志信息了。</p><hr><h2 id="切换成log4j2"><a href="#切换成log4j2" class="headerlink" title="切换成log4j2"></a>切换成log4j2</h2><p>在官网上面，我们能发现，Springboot默认是加载logback日志框架的，我们也可以直接改成log4j2日志框架。</p><p>在pom.xml文件中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">   &lt;dependency&gt;<br>       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>       &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;<br>          &lt;exclusions&gt;<br>             &lt;exclusion&gt;<br>                 &lt;artifactId&gt;spring‐boot‐starter‐logging&lt;/artifactId&gt;<br>                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;/exclusion&gt;<br>          &lt;/exclusions&gt;<br>    &lt;/dependency&gt;<br><br>&lt;dependency&gt;<br>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>  &lt;artifactId&gt;spring‐boot‐starter‐log4j2&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>直接移除spring‐boot‐starter‐logging依赖。然后添加spring‐boot‐starter‐log4j2的依赖。</p><p>然后添加log4j2-spring.xml 或者 log4j2.xml 日志配置文件。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot_day_02</title>
      <link href="/2018/11/03/SpringBoot-day-02/"/>
      <url>/2018/11/03/SpringBoot-day-02/</url>
      
        <content type="html"><![CDATA[<p>Springboot的配置文件<br><a id="more"></a></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>SpringBoot使用一个全局的配置文件，配置文件名是<strong>固定的</strong>；</p><ul><li>application.properties</li><li>application.yml</li></ul><p>配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；</p><p>xxx.properties文件，我们见的比较多，比较熟悉。</p><p>这里讲解yml文件。</p><p>YAML（YAML Ain’t Markup Language）<br>YAML A Markup Language：是一个标记语言<br>YAML isn’t Markup Language：不是一个标记语言；  </p><p>标记语言：<br>以前的配置文件；大多都使用的是 xxxx.xml文件；<br>YAML：以数据为中心，比json、xml等更适合做配置文件； </p><p>YAML：配置例子<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">server:<br>  port: 8081<br></code></pre></td></tr></table></figure></p><p>XML：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;server&gt;<br>   &lt;port&gt;8081&lt;/port&gt;    <br>&lt;/server&gt;<br></code></pre></td></tr></table></figure></p><hr><p>1）创建新的Springboot项目，添加web模块即可：<br><img src="/images/QQ截图20181103104435.png"></p><p>2）在resources下，创建application.yml文件<br><img src="/images/QQ截图20181103104633.png"></p><p>3）启动项目<br><img src="/images/QQ截图20181103104821.png"></p><p>项目的端口号，修改成为8081.</p><h3 id="YAML语法："><a href="#YAML语法：" class="headerlink" title="YAML语法："></a>YAML语法：</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>k:(空格)v：表示一对键值对（<strong>空格必须有</strong>）；</p><p>以<strong>空格的缩进</strong>来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p><p>例子：<br><img src="/images/QQ截图20181103105623.png"></p><p>注意：属性和值也是大小写敏感。</p><h4 id="值的写法"><a href="#值的写法" class="headerlink" title="值的写法"></a>值的写法</h4><h5 id="字面量：普通的值（数字，字符串，布尔）"><a href="#字面量：普通的值（数字，字符串，布尔）" class="headerlink" title="字面量：普通的值（数字，字符串，布尔）"></a>字面量：普通的值（数字，字符串，布尔）</h5><p>k: v：字面量直接来写；</p><p>字符串默认不用加上单引号或者双引号；</p><p>“”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p><p>name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi</p><p>‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p><p>name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi</p><h5 id="对象、Map（属性和值）（键值对）："><a href="#对象、Map（属性和值）（键值对）：" class="headerlink" title="对象、Map（属性和值）（键值对）："></a>对象、Map（属性和值）（键值对）：</h5><p>k: v：在下一行来写对象的属性和值的关系；注意缩进</p><p>对象还是k: v的方式<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">friends:<br>lastName: zhangsan        <br>age: 20<br></code></pre></td></tr></table></figure></p><p>行内写法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">friends: &#123;lastName: zhangsan,age: 18&#125;<br></code></pre></td></tr></table></figure></p><h5 id="数组（List、Set）："><a href="#数组（List、Set）：" class="headerlink" title="数组（List、Set）："></a>数组（List、Set）：</h5><p>用- 值表示数组中的一个元素<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">pets:<br> ‐ cat<br> ‐ dog<br> ‐ pig<br></code></pre></td></tr></table></figure></p><p>行内写法:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">pets: [cat,dog,pig]<br></code></pre></td></tr></table></figure></p><h3 id="配置文件值注入"><a href="#配置文件值注入" class="headerlink" title="配置文件值注入"></a>配置文件值注入</h3><h4 id="使用-ConfigurationProperties注解"><a href="#使用-ConfigurationProperties注解" class="headerlink" title="使用@ConfigurationProperties注解"></a>使用@ConfigurationProperties注解</h4><p>1) 在根包下，创建bean包，并创建Person和Dog类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Person &#123;<br><br>    private String lastName;<br>    private Integer age;<br>    private Boolean boss;<br>    private Date birth;<br>    private Map&lt;String, Object&gt; maps;<br>    private List&lt;Object&gt; lists;<br>    private Dog dog;<br><br>   ····<br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Dog &#123;<br><br>    private String name;<br>    private Integer age;<br><br>    ····<br>&#125;<br></code></pre></td></tr></table></figure><p>其中省略了，get、set、tostring的方法。</p><p>2）给application.yml文件赋值：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">person:<br>  lastName: zhangSan<br>  age: 18<br>  boss: true<br>  birth: 2018/11/11<br>  maps: &#123;k1: v1,k2: v2&#125;<br>  lists:<br>    - list1<br>    - list2<br>  dog:<br>    name: 小狗<br>    age: 2<br></code></pre></td></tr></table></figure></p><p>3) 给Person类添加@ConfigurationProperties注解<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">/**<br> * 描述:<br> *<br> * @ConfigurationProperties: 配置文件的属性映射<br> * prefix：前缀。<br> */<br>@ConfigurationProperties(prefix = &quot;person&quot;)<br>public class Person &#123;<br></code></pre></td></tr></table></figure></p><p>4) 测试：<br>在test包下，有一个测试类：<br>SpringBoot02ConfigApplicationTests</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RunWith(SpringRunner.class)<br>@SpringBootTest<br>public class SpringBoot02ConfigApplicationTests<br></code></pre></td></tr></table></figure><p>@RunWith(SpringRunner.class):使用Spring的测试驱动<br>@SpringBootTest：使用Springboot的测试</p><p>不再使用Junit测试，Spring的测试驱动，更加方便，可以使用自动注入什么的。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RunWith(SpringRunner.class)<br>@SpringBootTest<br>public class SpringBoot02ConfigApplicationTests &#123;<br><br>    @Autowired<br>    private Person person;<br><br>    @Test<br>    public void contextLoads() &#123;<br>        System.out.println(person);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里：<code>private Person person;</code> 会报错，因为我们的Person类没有注入到容器中，所以，我们还需要在Person类上面，加上@Component注解。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>@ConfigurationProperties(prefix = &quot;person&quot;)<br>public class Person<br></code></pre></td></tr></table></figure></p><p>运行测试：<br><img src="/images/QQ截图20181103114614.png"><br><img src="/images/QQ截图20181103114704.png"></p><p>在控制台，看到到了Person类的属性注入成功了。</p><p><strong>PS：想要在yml文件中书写时，有提示，我们可以加入配置文件处理器依赖：</strong><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!--配置文件处理器，会给出提示--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;<br>    &lt;optional&gt;true&lt;/optional&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p><img src="/images/QQ截图20181103115009.png"></p><p>在yml配置文件中，person属性下：Alt+/ 会出Person类中还没有配置的属性。</p><p><strong>使用提示出现的属性，比如lastName，会是last-name的样子，都是一样的。-n 就相当于大写的N。</strong></p><hr><p>接下来，使用properties文件配置Person类：</p><p>将yml文件中的Person配置注释掉</p><p>在properties文件中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">#idea中的properties文件是UTF-8的编码，而我们需要转换成ASCII编码<br>#给person配置属性值<br>person.last-name=张三<br>person.age=20<br>person.boss=false<br>person.birth=2018/11/03<br>person.maps.k1=v1<br>person.maps.k2=v2<br>person.lists=a,b,c<br>person.dog.name=dog<br>person.dog.age=2<br></code></pre></td></tr></table></figure></p><p>运行测试：<br><img src="/images/QQ截图20181103120508.png"><br>此时出现了中文乱码的现象。</p><p>这是因为idea默认是使用utf-8的编码，不会转义成ascii。</p><p>打开idea的settings：<br><img src="/images/QQ截图20181103120858.png"></p><p>再次运行测试：<br><img src="/images/QQ截图20181103120952.png"></p><hr><h4 id="使用-Value注解"><a href="#使用-Value注解" class="headerlink" title="使用@Value注解"></a>使用@Value注解</h4><p>除了使用@ConfigurationProperties注解来给属性赋值，我们还知道可以还是要Spring的@Value注解。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Person &#123;<br>    /**<br>     * &lt;bean class=&quot;Person&quot;&gt;<br>     *      &lt;property name=&quot;lastName&quot; value=&quot;字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;&quot;&gt;&lt;/property&gt;<br>     * &lt;bean/&gt;<br>     */<br>    @Value(&quot;$&#123;person.last‐name&#125;&quot;)<br>    private String lastName;<br>    @Value(&quot;#&#123;11*2&#125;&quot;)<br>    private Integer age;<br>    @Value(&quot;true&quot;)<br>    private Boolean boss;<br>    private Date birth;<br>    private Map&lt;String,Object&gt; maps;<br>    private List&lt;Object&gt; lists;<br>    private Dog dog;<br></code></pre></td></tr></table></figure><p><strong>@Value获取值 和 @ConfigurationProperties获取值比较</strong></p><p><img src="/images/QQ截图20181103122845.png"></p><p>这里的松散绑定的意思是，lastName，last-name,last_name都可以在@ConfigurationProperties中使用，但是在@Value中，必须一模一样，比如：</p><p>在Person类中：<br>@Value(“${person.last-name}”)</p><p>在properties配置文件中，必须是：<br>person.last-name=张三</p><p>JSR303数据校验的意思是：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>@ConfigurationProperties(prefix = &quot;person&quot;)<br>@Validated<br>public class Person &#123;<br><br>    @Email<br>    private String lastName;<br></code></pre></td></tr></table></figure></p><p>在Person类上，添加@Validated注解，开启数据校验的功能，然后在Person的属性上面，添加@Email、等其他注解，就可以提供数据校验的功能。</p><p>复杂类型封装的意思是：<br>比如：<br>使用@ConfigurationProperties(prefix = “person”)后，map类型的数据：<br>在配置文件中：maps: {k1: v1,k2: v2} 或者 person.maps.k1=v1，person.maps.k2=v2</p><p>然后自动就绑定上了，但是使用@Value注解，就不行。</p><p>@Value注入复杂的属性值：</p><p>1）使用util标签<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Properties &#123;<br> <br>@Value(&quot;#&#123;testPro&#125;&quot;)<br>private Properties pros;<br> <br>@Value(&quot;#&#123;testList&#125;&quot;)<br>private List&lt;String&gt; myList;<br> <br>@Value(&quot;#&#123;testMap&#125;&quot;)<br>private Map&lt;Integer, String&gt; myMap;<br></code></pre></td></tr></table></figure></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!-- applicationContext.xml --&gt;<br>&lt;!-- 扫描测试属性包中的类，要注入属性类需要被Spring管理 --&gt;<br>&lt;context:component-scan base-package=&quot;com.xy.test2&quot; /&gt;<br> <br>&lt;!-- properties --&gt;<br>&lt;util:properties id=&quot;testPro&quot; location=&quot;classpath:info/info2.properties&quot; /&gt;<br> <br>&lt;!-- list --&gt;<br>&lt;util:list id=&quot;testList&quot; list-class=&quot;java.util.ArrayList&quot;&gt;<br>&lt;value&gt;first&lt;/value&gt;<br>&lt;value&gt;second&lt;/value&gt;<br>&lt;value&gt;third&lt;/value&gt;<br>&lt;/util:list&gt;<br> <br>&lt;!-- map --&gt;<br>&lt;util:map id=&quot;testMap&quot; map-class=&quot;java.util.HashMap&quot;&gt;<br>&lt;entry key=&quot;1&quot; value=&quot;first&quot; /&gt;<br>&lt;entry key=&quot;2&quot; value=&quot;second&quot; /&gt;<br>&lt;entry key=&quot;3&quot; value=&quot;third&quot; /&gt;<br>&lt;/util:map&gt;<br></code></pre></td></tr></table></figure><p>2) 直接使用xml的形式来注入复杂的数据类型：</p><p>下边的一个java类包含了所有Map、Set、List、数组、属性集合等这些容器，主要用于演示Spring的注入配置；<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><br>package com.lc.collection;<br> <br>import java.util.List;<br>import java.util.Map;<br>import java.util.Properties;<br>import java.util.Set;<br> <br>public class Department &#123;<br> <br>private String name;<br>private String [] empName;//数组<br>private List&lt;Employee&gt; empList;//list集合<br>private Set&lt;Employee&gt; empsets;//set集合<br>private Map&lt;String,Employee&gt; empMaps;//map集合<br>private Properties pp;//Properties的使用<br> <br><br>public Set&lt;Employee&gt; getEmpsets() &#123;<br>return empsets;<br>&#125;<br>public void setEmpsets(Set&lt;Employee&gt; empsets) &#123;<br>this.empsets = empsets;<br>&#125;<br>public String[] getEmpName() &#123;<br>return empName;<br>&#125;<br>public void setEmpName(String[] empName) &#123;<br>this.empName = empName;<br>&#125;<br>public String getName() &#123;<br>return name;<br>&#125;<br>public void setName(String name) &#123;<br>this.name = name;<br>&#125;<br>public List&lt;Employee&gt; getEmpList() &#123;<br>return empList;<br>&#125;<br>public void setEmpList(List&lt;Employee&gt; empList) &#123;<br>this.empList = empList;<br>&#125;<br>public Map&lt;String, Employee&gt; getEmpMaps() &#123;<br>return empMaps;<br>&#125;<br>public void setEmpMaps(Map&lt;String, Employee&gt; empMaps) &#123;<br>this.empMaps = empMaps;<br>&#125;<br>public Properties getPp() &#123;<br>return pp;<br>&#125;<br>public void setPp(Properties pp) &#123;<br>this.pp = pp;<br>&#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure></p><p>Spring配置文件beans.xml文件:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;<br>xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd<br>http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd<br>http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot;&gt;<br> <br>&lt;bean id=&quot;department&quot; class=&quot;com.hsp.collection.Department&quot;&gt;<br>&lt;property name=&quot;name&quot; value=&quot;财务部&quot;/&gt;<br> <br>&lt;!-- 给数组注入值 --&gt;<br>&lt;property name=&quot;empName&quot;&gt;<br>&lt;list&gt;<br>&lt;value&gt;小明&lt;/value&gt;<br>&lt;value&gt;小明小明&lt;/value&gt;<br>&lt;value&gt;小明小明小明小明&lt;/value&gt;<br>&lt;/list&gt;<br>&lt;/property&gt;<br> <br>&lt;!-- 给list注入值 list 中可以有相当的对象 --&gt;<br>&lt;property name=&quot;empList&quot;&gt;<br>&lt;list&gt;<br>&lt;ref bean=&quot;emp2&quot; /&gt;<br>&lt;ref bean=&quot;emp1&quot;/&gt;<br>&lt;ref bean=&quot;emp1&quot;/&gt;<br>&lt;ref bean=&quot;emp1&quot;/&gt;<br>&lt;ref bean=&quot;emp1&quot;/&gt;<br>&lt;ref bean=&quot;emp1&quot;/&gt;<br>&lt;ref bean=&quot;emp1&quot;/&gt;<br>&lt;/list&gt;<br>&lt;/property&gt;<br> <br>&lt;!-- 给set注入值 set不能有相同的对象 --&gt;<br>&lt;property name=&quot;empsets&quot;&gt;<br>&lt;set&gt;<br>&lt;ref bean=&quot;emp1&quot; /&gt;<br>&lt;ref bean=&quot;emp2&quot;/&gt;<br>&lt;ref bean=&quot;emp2&quot;/&gt;<br>&lt;ref bean=&quot;emp2&quot;/&gt;<br>&lt;ref bean=&quot;emp2&quot;/&gt;<br>&lt;/set&gt;<br>&lt;/property&gt;<br> <br>&lt;!-- 给map注入值 map只有key不一样，就可以装配value --&gt;<br>&lt;property name=&quot;empMaps&quot;&gt;<br>&lt;map&gt;<br>&lt;entry key=&quot;11&quot; value-ref=&quot;emp1&quot; /&gt; <br>&lt;entry key=&quot;22&quot; value-ref=&quot;emp2&quot;/&gt;<br>&lt;entry key=&quot;22&quot; value-ref=&quot;emp1&quot;/&gt;<br>&lt;/map&gt;<br>&lt;/property&gt;<br> <br>&lt;!-- 给属性集合配置 --&gt;<br>&lt;property name=&quot;pp&quot;&gt;<br>&lt;props&gt;<br>&lt;prop key=&quot;pp1&quot;&gt;abcd&lt;/prop&gt;<br>&lt;prop key=&quot;pp2&quot;&gt;hello&lt;/prop&gt;<br>&lt;/props&gt;<br>&lt;/property&gt;<br>&lt;/bean&gt;<br> <br>&lt;bean id=&quot;emp1&quot; class=&quot;com.hsp.collection.Employee&quot;&gt;<br>&lt;property name=&quot;name&quot; value=&quot;北京&quot;/&gt;<br>&lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;<br>&lt;/bean&gt;<br>&lt;bean id=&quot;emp2&quot; class=&quot;com.hsp.collection.Employee&quot;&gt;<br>&lt;property name=&quot;name&quot; value=&quot;天津&quot;/&gt;<br>&lt;property name=&quot;id&quot; value=&quot;2&quot;/&gt;<br>&lt;/bean&gt;<br> <br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure></p><hr><p>配置文件yml还是properties他们都能获取到值；</p><p>总结：</p><p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；<br>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</p><h4 id="PropertySource-amp-ImportResource-amp-Bean"><a href="#PropertySource-amp-ImportResource-amp-Bean" class="headerlink" title="@PropertySource &amp; @ImportResource &amp; @Bean"></a>@PropertySource &amp; @ImportResource &amp; @Bean</h4><p>@ConfigurationProperties默认加载默认的全局配置中的内容。</p><p>但是，我们并不想将所有的配置内容都放在全局的配置文件中，则使用@PropertySource注解。</p><p>@PropertySource：加载指定的配置文件。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">/**<br> * 将配置文件中配置的每一个属性的值，映射到这个组件中<br> * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；<br> *      prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射<br> *<br> * 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能；<br> *  @ConfigurationProperties(prefix = &quot;person&quot;)默认从全局配置文件中获取值；<br> *<br> */<br>@PropertySource(value = &#123;&quot;classpath:person.properties&quot;&#125;)<br>@Component<br>@ConfigurationProperties(prefix = &quot;person&quot;)<br>public class Person &#123;<br>   ···<br>｝<br></code></pre></td></tr></table></figure><p>@PropertySource(value = {“classpath:person.properties”})：这里指定了在类路径下的person.properties文件中内容映射到本类的属性中。</p><p><img src="/images/QQ截图20181103141521.png"></p><p><strong>注意：</strong><br>再将默认的全局配置文件中的person属性注释掉，因为全局的配置文件的优先级高于自定义的配置文件的优先级。</p><p>运行测试类：<br><img src="/images/QQ截图20181103141730.png"></p><p>此时，我们加载的就是自定义person.properties文件中的内容了。</p><p>@<strong>ImportResource</strong>：导入Spring的xml配置文件，让配置文件里面的内容生效；</p><p>Spring Boot里面没有Spring的xml配置文件，我们自己编写的配置文件，也不能自动识别；<br>想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上。</p><p>在resources下，创建beans.xml文件。<br>在service下，创建HellService类</p><p><img src="/images/QQ截图20181103142248.png"></p><p>修改测试类：<br><img src="/images/QQ截图20181103142451.png"></p><p>运行测试方法：<br><img src="/images/QQ截图20181103142633.png"></p><p>在Springboot启动类上，加上@ImportResource注解：</p><p>因为@SpringBootApplication注解本身也是一个配置类<br><img src="/images/QQ截图20181103142813.png"></p><p>再次运行测试方法：<br><img src="/images/QQ截图20181103142947.png"></p><p><strong>@Bean</strong></p><p>SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式</p><p>不来编写Spring的xml配置文件。</p><p>1）配置类@Configuration——&gt;Spring配置文件</p><p>2）使用@Bean给容器中添加组件</p><p>在config下，创建一个配置类：<br><img src="/images/QQ截图20181103143527.png"></p><p>去掉SpringBootApplication启动类上的@ImportResource注解；</p><p>运行测试方法：<br><img src="/images/QQ截图20181103142947.png"></p><hr><h4 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h4><p>1）随机数</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;<br>$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125;<br></code></pre></td></tr></table></figure><p>比如：<br><img src="/images/QQ截图20181103144510.png"></p><p>2）占位符获取之前配置的值，如果没有可以是用:指定默认值</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">person.last‐name=张三$&#123;random.uuid&#125;<br>person.age=$&#123;random.int&#125;<br>person.birth=2017/12/15<br>person.boss=false<br>person.maps.k1=v1<br>person.maps.k2=14<br>person.lists=a,b,c<br>person.dog.name=$&#123;person.hello:hello&#125;_dog<br>person.dog.age=15<br></code></pre></td></tr></table></figure><p>这里的person.dog.name使用了${person.hello:hello}_dog，如果${person.hello:hello}之前没有配置，就会使用冒号后面的默认值hello。如果没有写冒号后面的值，即：person.dog.name=${person.hello}_dog。则原样输出。（没有配置${person.hello}的话）。</p><h4 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h4><h5 id="多Profile文件"><a href="#多Profile文件" class="headerlink" title="多Profile文件"></a>多Profile文件</h5><p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml</p><p><strong>默认使用application.properties的配置。</strong></p><p>默认的配置文件application.properties：<br><img src="/images/QQ截图20181103150324.png"></p><p>创建dev配置文件：<br><img src="/images/QQ截图20181103150535.png"></p><p>创建prod配置文件：<br><img src="/images/QQ截图20181103150641.png"></p><p>启动SpringBoot应用：<br><img src="/images/QQ截图20181103150737.png"><br><img src="/images/QQ截图20181103150805.png"></p><p>可以看出，默认启动，application.properties的配置。端口号：8081</p><h5 id="激活指定profile"><a href="#激活指定profile" class="headerlink" title="激活指定profile"></a>激活指定profile</h5><p>1）在默认配置文件中指定 spring.profiles.active=dev<br><img src="/images/QQ截图20181103151018.png"></p><p>启动SpringBoot应用：<br><img src="/images/QQ截图20181103151137.png"></p><p>端口号：8082.</p><p>2）命令行：</p><p>java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar  <strong>–spring.profiles.active=dev；</strong></p><p>这里是（两个减号）<br><img src="/images/QQ截图20181103151355.png"><br><img src="/images/QQ截图20181103151622.png"><br><img src="/images/QQ截图20181103151704.png"></p><p>端口号是：8083</p><p><strong>激活的是prod，说明命令行参数的优先级 高于 配置文件的激活的优先级。</strong></p><p>3) 虚拟机参数；</p><p>-Dspring.profiles.active=dev</p><p>（这里是一个减号）<br><img src="/images/QQ截图20181103152038.png"><br><img src="/images/QQ截图20181103152205.png"><br><img src="/images/QQ截图20181103152225.png"></p><p>端口号：8082</p><p><strong>激活的是dev。说明虚拟机参数的优先级 高于 配置文件的优先级</strong></p><hr><p>当命令行参数与虚拟机参数同时存在时，以命令行参数为准。</p><p>即：命令行的优先级最高。</p><p><img src="/images/QQ截图20181103152736.png"><br><img src="/images/QQ截图20181103152756.png"></p><p>端口号是：8083</p><p>激活的是prod。</p><h5 id="yml支持多文档块方式"><a href="#yml支持多文档块方式" class="headerlink" title="yml支持多文档块方式"></a>yml支持多文档块方式</h5><p>在yml文件中，支持多文档块方式，即在一个yml文件中，书写多个文件配置。</p><p>使用—隔开。这里是三个减号。</p><p>首先，注释掉所有的properties文件和启动的命令行与虚拟机参数。</p><p>修改yml文件：</p><p><img src="/images/QQ截图20181103153342.png"></p><p>启动SpringBoot应用：<br><img src="/images/QQ截图20181103153506.png"></p><p>端口号：8084</p><p>激活的是dev文件。</p><h4 id="配置文件加载位置"><a href="#配置文件加载位置" class="headerlink" title="配置文件加载位置"></a>配置文件加载位置</h4><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件。</p><p>–file:./config/<br>–file:./<br>–classpath:/config/<br>–classpath:/</p><p><strong>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</strong></p><p>SpringBoot会从这四个位置全部加载主配置文件；<strong>互补配置。</strong></p><p>file：代表的是项目的根路径下。</p><p>classpath：代表的是resources下。</p><p>1）application.properties中：<br><img src="/images/QQ截图20181103155025.png"><br>端口号：8081</p><p>启动项目：<br><img src="/images/QQ截图20181103155147.png"><br>端口号启动的也是8081.</p><p>2）在resources下创建config包，并创建application.properties文件：<br><img src="/images/QQ截图20181103155312.png"><br>端口号是：8082</p><p>启动项目：<br><img src="/images/QQ截图20181103155414.png"><br>启动的端口号：8082</p><p>3）在项目的根路径下创建application.properties文件：</p><p>即：在spring-boot-02-config右键创建文件。<br><img src="/images/QQ截图20181103155603.png"><br>端口号：8083</p><p>启动项目：<br><img src="/images/QQ截图20181103155649.png"><br>启动的端口号：8083</p><p>4）在项目的根路径下创建config文件夹，并application.properties文件：<br><img src="/images/QQ截图20181103155800.png"><br>端口号：8084</p><p>启动项目：<br><img src="/images/QQ截图20181103155859.png"><br>启动的端口号：8084</p><p>印证了SpringBoot加载配置文件的优先级。</p><p>当四个位置都有配置文件时，是<strong>互补配置的</strong>。</p><p>即当高优先级的配置文件中存在低优先级的配置文件中的内容时会覆盖低优先级中的内容，但是当高优先级的配置文件中，没有低优先级文件中的内容时，会直接加载低优先级文件中的内容。</p><p><strong>注意：我们还可以通过spring.config.location来改变默认的配置文件位置</strong></p><p>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默<br>认加载的这些配置文件共同起作用形成互补配置；</p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar  –spring.config.location=G:/application.properties</p><p>此时：G:/application.properties文件的优先级最高，然后互补配置。</p><h4 id="外部配置加载顺序"><a href="#外部配置加载顺序" class="headerlink" title="外部配置加载顺序"></a>外部配置加载顺序</h4><p><strong>SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</strong></p><font color="red">1.命令行参数</font><br>所有的配置都可以在命令行上进行指定<br>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar  <strong>–server.port=8087  –server.context-path=/abc</strong><br><br>多个配置用空格分开； –配置项 = 值 (两个减号)<br><br>2.来自java:comp/env的JNDI属性<br><br>3.Java系统属性（System.getProperties()）<br><br>4.操作系统环境变量<br><br>5.RandomValuePropertySource配置的random.*属性值<br><br><strong>由jar包外向jar包内进行寻找；</strong><br><br><strong>优先加载带profile</strong><br><br><font color="red">6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</font><br><font color="red">7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</font><p><strong>再来加载不带profile</strong></p><font color="red">8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</font><br><font color="red">9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</font><p>10.@Configuration注解类上的@PropertySource<br>11.通过SpringApplication.setDefaultProperties指定的默认属性</p><p>所有支持的配置加载来源；</p><p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">参考官方文档</a></p><h4 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h4><p>配置文件到底能写什么？怎么写？自动配置原理；</p><p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p><h5 id="自动配置原理："><a href="#自动配置原理：" class="headerlink" title="自动配置原理："></a>自动配置原理：</h5><p>1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 <strong>@EnableAutoConfiguration</strong></p><p>2）、@EnableAutoConfiguration 作用：</p><ul><li>利用EnableAutoConfigurationImportSelector给容器中导入一些组件？</li><li>可以查看selectImports()方法的内容；</li><li>List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">SpringFactoriesLoader.loadFactoryNames()<br>扫描所有jar包类路径下  META‐INF/spring.factories<br>把扫描到的这些文件的内容包装成properties对象<br>从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器<br>中<br></code></pre></td></tr></table></figure></li></ul><p><strong>将类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；</strong></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># Auto Configure<br>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\<br>org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\<br>org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\<br>org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\<br>org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\<br>org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\<br>org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\<br>org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\<br>org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\<br>org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\<br>org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\<br>org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\<br>org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\<br>org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\<br>org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\<br>org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\<br>org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\<br>org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\<br>org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\<br>org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfi<br>guration,\<br>org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\<br>org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\<br>org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\<br>org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\<br>org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\<br>org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\<br>org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\<br>org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\<br>org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\<br>org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\<br>org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\<br>org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\<br>org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\<br>org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\<br>org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\<br>org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\<br>org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\<br>org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\<br>org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\<br>org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\<br>org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\<br>org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\<br>org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\<br>org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\<br>org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\<br>org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\<br>org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\<br>org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\<br>org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\<br>org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\<br>org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\<br>org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\<br>org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\<br>org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\<br>org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\<br>org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\<br>org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\<br>org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\<br>org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\<br>org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\<br>org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\<br>org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\<br>org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\<br>org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,<br>\<br>org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\<br>org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\<br>org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\<br>org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\<br>org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\<br>org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\<br>org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\<br>org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\<br>org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\<br>org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\<br>org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\<br>org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\<br>org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\<br>org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\<br>org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\<br>org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\<br>org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\<br>org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\<br>org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\<br>org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\<br>org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\<br>org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\<br>org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\<br>org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\<br>org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\<br>org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\<br>org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\<br>org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\<br>org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\<br>org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\<br>org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\<br>org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\<br>org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration<br></code></pre></td></tr></table></figure><p>每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p><p>3）、每一个自动配置类进行自动配置功能；</p><p>4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理；<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration   //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件<br>@EnableConfigurationProperties(HttpEncodingProperties.class)  //启动指定类的<br>ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把<br>HttpEncodingProperties加入到ioc容器中<br>@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果<br>满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是web应用，如果是，当前配置类生效<br>@ConditionalOnClass(CharacterEncodingFilter.class)  //判断当前项目有没有这个类<br>CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；<br>@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing =<br>true)  //判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的<br>//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；<br>public class HttpEncodingAutoConfiguration &#123;<br> <br>   //他已经和SpringBoot的配置文件映射了  <br>   private final HttpEncodingProperties properties;<br><br>   //只有一个有参构造器的情况下，参数的值就会从容器中拿<br>   public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123;  <br>      this.properties = properties;        <br>   &#125;    <br> <br>@Bean   //给容器中添加一个组件，这个组件的某些值需要从properties中获取<br>@ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？    <br>public CharacterEncodingFilter characterEncodingFilter() &#123;    <br>CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();        <br>filter.setEncoding(this.properties.getCharset().name());        <br>filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));        <br>filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));        <br>return filter;        <br>&#125;<br></code></pre></td></tr></table></figure></p><p>根据当前不同的条件判断，决定这个配置类是否生效？</p><p>一旦这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p><p>5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者；配置文件能配置什么就可以参照某个功能对应的这个属性类</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@ConfigurationProperties(prefix = &quot;spring.http.encoding&quot;)  //从配置文件中获取指定的值和bean的属<br>性进行绑定<br>public class HttpEncodingProperties &#123;<br>   public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF‐8&quot;);<br></code></pre></td></tr></table></figure><p><strong>精髓：<br>1）、SpringBoot启动会加载大量的自动配置类<br>2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；<br>3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）<br>4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这<br>些属性的值.</strong></p><p>xxxxAutoConfigurartion：自动配置类；给容器中添加组件</p><p>xxxxProperties:封装配置文件中相关属性；</p><h5 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h5><p>1、@Conditional派生注解（Spring注解版原生的@Conditional作用）</p><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置里面的所有内容才生效；</p><p><img src="/images/QQ截图20181103170857.png"></p><p><strong>自动配置类必须在一定的条件下才能生效；</strong></p><p>我们怎么知道哪些自动配置类生效；</p><font color="#EE2C2C">我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</font><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">=========================<br>AUTO‐CONFIGURATION REPORT<br>=========================<br>Positive matches:（自动配置类启用的）<br>‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐<br>   DispatcherServletAutoConfiguration matched:<br> ‐ @ConditionalOnClass found required class<br>&apos;org.springframework.web.servlet.DispatcherServlet&apos;; @ConditionalOnMissingClass did not find<br>unwanted class (OnClassCondition)<br>      ‐ @ConditionalOnWebApplication (required) found StandardServletEnvironment<br>(OnWebApplicationCondition)<br>       <br>   <br>Negative matches:（没有启动，没有匹配成功的自动配置类）<br>‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐<br>   ActiveMQAutoConfiguration:<br>      Did not match:<br>         ‐ @ConditionalOnClass did not find required classes &apos;javax.jms.ConnectionFactory&apos;,<br>&apos;org.apache.activemq.ActiveMQConnectionFactory&apos; (OnClassCondition)<br>   AopAutoConfiguration:<br>      Did not match:<br>         ‐ @ConditionalOnClass did not find required classes<br>&apos;org.aspectj.lang.annotation.Aspect&apos;, &apos;org.aspectj.lang.reflect.Advice&apos; (OnClassCondition)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot_day_01</title>
      <link href="/2018/11/02/SpringBoot-day-01/"/>
      <url>/2018/11/02/SpringBoot-day-01/</url>
      
        <content type="html"><![CDATA[<p>Spring boot 来简化Spring应用开发，约定大于配置，去繁从简，just run就能创建一个独立的，产品级别的应用。<br><a id="more"></a></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>J2EE笨重的开发、繁多的配置、低下的开发效率、复杂的部署流程、第三方技术集成难度大。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>“Spring全家桶”时代.</p><p>SpringBoot -&gt; J2EE一站式解决方案</p><p>SpingCloud -&gt; 分布式整体解决方案</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>快速创建独立运行的Spring项目以及与主流框架集成  </li><li>使用嵌入式的Servlet容器，应用无需打成WAR包  </li><li>starters自动依赖与版本控制  </li><li>大量的自动配置，简化开发，也可修改默认值  </li><li>无需配置XML，无代码生成，开箱即用  </li><li>准生产环境的运行时应用监控  </li><li>与云计算的天然集成  </li></ul><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>2014，martin fowler</p><p>微服务：架构风格（服务微化）</p><p>一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；</p><p>单体应用：ALL IN ONE</p><p>微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；</p><p><a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa" title="微服务参考" target="_blank" rel="noopener">微服务参考</a></p><h3 id="环境约束："><a href="#环境约束：" class="headerlink" title="环境约束："></a>环境约束：</h3><ul><li>jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112”  </li><li>maven3.x：maven 3.3以上版本；Apache Maven 3.3.9  </li><li>IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64 、STS  </li><li>SpringBoot 1.5.9.RELEASE：1.5.9；  </li></ul><p><a href="https://pan.baidu.com/s/1ay5tPJkNJeptSkFgjiL_Zw" target="_blank" rel="noopener">环境软件下载</a></p><p>密码：jpro</p><p>统一环境；</p><p><strong>1.Maven设置</strong></p><p>给maven 的 settings.xml配置文件的profiles标签添加</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;profile&gt;<br>  &lt;id&gt;jdk‐1.8&lt;/id&gt;<br>  &lt;activation&gt;<br>    &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;<br>    &lt;jdk&gt;1.8&lt;/jdk&gt;<br>  &lt;/activation&gt;<br>  &lt;properties&gt;<br>    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;<br>    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;<br>    &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;<br>  &lt;/properties&gt;<br>&lt;/profile&gt;<br></code></pre></td></tr></table></figure><p><strong>2.IDEA设置</strong></p><p>整合maven进来</p><p><img src="/images/QQ截图20181102151849.png"><br><img src="/images/QQ截图20181102152017.png"></p><p>将maven配置成我们的maven，不使用idea自带的maven。</p><p>Maven home directory： maven的安装路径</p><p>User setting file：maven的setting配置文件的路径</p><p>Local repository：maven的本地仓库的路径。</p><h3 id="Spring-Boot-HelloWorld"><a href="#Spring-Boot-HelloWorld" class="headerlink" title="Spring Boot HelloWorld"></a>Spring Boot HelloWorld</h3><p>一个功能：</p><p>浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；</p><h4 id="创建一个maven项目-jar"><a href="#创建一个maven项目-jar" class="headerlink" title="创建一个maven项目(jar)"></a>创建一个maven项目(jar)</h4><p><img src="/images/QQ截图20181102154909.png"><br><img src="/images/QQ截图20181102155112.png"><br><img src="/images/QQ截图20181102155230.png"><br><img src="/images/QQ截图20181102155348.png"><br><img src="/images/QQ截图20181102155708.png"></p><h4 id="导入spring-boot相关的依赖"><a href="#导入spring-boot相关的依赖" class="headerlink" title="导入spring boot相关的依赖"></a>导入spring boot相关的依赖</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;parent&gt;<br>        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring‐boot‐starter‐parent&lt;/artifactId&gt;<br>        &lt;version&gt;1.5.17.RELEASE&lt;/version&gt;<br>   &lt;/parent&gt;<br><br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br></code></pre></td></tr></table></figure><p><strong>现在的spring boot的1.x的版本没有1.5.9，所以我们使用1.5.17.RELEASE。</strong></p><p>我们可以参考Spring的官网的文档。<a href="https://spring.io/" target="_blank" rel="noopener">Spring官网</a><br><img src="/images/QQ截图20181102160852.png"><br><img src="/images/QQ截图20181102161036.png"><br><img src="/images/QQ截图20181102161400.png"></p><p>添加依赖后，idea就会帮我们开始下载依赖，如果没有自动下载，可以点击idea的右边的Maven Projects，然后点击上面的循环标志。<br><img src="/images/QQ截图20181102162613.png" style="width:50%"></p><p>依赖下载完毕后，可以看到我们的依赖文件：<br><img src="/images/QQ截图20181102162819.png"></p><h4 id="编写一个主程序"><a href="#编写一个主程序" class="headerlink" title="编写一个主程序"></a>编写一个主程序</h4><p>在src/main/java下创建com.liuzhuo的包，并创建HelloWorldApplication类：<br><img src="/images/QQ截图20181102163202.png"></p><p>添加@SpringBootApplication注解，并编写一个主函数。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@SpringBootApplication  //表明这是一个Springboot的启动类<br>public class HelloWorldApplication &#123;<br><br>    public static void main(String[] args) &#123;<br>        //启动Springboot应用。<br>        SpringApplication.run(HelloWorldApplication.class);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="编写相关的Controller"><a href="#编写相关的Controller" class="headerlink" title="编写相关的Controller"></a>编写相关的Controller</h4><p>在com.liuzhuo.controller下，创建HelloController<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Controller<br>public class HelloController &#123;<br>    @ResponseBody<br>    @RequestMapping(&quot;/hello&quot;)<br>    public String hello()&#123;<br>        return &quot;Hello World!&quot;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="运行主程序测试"><a href="#运行主程序测试" class="headerlink" title="运行主程序测试"></a>运行主程序测试</h4><p>回到Springboot的启动类中，直接运行main函数：<br><img src="/images/QQ截图20181102163832.png"><br><img src="/images/QQ截图20181102163913.png"><br><img src="/images/QQ截图20181102163946.png"></p><p>出现上图所示的效果就说明Springboot应用启动成功。</p><p>在浏览器中输入：<code>http://localhost:8080/hello</code></p><p><img src="/images/QQ截图20181102164146.png"></p><h4 id="简化部署"><a href="#简化部署" class="headerlink" title="简化部署"></a>简化部署</h4><p>以前，部署Web应用，需要将我们的Web项目生成War，然后在服务器中安装服务器，比如Tomcat等，然后将War放在Tomcat容器中，启动Tomcat容器。</p><p>现在，我们不需要这么麻烦了，我们直接生成jar就行。生成jar之前，我们需要在pom文件中添加Springboot的构建插件。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包--&gt;<br>&lt;build&gt;<br>    &lt;plugins&gt;<br>        &lt;plugin&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;<br>        &lt;/plugin&gt;<br>    &lt;/plugins&gt;<br>&lt;/build&gt;<br></code></pre></td></tr></table></figure></p><p>然后生成jar包：<br><img src="/images/QQ截图20181102164849.png" style="width:50%"></p><p>双击：package。</p><p>控制台输出：BUILD SUCCESS<br><img src="/images/QQ截图20181102165053.png"></p><p>我们，可以在target包下，看到我们生成的可运行的jar。<br><img src="/images/QQ截图20181102165310.png"></p><p>拷贝这个jar到我们的桌面上面：<br><img src="/images/QQ截图20181102165410.png"></p><p>打开命令行界面：<br><img src="/images/QQ截图20181102165718.png"></p><p>我们的Springboot应用就启动了，这样是不是很简单，都不需要打成war包和安装Tomcat。</p><p>在浏览器中输入：<code>http://localhost:8080/hello</code></p><p><img src="/images/QQ截图20181102164146.png"></p><h3 id="Hello-World-的探究"><a href="#Hello-World-的探究" class="headerlink" title="Hello World 的探究"></a>Hello World 的探究</h3><h4 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h4><p>1）父项目</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;parent&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring‐boot‐starter‐parent&lt;/artifactId&gt;<br>    &lt;version&gt;1.5.17.RELEASE&lt;/version&gt;<br>&lt;/parent&gt;<br>他的父项目是<br>&lt;parent&gt;<br>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>  &lt;artifactId&gt;spring‐boot‐dependencies&lt;/artifactId&gt;<br>  &lt;version&gt;1.5.17.RELEASE&lt;/version&gt;<br>  &lt;relativePath&gt;../../spring‐boot‐dependencies&lt;/relativePath&gt;<br>&lt;/parent&gt;<br>他来真正管理Spring Boot应用里面的所有依赖版本；<br></code></pre></td></tr></table></figure><p>Spring Boot的版本仲裁中心；</p><p>以后我们导入依赖,默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）</p><p>2) 启动器</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>spring-boot-starter-web：</p><p>spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；</p><p>Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter.<br>相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器.</p><h4 id="主程序类，主入口类"><a href="#主程序类，主入口类" class="headerlink" title="主程序类，主入口类"></a>主程序类，主入口类</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">/**<br> * 描述:<br> *<br> * @author liuzhuo<br> * @create 2018-11-02 16:31<br> */<br>@SpringBootApplication  //表明这是一个Springboot的启动类<br>public class HelloWorldApplication &#123;<br><br>    public static void main(String[] args) &#123;<br>        //启动Springboot应用。<br>        SpringApplication.run(HelloWorldApplication.class);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>@SpringBootApplication:</strong> Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot<br>就应该运行这个类的main方法来启动SpringBoot应用；</p><p>点击@SpringBootApplication注解：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Target(ElementType.TYPE)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>@Inherited<br>@SpringBootConfiguration<br>@EnableAutoConfiguration<br>@ComponentScan(excludeFilters = &#123;<br>@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),<br>@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)<br>public @interface SpringBootApplication<br></code></pre></td></tr></table></figure></p><p>发现@SpringBootApplication注解是一个组合注解，下面我们一一来看。</p><p><strong>@SpringBootConfiguration:</strong> Spring Boot的配置类；</p><p>标注在某个类上，表示这是一个Spring Boot的配置类；<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Target(&#123;ElementType.TYPE&#125;)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>@Configuration<br>public @interface SpringBootConfiguration &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>其实就是一个@Configuration注解，只是@Configuration注解，我们是在Spring中使用，@SpringBootConfiguration是在Springboot中使用，本质都一个配置类。</p><p>配置类 —– 配置文件；配置类也是容器中的一个组件；@Component</p><p><strong>@EnableAutoConfiguration</strong>：开启自动配置功能；</p><p>以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自<br>动配置功能；这样自动配置才能生效；<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@SuppressWarnings(&quot;deprecation&quot;)<br>@Target(ElementType.TYPE)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>@Inherited<br>@AutoConfigurationPackage<br>@Import(EnableAutoConfigurationImportSelector.class)<br>public @interface EnableAutoConfiguration<br></code></pre></td></tr></table></figure></p><p><strong>@AutoConfigurationPackage</strong>：自动配置包<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Target(ElementType.TYPE)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>@Inherited<br>@Import(AutoConfigurationPackages.Registrar.class)<br>public @interface AutoConfigurationPackage &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>@Import(AutoConfigurationPackages.Registrar.class)：<br>Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class注入；</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Order(Ordered.HIGHEST_PRECEDENCE)<br>static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;<br><br>@Override<br>public void registerBeanDefinitions(AnnotationMetadata metadata,<br>BeanDefinitionRegistry registry) &#123;<br>register(registry, new PackageImport(metadata).getPackageName());<br>&#125;<br><br>@Override<br>public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123;<br>return Collections.&lt;Object&gt;singleton(new PackageImport(metadata));<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>给这个方法打上断点。debug下</p><p><strong>会发现，Spring会把将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；</strong></p><p>@<strong>Import(EnableAutoConfigurationImportSelector.class)；</strong></p><p>给容器中导入组件？</p><p>EnableAutoConfigurationImportSelector：导入哪些组件的选择器；</p><p>将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；</p><p>会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；<br><img src="/images/QQ截图20181102192759.png"></p><p>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；<br>SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；</p><p>Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将<br>这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；以前我们需要自己配置的东<br>西，自动配置类都帮我们；<br><img src="/images/QQ截图20181102193127.png"></p><p>J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.17.RELEASE.jar；</p><p>所以，@EnableAutoConfiguration自动配置的魔法骑士就变成了：</p><p><strong>从classpath中搜寻所有的 META-INF/spring.factories 配置文件，并将其中org.springframework.boot.autoconfigure.EnableutoConfiguration对应的配置项</strong>  </p><p><strong>通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。</strong></p><h3 id="深入探索SpringApplication执行流程"><a href="#深入探索SpringApplication执行流程" class="headerlink" title="深入探索SpringApplication执行流程"></a>深入探索SpringApplication执行流程</h3><p>SpringApplication的run方法的实现是我们本次旅程的主要线路，该方法的主要流程大体可以归纳如下：</p><p>1） 如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：</p><ul><li>根据classpath里面是否存在某个特征类（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。</li><li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。</li><li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。</li><li>推断并设置main方法的定义类。</li></ul><p>2）SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行开始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。</p><p>3） 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。</p><p>4） 遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。</p><p>5） 如果SpringApplication的showBanner属性被设置为true，则打印banner。</p><p>6） 根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。</p><p>7） ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。</p><p>8） 遍历调用所有SpringApplicationRunListener的contextPrepared()方法。</p><p>9） 最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。</p><p>10） 遍历调用所有SpringApplicationRunListener的contextLoaded()方法。</p><p>11） 调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。</p><p>12） 查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。</p><p>13） 正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）</p><p><strong>总结</strong></p><p>到此，SpringBoot的核心组件完成了基本的解析，综合来看，大部分都是Spring框架背后的一些概念和实践方式，SpringBoot只是在这些概念和实践上对特定的场景事先进行了固化和升华，而也恰恰是这些固化让我们开发基于Sping框架的应用更加方便高效。</p><h3 id="使用Spring-Initializer快速创建Spring-Boot项目"><a href="#使用Spring-Initializer快速创建Spring-Boot项目" class="headerlink" title="使用Spring Initializer快速创建Spring Boot项目"></a>使用Spring Initializer快速创建Spring Boot项目</h3><p>IDE都支持使用<strong>Spring的项目创建向导</strong>快速创建一个Spring Boot项目；<br>选择我们需要的模块；向导会联网创建Spring Boot项目；<br>默认生成的Spring Boot项目；<br>主程序已经生成好了，我们只需要我们自己的逻辑</p><p>resources文件夹中目录结构：</p><ul><li>static：保存所有的静态资源； js css images；</li><li>templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的- - Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；</li><li>application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；</li></ul><p>1）打开idea，创建一个工程Project<br><img src="/images/QQ截图20181102201430.png"></p><p>2）选择Spring Initializr<br><img src="/images/QQ截图20181102201714.png"></p><p>3) 填写Group和Artifact<br><img src="/images/QQ截图20181102202215.png"></p><p>4）选择Spring boot的版本 和 我们需要的模块（Web）<br><img src="/images/QQ截图20181102202456.png"></p><p>5）填写项目名和项目的路径<br><img src="/images/QQ截图20181102202648.png"></p><p>6）删除不需要的文件<br><img src="/images/QQ截图20181102202925.png"></p><p>7）编写逻辑控制层<br>在com.liuzhuo.springboot的包下，创建controller包，并创建HelloController：<br><img src="/images/QQ截图20181102205841.png"></p><p>8）启动Springboot应用<br><img src="/images/QQ截图20181102210019.png"></p><p>9）在浏览器中输入：<code>http://localhost:8080/hello</code><br><img src="/images/QQ截图20181102210130.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>idea创建maven-web工程</title>
      <link href="/2018/10/29/idea%E5%88%9B%E5%BB%BAmaven-web%E5%B7%A5%E7%A8%8B/"/>
      <url>/2018/10/29/idea%E5%88%9B%E5%BB%BAmaven-web%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>考虑到现在大家都是使用maven来创建web工程，不再使用创建原始的Dynamic Web工程了，所以，我们开始吧~~~<br><a id="more"></a></p><h3 id="首先先创建一个project-一个project就是一个工作空间-，在这里就是创建一个maven的工作空间"><a href="#首先先创建一个project-一个project就是一个工作空间-，在这里就是创建一个maven的工作空间" class="headerlink" title="首先先创建一个project(一个project就是一个工作空间)，在这里就是创建一个maven的工作空间"></a>首先先创建一个project(一个project就是一个工作空间)，在这里就是创建一个maven的工作空间</h3><p><img src="/images/QQ截图20181029170715.png" style="width:50%"></p><h3 id="你要选择maven然后按照下面图片-的指示操作就可以了—-gt-最后点击next按钮"><a href="#你要选择maven然后按照下面图片-的指示操作就可以了—-gt-最后点击next按钮" class="headerlink" title="你要选择maven然后按照下面图片 的指示操作就可以了—&gt;最后点击next按钮"></a>你要选择maven然后按照下面图片 的指示操作就可以了—&gt;最后点击next按钮</h3><p><img src="/images/QQ截图20181029171222.png"></p><h3 id="填写，groupID、ArtifactID"><a href="#填写，groupID、ArtifactID" class="headerlink" title="填写，groupID、ArtifactID"></a>填写，groupID、ArtifactID</h3><p><img src="/images/QQ截图20181029171531.png"></p><h3 id="配置maven的本地仓库的位置"><a href="#配置maven的本地仓库的位置" class="headerlink" title="配置maven的本地仓库的位置"></a>配置maven的本地仓库的位置</h3><p>是通过修改settings.xml中的文件的位置放置问题，还有你要加上阿里巴巴的仓库，这样你的下载速度就会加快，如果你不采用阿里巴巴的仓库，你要下载你需要的jar包的话，你就要通过FQ去下载，你的速度就会变慢，是某些包！！！！<br><img src="/images/QQ截图20181029172013.png"></p><h3 id="填写项目名"><a href="#填写项目名" class="headerlink" title="填写项目名"></a>填写项目名</h3><p>一般不用改了，直接finish<br><img src="/images/QQ截图20181029172634.png"></p><h3 id="喝杯咖啡，泡杯茶稍安勿躁，等一等。maven正在下载架构"><a href="#喝杯咖啡，泡杯茶稍安勿躁，等一等。maven正在下载架构" class="headerlink" title="喝杯咖啡，泡杯茶稍安勿躁，等一等。maven正在下载架构"></a>喝杯咖啡，泡杯茶稍安勿躁，等一等。maven正在下载架构</h3><p><img src="/images/QQ截图20181029172839.png"></p><h3 id="等出结果，如果目录结构还不出来直接按图操作一波"><a href="#等出结果，如果目录结构还不出来直接按图操作一波" class="headerlink" title="等出结果，如果目录结构还不出来直接按图操作一波"></a>等出结果，如果目录结构还不出来直接按图操作一波</h3><p><img src="/images/QQ截图20181029172941.png"></p><h3 id="项目的基本目录结构出来后我们最后还需要为项目配置下编译路径。"><a href="#项目的基本目录结构出来后我们最后还需要为项目配置下编译路径。" class="headerlink" title="项目的基本目录结构出来后我们最后还需要为项目配置下编译路径。"></a>项目的基本目录结构出来后我们最后还需要为项目配置下编译路径。</h3><p><img src="/images/QQ截图20181029173041.png" style="width:50%"></p><p>点击Modules，如果你的是空的的话，就需要配置了，如果存在就不需要配置了，idea201703版本后，会自动帮我们配置的。<br><img src="/images/QQ截图20181029173524.png" style="width:50%"><br><img src="/images/QQ截图20181029173829.png"></p><p>如果你的idea的自动帮你配置了，你只需要检查那两个路径对不对即可，一般都是对的。</p><h3 id="为项目配置下Artifacts"><a href="#为项目配置下Artifacts" class="headerlink" title="为项目配置下Artifacts"></a>为项目配置下Artifacts</h3><p>和Modules一样，如果已经存在了，就不要配置了。如果没有的话<br><img src="/images/QQ截图20181029174352.png" style="width:50%"></p><p>选择我们的项目<br><img src="/images/QQ截图20181029174451.png"></p><h3 id="配置Tomcat容器"><a href="#配置Tomcat容器" class="headerlink" title="配置Tomcat容器"></a>配置Tomcat容器</h3><p><img src="/images/QQ截图20181029174611.png"></p><p>出现这个画面，然后按图再操作一波<br><img src="/images/QQ截图20181029174659.png" style="width:50%"></p><p>接着出现这个画面，继续看图操作<br><img src="/images/QQ截图20181029175057.png"></p><p>然后你选择右边第二个选项，Deployment，还是看图操作。。。<br><img src="/images/QQ截图20181029175151.png"><br><img src="/images/QQ截图20181029175319.png"></p><p>最后点击ok完成Tomcat配置，现在就可以启动tomcat跑跑我们的helloWorld了！</p><h3 id="启动tomcat，看效果"><a href="#启动tomcat，看效果" class="headerlink" title="启动tomcat，看效果"></a>启动tomcat，看效果</h3><p><img src="/images/QQ截图20181029175623.png"><br><img src="/images/QQ截图20181029175655.png"></p><h3 id="配置src-main-java"><a href="#配置src-main-java" class="headerlink" title="配置src/main/java"></a>配置src/main/java</h3><p>如上图，src/main目录下缺少java目录，我们可以右键创建目录java，然后再modules中配置为Sources目录</p><p><img src="/images/QQ截图20181030112516.png"></p><p>这样src/main/java图标就变成了蓝色，作为java源代码区了。</p><h3 id="配置src-main-resources"><a href="#配置src-main-resources" class="headerlink" title="配置src/main/resources"></a>配置src/main/resources</h3><p>如上图，src/main目录下缺少resources目录，我们可以右键创建目录resources，然后再modules中配置为Resources目录<br><img src="/images/QQ截图20181030112807.png"></p><p>这样src/main/resources图标就变成了右下角有黄标了，作为resources资源区了。</p>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
          <category> maven </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> idea </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决idea控制台输出乱码问题</title>
      <link href="/2018/10/29/%E8%A7%A3%E5%86%B3idea%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/2018/10/29/%E8%A7%A3%E5%86%B3idea%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>解决IntelliJ IDEA 控制台输出乱码问题<br><a id="more"></a></p><h3 id="找到安装Intellij-idea目录bin下面的idea-exe-vmoptions和idea64-exe-vmoptions文件，我的安装目录是D-IntelliJ-IDEA-IntelliJ-IDEA-15-0-2-bin"><a href="#找到安装Intellij-idea目录bin下面的idea-exe-vmoptions和idea64-exe-vmoptions文件，我的安装目录是D-IntelliJ-IDEA-IntelliJ-IDEA-15-0-2-bin" class="headerlink" title="找到安装Intellij idea目录bin下面的idea.exe.vmoptions和idea64.exe.vmoptions文件，我的安装目录是D:\IntelliJ IDEA\IntelliJ IDEA 15.0.2\bin"></a>找到安装Intellij idea目录bin下面的idea.exe.vmoptions和idea64.exe.vmoptions文件，我的安装目录是D:\IntelliJ IDEA\IntelliJ IDEA 15.0.2\bin</h3><p><img src="/images/QQ截图20181029164601.png"></p><h3 id="修改idea-exe-vmoptions和idea64-exe-vmoptions文件，在末尾添加-Dfile-encoding-UTF-8"><a href="#修改idea-exe-vmoptions和idea64-exe-vmoptions文件，在末尾添加-Dfile-encoding-UTF-8" class="headerlink" title="修改idea.exe.vmoptions和idea64.exe.vmoptions文件，在末尾添加                -Dfile.encoding=UTF-8"></a>修改idea.exe.vmoptions和idea64.exe.vmoptions文件，在末尾添加                -Dfile.encoding=UTF-8</h3><p><img src="/images/QQ截图20181029164704.png"></p><h3 id="设置idea-file编码。在菜单栏找到”File-gt-settings-gt-搜索File-Encodeing”-设置utf-8。如图所示"><a href="#设置idea-file编码。在菜单栏找到”File-gt-settings-gt-搜索File-Encodeing”-设置utf-8。如图所示" class="headerlink" title="设置idea file编码。在菜单栏找到”File-&gt;settings-&gt;搜索File Encodeing” 设置utf-8。如图所示"></a>设置idea file编码。在菜单栏找到”File-&gt;settings-&gt;搜索File Encodeing” 设置utf-8。如图所示</h3><p><img src="/images/QQ截图20181029164741.png"></p><h3 id="设置idea-server编码。在菜单栏找到”run-gt-editconfigration”-找到”server”选项卡-设置-vm-option为-Dfile-encoding-utf-8，如图所示"><a href="#设置idea-server编码。在菜单栏找到”run-gt-editconfigration”-找到”server”选项卡-设置-vm-option为-Dfile-encoding-utf-8，如图所示" class="headerlink" title="设置idea server编码。在菜单栏找到”run-&gt;editconfigration” 找到”server”选项卡 设置 vm option为 -Dfile.encoding=utf-8，如图所示"></a>设置idea server编码。在菜单栏找到”run-&gt;editconfigration” 找到”server”选项卡 设置 vm option为 -Dfile.encoding=utf-8，如图所示</h3><p><img src="/images/QQ截图20181029164814.png"></p><h3 id="重启Intellij-IDEA"><a href="#重启Intellij-IDEA" class="headerlink" title="重启Intellij IDEA"></a>重启Intellij IDEA</h3>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
          <category> 乱码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
            <tag> 乱码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Servlet3.0与SpringMVC整合</title>
      <link href="/2018/10/29/Servlet3-0%E4%B8%8ESpringMVC%E6%95%B4%E5%90%88/"/>
      <url>/2018/10/29/Servlet3-0%E4%B8%8ESpringMVC%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>Servlet3.0与SpringMVC的整合，永久告别web.xml的配置文件啦~~<br><a id="more"></a></p><h3 id="创建maven-web工程"><a href="#创建maven-web工程" class="headerlink" title="创建maven-web工程"></a>创建maven-web工程</h3><p>如果大家对idea创建maven-web工程不熟悉的话，去看我的另一篇博客<a href="https://gakkil.top/2018/10/29/idea%E5%88%9B%E5%BB%BAmaven-web%E5%B7%A5%E7%A8%8B/" target="_blank" rel="noopener">idea创建maven-web工程</a></p><p><img src="/images/QQ截图20181029201934.png" style="width:50%"></p><h3 id="打开pom-xml文件"><a href="#打开pom-xml文件" class="headerlink" title="打开pom.xml文件"></a>打开pom.xml文件</h3><p>添加两个依赖，Springmvc和servlet的依赖<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;<br>    &lt;version&gt;4.1.9.RELEASE&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;<br>    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;<br>    &lt;version&gt;3.1.0&lt;/version&gt;  &lt;!-- 3.0以上的版本都可以--&gt;<br>    &lt;scope&gt;provided&lt;/scope&gt;   &lt;!-- 因为Tomcat容器中有servlet的jar，所以打成war包的时候，不需要这个--&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><h3 id="现在开始整合SpringMVC开发。打开Spring的官网。"><a href="#现在开始整合SpringMVC开发。打开Spring的官网。" class="headerlink" title="现在开始整合SpringMVC开发。打开Spring的官网。"></a>现在开始整合SpringMVC开发。打开Spring的官网。</h3><p>找到相关的文档处<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#spring-web" target="_blank" rel="noopener">Spring-web</a></p><p>我们能发现在servlet3.0以后，官网推不再使用web.xml开发，直接使用java的配置类来替代web.xml文件。</p><p>我们只需要编写一个类实现<strong>WebApplicationInitializer</strong>接口，就相当于web.xml文件了。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyWebApplicationInitializer implements WebApplicationInitializer &#123;<br><br>    @Override<br>    public void onStartup(ServletContext servletCxt) &#123;<br><br>        // Load Spring web application configuration<br>        AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();<br>        ac.register(AppConfig.class);<br>        ac.refresh();<br><br>        // Create and register the DispatcherServlet<br>        DispatcherServlet servlet = new DispatcherServlet(ac);<br>        ServletRegistration.Dynamic registration = servletCxt.addServlet(&quot;app&quot;, servlet);<br>        registration.setLoadOnStartup(1);<br>        registration.addMapping(&quot;/app/*&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>容器启动后，会执行这个实现WebApplicationInitializer接口的实现类。然后执行onStartup()方法。</p><p>在该方法中，创建了注解式配置应用上下文，传入spring的配置文件。然后向该容器中注入DispatcherServlet，来完成SpringMVC的前端控制器。</p><p><font color="red"><strong>重点</strong></font>:</p><p>那为啥实现了WebApplicationInitializer接口的实现类，在容器启动时调用呢？</p><p>首先打开这个接口：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public interface WebApplicationInitializer &#123;<br><br>/**<br> * Configure the given &#123;@link ServletContext&#125; with any servlets, filters, listeners<br> * context-params and attributes necessary for initializing this web application. See<br> * examples &#123;@linkplain WebApplicationInitializer above&#125;.<br> * @param servletContext the &#123;@code ServletContext&#125; to initialize<br> * @throws ServletException if any call against the given &#123;@code ServletContext&#125;<br> * throws a &#123;@code ServletException&#125;<br> */<br>void onStartup(ServletContext servletContext) throws ServletException;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>只有一个方法，看不出什么头绪。但是，在这个包下有另外一个类，SpringServletContainerInitializer。它的实现如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@HandlesTypes(WebApplicationInitializer.class)<br>public class SpringServletContainerInitializer implements ServletContainerInitializer &#123;<br><br>@Override<br>public void onStartup(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)<br>throws ServletException &#123;<br><br>List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;WebApplicationInitializer&gt;();<br><br>if (webAppInitializerClasses != null) &#123;<br>for (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;<br>// Be defensive: Some servlet containers provide us with invalid classes,<br>// no matter what @HandlesTypes says...<br>if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;<br>WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123;<br>try &#123;<br>initializers.add((WebApplicationInitializer) waiClass.newInstance());<br>&#125;<br>catch (Throwable ex) &#123;<br>throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br>if (initializers.isEmpty()) &#123;<br>servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;);<br>return;<br>&#125;<br><br>AnnotationAwareOrderComparator.sort(initializers);<br>servletContext.log(&quot;Spring WebApplicationInitializers detected on classpath: &quot; + initializers);<br><br>for (WebApplicationInitializer initializer : initializers) &#123;<br>initializer.onStartup(servletContext);<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>这个类就比较有意思了，先不管其他的，读一下这段代码，可以得到这样的意思。</p><p>先判断webAppInitializerClasses这个Set是否为空。如果不为空的话，找到这个set中不是接口，不是抽象类，并且是WebApplicationInitializer接口实现类的类，将它们保存到list中。当这个list为空的时候，直接return。不为空的话就按照一定的顺序排序，并将它们按照一定的顺序实例化。调用<strong>其onStartup方法执行</strong>。到这里，就可以解释WebApplicationInitializer实现类的工作过程了。</p><p><strong>但是，在web项目运行的时候，SpringServletContainerInitializer这个类又是怎样被调用的呢？</strong></p><p>再看被它实现的ServletContainerInitializer这个接口<br>它只有一个接口方法onStartup()，通过它就可以解释SpringServletContainerInitializer是如何被调用的。它的内容如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package javax.servlet;<br> <br>import java.util.Set;<br> <br>public interface ServletContainerInitializer &#123;<br>    void onStartup(Set&lt;Class&lt;?&gt;&gt; var1, ServletContext var2) throws ServletException;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>首先，这个接口是javax.servlet下的，官方的解释是这样的：</p><p>为了支持可以不使用web.xml。提供了ServletContainerInitializer，它可以通过SPI机制。</p><p>当启动web容器的时候，会自动到添加的相应jar包下找到META-INF/services/javax.servlet.ServletContainerInitializer文件。</p><p>它的内容为ServletContainerInitializer实现类的全路径，将它们实例化。</p><p>既然这样的话，那么SpringServletContainerInitializer作为ServletContainerInitializer的实现类，它的jar包下也应该有相应的文件。<br><img src="/images/QQ截图20181029211845.png"></p><p>哈，现在就可以解释清楚了。首先，SpringServletContainerInitializer作为ServletContainerInitializer的实现类，通过SPI机制，在web容器加载的时候会自动的被调用。（这个类上还有一个注解@HandlesTypes，它的作用是将感兴趣的一些类注入到ServletContainerInitializer）， 而这个类的方法又会扫描找到WebApplicationInitializer的实现类，调用它的onStartup方法，从而起到启动web.xml相同的作用。</p><hr><p>等价于web.xml文件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;web-app&gt;<br><br>    &lt;!-- 注册这个监听器来注入Spring的父容器--&gt;<br>    &lt;listener&gt;<br>        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;<br>    &lt;/listener&gt;<br><br>    &lt;context-param&gt;<br>        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;<br>        &lt;param-value&gt;/WEB-INF/app-context.xml&lt;/param-value&gt;<br>    &lt;/context-param&gt;<br><br>    &lt;!-- 注册这个Servlet来注入SpringMVC的子容器--&gt;<br>    &lt;servlet&gt;<br>        &lt;servlet-name&gt;app&lt;/servlet-name&gt;<br>        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;<br>        &lt;init-param&gt;<br>            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;<br>            &lt;param-value&gt;&lt;/param-value&gt;<br>        &lt;/init-param&gt;<br>        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;<br>    &lt;/servlet&gt;<br><br>    &lt;servlet-mapping&gt;<br>        &lt;servlet-name&gt;app&lt;/servlet-name&gt;<br>        &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;<br>    &lt;/servlet-mapping&gt;<br><br>&lt;/web-app&gt;<br></code></pre></td></tr></table></figure></p><p>总结：</p><p>1）servlet3.0以后的Web容器在启动的时候，会扫描每个jar包下的META-INF/services/javax.servlet.ServletContainerInitializer文件</p><p>2）加载这个文件指定的类(实现了ServletContainerInitializer接口)，并调用这个接口的onStartup()方法。<br>void onStartup(Set&lt;Class&lt;?&gt;&gt; var1, ServletContext var2) throws ServletException;</p><p>3）现在，我们在pom.xml文件中加入了spring-mvc的依赖，其中有一个jar：<br><img src="/images/QQ截图20181029214152.png" style="width:50%"></p><p>在该META-INF/services/javax.servlet.ServletContainerInitializer文件下，有一个：org.springframework.web.SpringServletContainerInitializer的全路径。</p><p>打开SpringServletContainerInitializer类。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@HandlesTypes(WebApplicationInitializer.class)<br>public class SpringServletContainerInitializer implements ServletContainerInitializer &#123;<br>  ···<br>&#125;<br></code></pre></td></tr></table></figure></p><p>该类上面有一个@HandlesTypes注解，该注解会在web容器启动的时候，传入我们感兴趣的类型，这里会传入WebApplicationInitializer的类型。</p><p>然后在该类的onStartup()方法中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">if (webAppInitializerClasses != null) &#123;<br>for (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;<br>// Be defensive: Some servlet containers provide us with invalid classes,<br>// no matter what @HandlesTypes says...<br>if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;<br>WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123;<br>try &#123;<br>initializers.add((WebApplicationInitializer) waiClass.newInstance());<br>&#125;<br>catch (Throwable ex) &#123;<br>throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这里的webAppInitializerClasses就是传入的我们感兴趣的类型，判断该传入的类型，在不是接口，不是抽象类，而且是WebApplicationInitializer类型的时候，实例化该传入的类型。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">for (WebApplicationInitializer initializer : initializers) &#123;<br>initializer.onStartup(servletContext);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>最后调用WebApplicationInitializer的<br>onStartup(ServletContext servletContext) throws ServletException;</p><hr><p>我们可以直接实现WebApplicationInitializer接口，像Spring官网一样整合SpringMVC。</p><p>但是，这里，我们来看看WebApplicationInitializer的继承体系：<br>会发现有三个抽象类：<br>AbstractContextLoaderInitializer<br>AbstractDispatcherServletInitializer<br>AbstractAnnotationConfigDispatcherServletInitializer</p><p>AbstractContextLoaderInitializer：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public abstract class AbstractContextLoaderInitializer implements WebApplicationInitializer &#123;<br><br>/** Logger available to subclasses */<br>protected final Log logger = LogFactory.getLog(getClass());<br><br><br>@Override<br>public void onStartup(ServletContext servletContext) throws ServletException &#123;<br>registerContextLoaderListener(servletContext);<br>&#125;<br><br>protected void registerContextLoaderListener(ServletContext servletContext) &#123;<br>WebApplicationContext rootAppContext = createRootApplicationContext();<br>if (rootAppContext != null) &#123;<br>servletContext.addListener(new ContextLoaderListener(rootAppContext));<br>&#125;<br>else &#123;<br>logger.debug(&quot;No ContextLoaderListener registered, as &quot; +<br>&quot;createRootApplicationContext() did not return an application context&quot;);<br>&#125;<br>&#125;<br><br>protected abstract WebApplicationContext createRootApplicationContext();<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>这里，我们可以看到：首先执行onStartup(),然后执行registerContextLoaderListener().</p><p>在然后执行registerContextLoaderListener中，调用createRootApplicationContext()方法来获取Spring的根容器。该方法需要我们来实现。</p><p>然后将我们创建的根容器注入到ServletContext中。</p><hr><p>AbstractDispatcherServletInitializer：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public abstract class AbstractDispatcherServletInitializer extends AbstractContextLoaderInitializer &#123;<br>    public static final String DEFAULT_SERVLET_NAME = &quot;dispatcher&quot;;<br><br>    public AbstractDispatcherServletInitializer() &#123;<br>    &#125;<br><br>    public void onStartup(ServletContext servletContext) throws ServletException &#123;<br>        super.onStartup(servletContext);<br>        this.registerDispatcherServlet(servletContext);<br>    &#125;<br><br>    protected void registerDispatcherServlet(ServletContext servletContext) &#123;<br>        String servletName = this.getServletName();<br>        Assert.hasLength(servletName, &quot;getServletName() must not return empty or null&quot;);<br>        WebApplicationContext servletAppContext = this.createServletApplicationContext();<br>        Assert.notNull(servletAppContext, &quot;createServletApplicationContext() did not return an application context for servlet [&quot; + servletName + &quot;]&quot;);<br>        DispatcherServlet dispatcherServlet = new DispatcherServlet(servletAppContext);<br>        Dynamic registration = servletContext.addServlet(servletName, dispatcherServlet);<br>        Assert.notNull(registration, &quot;Failed to register servlet with name &apos;&quot; + servletName + &quot;&apos;.&quot; + &quot;Check if there is another servlet registered under the same name.&quot;);<br>        registration.setLoadOnStartup(1);<br>        registration.addMapping(this.getServletMappings());<br>        registration.setAsyncSupported(this.isAsyncSupported());<br>        Filter[] filters = this.getServletFilters();<br>        if (!ObjectUtils.isEmpty(filters)) &#123;<br>            Filter[] var7 = filters;<br>            int var8 = filters.length;<br><br>            for(int var9 = 0; var9 &lt; var8; ++var9) &#123;<br>                Filter filter = var7[var9];<br>                this.registerServletFilter(servletContext, filter);<br>            &#125;<br>        &#125;<br><br>        this.customizeRegistration(registration);<br>    &#125;<br></code></pre></td></tr></table></figure></p><p>第一，创建Spring的WebApplicationContext容器。</p><p><code>protected abstract WebApplicationContext createServletApplicationContext();</code></p><p>需要我们自己实现，这个方法，返回一个WebApplicationContext容器。</p><p>第二，帮我们创建了一个dispatcherServlet，然后注入到ServletContext中。</p><p>第三，registration.addMapping(this.getServletMappings());添加映射，Filter[] filters = this.getServletFilters();注入过滤器等。</p><p><code>protected abstract String[] getServletMappings();</code></p><p>映射器也需要我们重写。</p><hr><p>AbstractAnnotationConfigDispatcherServletInitializer:</p><p>注解版注册DispatcherServlet的版本</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public abstract class AbstractAnnotationConfigDispatcherServletInitializer extends AbstractDispatcherServletInitializer &#123;<br>    public AbstractAnnotationConfigDispatcherServletInitializer() &#123;<br>    &#125;<br><br>    protected WebApplicationContext createRootApplicationContext() &#123;<br>        Class&lt;?&gt;[] configClasses = this.getRootConfigClasses();<br>        if (!ObjectUtils.isEmpty(configClasses)) &#123;<br>            AnnotationConfigWebApplicationContext rootAppContext = new AnnotationConfigWebApplicationContext();<br>            rootAppContext.register(configClasses);<br>            return rootAppContext;<br>        &#125; else &#123;<br>            return null;<br>        &#125;<br>    &#125;<br><br>    protected WebApplicationContext createServletApplicationContext() &#123;<br>        AnnotationConfigWebApplicationContext servletAppContext = new AnnotationConfigWebApplicationContext();<br>        Class&lt;?&gt;[] configClasses = this.getServletConfigClasses();<br>        if (!ObjectUtils.isEmpty(configClasses)) &#123;<br>            servletAppContext.register(configClasses);<br>        &#125;<br><br>        return servletAppContext;<br>    &#125;<br><br>    protected abstract Class&lt;?&gt;[] getRootConfigClasses();<br><br>    protected abstract Class&lt;?&gt;[] getServletConfigClasses();<br>&#125;<br></code></pre></td></tr></table></figure><p>里面就重写了两个方法：</p><p>createRootApplicationContext():创建配置类的根容器<br>重写getRootConfigClasses():传入一个配置类。</p><p>createServletApplicationContext():创建Web的ioc容器<br>重写getServletConfigClasses():获取Web版的配置类。</p><hr><p>总结：</p><p>以注解方法来启动SpringMVC的话：继承AbstractAnnotationConfigDispatcherServletInitializer；</p><p>实现抽象方法指定DispatcherServlet的配置信息。</p><h3 id="Servlet3-0与SpringMVC的整合"><a href="#Servlet3-0与SpringMVC的整合" class="headerlink" title="Servlet3.0与SpringMVC的整合"></a>Servlet3.0与SpringMVC的整合</h3><p>1) 在src下的main下面的java里面写我们的源代码：</p><p>如果还不知道怎么配置，看我的<strong>idea创建maven-web</strong>的博客，最后有说明。</p><p>创建com.liuzhuo包，并在该包下面，创建MyWebAppInitializer类，继承AbstractAnnotationConfigDispatcherServletInitializer：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//Web容器启动的时候创建对象；调用方法来初始化容器以前的前端控制器<br>public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;<br><br>    //获取根容器的配置类；（Spring的配置文件）父容器。<br>    @Override<br>    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;<br>        return new Class[]&#123;RootConfig.class&#125;;<br>    &#125;<br><br>    //获取Web容器的配置类（SpringMVC配置文件）子容器<br>    @Override<br>    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;<br>        return new Class[]&#123;AppConfig.class&#125;;<br>    &#125;<br><br>    //获取DispatchServlet的映射信息<br>    // /:拦截所有请求（包括静态资源（XX.js,XX.png））,但是不包括*.jsp<br>    // /*:拦截所有请求；连*.jsp页面都拦截；jsp页面需要Tomcat的jsp引擎解析的。<br>    @Override<br>    protected String[] getServletMappings() &#123;<br>        return new String[]&#123;&quot;/&quot;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 在com.liuzhuo.config包下，创建RootConfig、AppConfig类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@ComponentScan(value = &quot;com.liuzhuo&quot;, excludeFilters = &#123;<br>        @ComponentScan.Filter(type = FilterType.ANNOTATION, value = &#123;Controller.class&#125;)<br>&#125;)<br>//Spring的根容器（父容器）,扫描排除含有Controller注解的bean对象<br>public class RootConfig &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = &#123;<br>        @ComponentScan.Filter(type = FilterType.ANNOTATION, value = &#123;Controller.class&#125;)<br>&#125;, useDefaultFilters = false)<br>//SpringMVC的子容器，只扫描含有Controller注解的Bean对象<br>//禁用默认的规则(扫描所有)：useDefaultFilters = false<br>public class AppConfig &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样配置，是根据Spring的官方给的建议：<br><img src="/images/QQ截图20181030134334.png" style="width:50%"></p><p>父容器:配置@service、@repository，数据连接池，事务管理等。<br>子容器：配置@Controller层，视图解析器，映射配置。</p><p>3）在com.liuzhuo.service包下，创建HelloService：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class HelloService &#123;<br><br>    public String sayHello(String name) &#123;<br>        return &quot;Hello:&quot; + name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 在com.liuzhuo.controller包下，创建HelloController：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Controller<br>public class HelloController &#123;<br><br>    @Autowired<br>    private HelloService helloService;<br><br>    @ResponseBody<br>    @RequestMapping(&quot;/hello&quot;)<br>    public String hello() &#123;<br>        String hello = helloService.sayHello(&quot;tomcat·····&quot;);<br>        return hello;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>整体的项目结构：<br><img src="/images/QQ截图20181030134808.png" style="width:50%"></p><p>5) 启动项目，运行</p><p>浏览器输入：<br><code>http://localhost:8080/hello</code><br><img src="/images/QQ截图20181030134940.png"></p><p>到现在为止，Servlet3.0与SpringMVC整合完成。</p><h3 id="定性配置SpringMVC"><a href="#定性配置SpringMVC" class="headerlink" title="定性配置SpringMVC"></a>定性配置SpringMVC</h3><p>打开官网，查看 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-config" target="_blank" rel="noopener">MVC Config</a>章节。</p><p>开启MVC的高级功能，需要@EnableWebMvc注解。</p><p>比如：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@EnableWebMvc<br>public class WebConfig &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>相等于xml文件：<code>&lt;mvc:annotation-driven/&gt;</code><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;<br>    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>    xsi:schemaLocation=&quot;<br>        http://www.springframework.org/schema/beans<br>        http://www.springframework.org/schema/beans/spring-beans.xsd<br>        http://www.springframework.org/schema/mvc<br>        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;<br><br>    <br><br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure></p><p>只有开启了@EnableWebMvc或者<code>&lt;mvc:annotation-driven/&gt;</code>才能定制SpringMVC的其他信息。</p><p>在官网中，我们使用配置实现 WebMvcConfigurer 接口，然后实现其中的所有方法来定制其他组件(视图解析器、拦截器、过滤器等)。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@EnableWebMvc<br>public class WebConfig implements WebMvcConfigurer &#123;<br><br>    // Implement configuration methods...<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，这样，我们就必须实现其中的所有方法了，为了方便，我们可以继承WebMvcConfigurerAdapter 适配器，其中所有的方法帮我们实现了，只是返回空方法。然后我们通过重写自己想要定制的方法来完成自身的需求。</p><h4 id="定制视图解析器"><a href="#定制视图解析器" class="headerlink" title="定制视图解析器"></a>定制视图解析器</h4><p>1）改写我们的AppConfig配置类：</p><p>添加@EnableWebMvc、并且继承WebMvcConfigurerAdapter抽象类<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = &#123;<br>        @ComponentScan.Filter(type = FilterType.ANNOTATION, value = &#123;Controller.class&#125;)<br>&#125;, useDefaultFilters = false)<br>//SpringMVC的子容器，只扫描含有Controller注解的Bean对象<br>//禁用默认的规则(扫描所有)：useDefaultFilters = false<br>@EnableWebMvc<br>public class AppConfig extends WebMvcConfigurerAdapter &#123;<br><br>    <br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>2）添加自定义的视图解析器</p><p>都是在AppConfig类中，直接重写方法</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置视图解析器<br>@Override<br>public void configureViewResolvers(ViewResolverRegistry registry) &#123;<br>    //定制jsp的视图解析器<br>    //参数一：视图的前缀路径<br>    //参数二：视图的后缀名<br>    registry.jsp(&quot;WEB-INF/views/&quot;, &quot;.jsp&quot;);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>3）在HelloController中<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RequestMapping(&quot;/suc&quot;)<br>public String sucess() &#123;<br>    return &quot;sucess&quot;;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 在WEB-INF/views下，添加一个sucess.jsp的文件<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;h1&gt;sucess!&lt;/h1&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></p><p>5) 运行项目</p><p>在浏览器中输入：<code>http://localhost:8080/suc</code><br><img src="/images/QQ截图20181030150751.png"></p><p>成功定制了jsp的视图解析器了。</p><hr><h4 id="定制静态资源"><a href="#定制静态资源" class="headerlink" title="定制静态资源"></a>定制静态资源</h4><p>没有配置之前：</p><p>1）在webapp根目录下：</p><p>放入一张图片，随便一张就行。<br><img src="/images/QQ截图20181030151708.png" style="width:50%"></p><p>2）在index.jsp中，添加img标签<br><img src="/images/QQ截图20181030151855.png" style="width:50%"></p><p>3) 启动项目</p><p>浏览器中输入：<code>http://localhost:8080</code><br><img src="/images/QQ截图20181030152023.png" style="width:50%"></p><p>发现，我们的照片出不来，这是为啥呢？这是因为，我们的静态资源也会被DispatchServlet拦截。</p><p>在控制台中能发现：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">30-Oct-2018 15:20:00.904 警告 [http-nio-8080-exec-4] org.springframework.web.servlet.PageNotFound.noHandlerFound No mapping found for HTTP request with URI [/gakki.jpg] in DispatcherServlet with name &apos;dispatcher&apos;<br></code></pre></td></tr></table></figure></p><p><img src="/images/QQ截图20181030152314.png"></p><p>发现 /gakki.jpg 也被DispatchServlet拦截了。</p><p>现在，我们需要不让DispatchServlet拦截我们的静态资源，使用Tomcat容器来加载静态资源。</p><p>4）在AppConfig下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//静态资源访问<br>@Override<br>public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;<br>    //默认是匹配路径：/**<br>    configurer.enable();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>相等于xml中的：<code>&lt;mvc:default-servlet-handler/&gt;</code></p><p>5) 启动项目<br><img src="/images/QQ截图20181030153052.png"></p><hr><h4 id="定制拦截器"><a href="#定制拦截器" class="headerlink" title="定制拦截器"></a>定制拦截器</h4><p>1）在com.liuzhuo.interceptors在，创建MyInterceptor，实现HandlerInterceptor接口<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//自定义的拦截器<br>public class MyInterceptor implements HandlerInterceptor &#123;<br><br>    //拦截之前调用<br>    @Override<br>    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123;<br>        //放行<br>        System.out.println(&quot;preHandle·······&quot;);<br>        return true;<br>    &#125;<br><br>    //处理之后调用<br>    @Override<br>    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;<br><br>        System.out.println(&quot;postHandle·······&quot;);<br>    &#125;<br><br>    //成功处理后调用<br>    @Override<br>    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;<br>        System.out.println(&quot;afterCompletion·······&quot;);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>2）在AppConfig类下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//添加拦截器<br>@Override<br>public void addInterceptors(InterceptorRegistry registry) &#123;<br><br>    registry.addInterceptor(new MyInterceptor()).addPathPatterns(&quot;/**&quot;);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 启动项目</p><p>在浏览器中输入：<code>http://localhost:8080/suc</code><br><img src="/images/QQ截图20181030155103.png"></p><p>拦截成功。</p><p>如果还想定制其他功能，请查看<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-config" target="_blank" rel="noopener">Spring的官方文档</a>。<br><img src="/images/QQ截图20181030155351.png"></p>]]></content>
      
      
      <categories>
          
          <category> servlet3.0 </category>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet3.0 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Servlet3.0</title>
      <link href="/2018/10/28/Servlet3-0/"/>
      <url>/2018/10/28/Servlet3-0/</url>
      
        <content type="html"><![CDATA[<p>以前，编写servlet，filter，Listener等，还是编写SpringMVC的前端控制器，都是在web.xml中编写的。Servlet3.0版本之后，只需要使用注解就可以完成组件的注解，还有运行时的组件式插拔开发。<br><a id="more"></a></p><p><strong>注意：</strong> servlet3.0的容器Tomcat 必须是<strong>7.0.x以上版本</strong>才能使用servlet3.0。</p><h3 id="创建dynamic-Web项目"><a href="#创建dynamic-Web项目" class="headerlink" title="创建dynamic Web项目"></a>创建dynamic Web项目</h3><p>我这里使用的是idea，大家也可以使用eclipse开发。大家估计都对eclipse开发熟悉，如果对idea创建动态web项目不熟悉的话，可以看我另一篇博客<a href="https://gakkil.top/2018/10/28/idea-%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81Web%E9%A1%B9%E7%9B%AE/" target="_blank" rel="noopener">idea 创建动态Web项目</a>。</p><p>创建好工程后如下：<br><img src="/images/QQ截图20181029114758.png" style="width:50%"></p><h4 id="使用web-xml的方式"><a href="#使用web-xml的方式" class="headerlink" title="使用web.xml的方式"></a>使用web.xml的方式</h4><p>1）在src下创建com.liuzhuo.servlet包，并创建HelloServlet<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class HelloServlet extends HttpServlet &#123;<br>    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;<br>        super.doPost(request, response);<br>    &#125;<br><br>    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;<br>        response.getWriter().write(&quot;hello world servlet3.0 ~~~&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 在WBE-INF下的index.jsp中：</p><p>添加：<code>&lt;a href=&quot;hello&quot;&gt;hello&lt;/a&gt;</code><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;servlet3.0&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;a href=&quot;hello&quot;&gt;hello&lt;/a&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></p><p>3) 在web.xml中配置servlet的映射关系<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;<br>         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;<br>         version=&quot;3.1&quot;&gt;<br><br>    &lt;servlet&gt;<br>        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;<br>        &lt;servlet-class&gt;com.liuzhuo.servlet.HelloServlet&lt;/servlet-class&gt;<br>    &lt;/servlet&gt;<br><br>    &lt;servlet-mapping&gt;<br>        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;<br>        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;<br>    &lt;/servlet-mapping&gt;<br>    <br>&lt;/web-app&gt;<br></code></pre></td></tr></table></figure></p><p>4) 运行web应用<br><img src="/images/QQ截图20181029124916.png"></p><p>点击hello的超链接<br><img src="/images/QQ截图20181029124951.png"></p><p>以上就是servlet3.0之前的版本开发web工程的演示。</p><hr><h4 id="不使用web-xml-servlet3-0"><a href="#不使用web-xml-servlet3-0" class="headerlink" title="不使用web.xml(servlet3.0)"></a>不使用web.xml(servlet3.0)</h4><p>1) 去掉web.xml中的servlet的配置：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;<br>         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;<br>         version=&quot;3.1&quot;&gt;<br><br>&lt;/web-app&gt;<br></code></pre></td></tr></table></figure></p><p>2) 此时再运行web项目，点击hello超链接<br><img src="/images/QQ截图20181029125311.png"></p><p>3）使用@WebServlet注解</p><p>在HelloServlet类上面写上@WebServlet注解<br>name : 就是servlet的名字<br>value：就是映射的路径</p><p>@WebServlet上的name  &lt;==&gt; <code>&lt;servlet-name&gt;hello&lt;/servlet-name&gt;</code><br>@WebServlet上的value &lt;==&gt; <code>&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</code></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@WebServlet(value =&quot;/hello&quot; )<br>public class HelloServlet extends HttpServlet &#123;<br>    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;<br>        super.doPost(request, response);<br>    &#125;<br><br>    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;<br>        response.getWriter().write(&quot;hello world servlet3.0 ~~~&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4) 重新启动web项目</p><p>会发现，项目启动正常了。</p><p><strong>ps：在idea中，有一个web的窗口，在编辑器的左下角，点开，会看见当前web项目的映射信息，很方便排错。</strong><br><img src="/images/QQ截图20181029130641.png" style="width:50%"></p><p>其他注解：</p><p>@WebFilter   ：注解过滤器<br>@WebListener ：注解监听器<br>@WebInitParam：注解初始化的参数</p><p>具体的使用情况：看官方文档即可。</p><hr><h3 id="servlet3-0的共享库和运行时插件"><a href="#servlet3-0的共享库和运行时插件" class="headerlink" title="servlet3.0的共享库和运行时插件"></a>servlet3.0的共享库和运行时插件</h3><p>Shared libraries / runtimes pluggability</p><p>1）在Servlet容器启动的时候，会扫描当前应用里面的每一个jar包的ServletContainerInitializer的实现类</p><p>2）提供ServletContainerInitializer的实现类</p><p>必须绑定在：META-INF/services/javax.servlet.ServletContainerInitializer文件中。<br><strong>文件名就是 javax.servlet.ServletContainerInitializer 没有后缀。</strong></p><p>文件中的内容就是：ServletContainerInitializer实现类的<strong>全类名</strong>。</p><p>总结：容器在启动的时候，会扫描当前应用中每一个jar包里面的：META-INF/services/javax.servlet.ServletContainerInitializer文件中ServletContainerInitializer实现类，启动并运行这个实现类中的方法和传入感兴趣的类型。</p><p>3）测试</p><p>3.1) 这里就不创建jar包了，直接在src下创建META-INF/services目录，然后在该目录下，创建javax.servlet.ServletContainerInitializer文件。<br><img src="/images/QQ截图20181029135845.png" style="width:50%"></p><p><strong>注意：目录和文件名称不要打错！！！</strong></p><p>3.2）在src下的com.liuzhuo.servlet下创建MyServletContainerInitializer，并实现ServletContainerInitializer接口。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@HandlesTypes(value = &#123;HelloService.class&#125;)<br>public class MyServletContainerInitializer implements ServletContainerInitializer &#123;<br><br>    /**<br>     * @param set：感兴趣的类型的所有子类型.@HandlesTypes注解中的value即为感兴趣的类型。<br>     * @param servletContext :代表当前Web应用的ServletContext,一个Web应用一个上下文<br>     * @throws ServletException<br>     */<br>    @Override<br>    public void onStartup(Set&lt;Class&lt;?&gt;&gt; set, ServletContext servletContext) throws ServletException &#123;<br>        System.out.println(&quot;感兴趣的类型：&quot;);<br>        for (Class&lt;?&gt; aClass : set) &#123;<br>            System.out.println(aClass);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3.3) 在src下的com.liuzhuo.service下创建<br>HelloService：接口<br>HelloServiceExt：实现了HelloService的子接口<br>AbstractHelloService：实现了HelloService的抽象类<br>HelloServiceImpl：HelloService的实现类<br><img src="/images/QQ截图20181029140510.png" style="width:50%"></p><p>3.4）将MyServletContainerInitializer的全类名添加到javax.servlet.ServletContainerInitializer文件中<br><img src="/images/QQ截图20181029140722.png"></p><p>3.5）运行web项目<br><img src="/images/QQ截图20181029140828.png"></p><p>能看到，输出感兴趣的类型：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class com.liuzhuo.service.HelloServiceImpl<br>interface com.liuzhuo.service.HelloServiceExt<br>class com.liuzhuo.service.AbstractHelloService<br></code></pre></td></tr></table></figure></p><p><strong>注意感兴趣的类型：不包括本身（HelloService接口）！！！</strong></p><hr><h3 id="使用ServletContainerInitializer给容器添加组件"><a href="#使用ServletContainerInitializer给容器添加组件" class="headerlink" title="使用ServletContainerInitializer给容器添加组件"></a>使用ServletContainerInitializer给容器添加组件</h3><p>根据上文，我们已经了解到了，我们使用@WebServlet注解，给容器添加我们自己写的Servlet类，但是无法添加第三方的组件。只能使用Web.xml文件来添加。</p><p>现在，我们了解了Servlet3.0的共享库和运行时机制，可以使用ServletContainerInitializer的机制来注册Web组件(Servlet、Filter、Listener)，不必使用Web.xml配置文件。</p><p>接着现有的项目继续开发。</p><p>1）在com.liuzhuo.servlet下创建UserServlet、UserFilter、UserListener三大组件<br><img src="/images/QQ截图20181029143900.png" style="width:50%"></p><p>UserServlet:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class UserServlet extends HttpServlet &#123;<br><br>    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;<br>        response.getWriter().write(&quot;UserServlet ·····&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>UserFilter:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class UserFilter implements Filter &#123;<br>    public void destroy() &#123;<br>    &#125;<br><br>    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;<br>        //执行过滤的方法<br>        System.out.println(&quot;UserFilter ~~~&quot;);<br>        //放行<br>        chain.doFilter(req, resp);<br>    &#125;<br><br>    public void init(FilterConfig config) throws ServletException &#123;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>UserListener:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class UserListener implements ServletContextListener &#123;<br><br>    //容器初始化的时候<br>    @Override<br>    public void contextInitialized(ServletContextEvent servletContextEvent) &#123;<br>        //获取ServletContext容器的上下文，这里也可以注册Servlet、Fliter、Listener组件<br>        ServletContext servletContext = servletContextEvent.getServletContext();<br>        System.out.println(servletContext);<br>        System.out.println(&quot;UserListener监听ServletContextListener的初始化&quot;);<br>    &#125;<br><br>    //容器销毁的时候<br>    @Override<br>    public void contextDestroyed(ServletContextEvent servletContextEvent) &#123;<br>        System.out.println(&quot;UserListener监听ServletContextListener的销毁&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 在MyServletContainerInitializer中的onStartup方法中使用ServletContext注册三大组件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@HandlesTypes(value = &#123;HelloService.class&#125;)<br>public class MyServletContainerInitializer implements ServletContainerInitializer &#123;<br><br>    /**<br>     * @param set：感兴趣的类型的所有子类型.@HandlesTypes注解中的value即为感兴趣的类型。<br>     * @param servletContext :代表当前Web应用的ServletContext：一个Web应用一个上下文<br>     * @throws ServletException<br>     */<br>    @Override<br>    public void onStartup(Set&lt;Class&lt;?&gt;&gt; set, ServletContext servletContext) throws ServletException &#123;<br>        System.out.println(&quot;感兴趣的类型：&quot;);<br>        for (Class&lt;?&gt; aClass : set) &#123;<br>            System.out.println(aClass);<br>        &#125;<br><br>        //添加userServelt组件。<br>        ServletRegistration.Dynamic userServelt = servletContext.addServlet(&quot;userServelt&quot;, new UserServlet());<br>        //添加Servlet的映射路径<br>        userServelt.addMapping(&quot;/user&quot;);<br><br>        //添加监听器<br>        servletContext.addListener(UserListener.class);<br><br>        //添加过滤器<br>        FilterRegistration.Dynamic userFilter = servletContext.addFilter(&quot;userFilter&quot;, UserFilter.class);<br>        //添加拦截规则<br>        //EnumSet&lt;DispatcherType&gt; var1 :拦截的请求类型<br>        // boolean var2                ：true<br>        // String... var3              ：拦截的路径<br>        userFilter.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), true, &quot;/*&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 运行Web项目<br><img src="/images/QQ截图20181029150012.png"></p><p>说明userListener监听器注册成功。</p><p>在浏览器中输入：<code>http://localhost:8080/user</code><br><img src="/images/QQ截图20181029150247.png"><br><img src="/images/QQ截图20181029150400.png"></p><p>说明UserServlet和userFliter注册也成功了。</p><p>停止Web项目：<br><img src="/images/QQ截图20181029150554.png"></p><p>以上，就是不使用Web.xml的注册Servlet、Filter、Listener三大组件的过程，使用硬编码的形式。</p><p><strong>注意：servlet3.0动态注册，只能在webapp启动时进行注册,可能是为了安全考虑吧.不能在运行时完成对servlet的注册和销毁</strong></p><p>在初始化情况下的注册Servlet组件有除了上面的方式，还有另外一种方式：<br>就是在实现ServletContextListener接口,在contextInitialized方法中完成注册.</p><p>就是在上述UserListener中contextInitialized方法中获取：<br> ServletContext servletContext = servletContextEvent.getServletContext();<br>然后进行三大组件的注册。</p>]]></content>
      
      
      <categories>
          
          <category> servlet3.0 </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet3.0 </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>idea 创建动态Web项目</title>
      <link href="/2018/10/28/idea-%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81Web%E9%A1%B9%E7%9B%AE/"/>
      <url>/2018/10/28/idea-%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81Web%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>intellij idea这个开发工具功能强大，但是大部分人都习惯eclipse 开发，所以对这个工具还不是太了解。今天就使用idea来创建动态web项目。</p><a id="more"></a><h3 id="idea-创建动态Web项目"><a href="#idea-创建动态Web项目" class="headerlink" title="idea 创建动态Web项目"></a>idea 创建动态Web项目</h3><p>打开idea</p><p>我使用的是2017版本的。</p><p>(1)点击左上角的File–&gt; new –&gt; Project<br><img src="/images/QQ截图20181028182054.png"></p><p>(2)之后会弹出一个选择框，选择Java Enterprise ，网上有的会说选择第一个java 当然也是可行的 ，两者之间有一点点细微的差别啦，当然别忘记<strong>勾选Web Application</strong>,点击Next。<br><img src="/images/QQ截图20181028191302.png"></p><p>(3)填好项目名称，和项目路径，Finish。<br><img src="/images/QQ截图20181028191740.png"></p><p>(4)完成后，需要添加web.xml文件。在idea201703版本之前。在第二步的选择Web Application时，可以选择版本号，并创建web.xml文件。但是之后的版本没有。我们可以手工创建，但是麻烦，教大家另外的创建方法。</p><p>打开 Project Structure（Ctrl+Alt+Shift+S），在 facets 里<strong>选中次级的 web 或者 在Modules 中选中web</strong>，在deployment Descriptors面板里，点击 +号选择web.xml以及版本号。然后在弹出的对话框中修改xml默认的目录，加上web就可以了。<br><img src="/images/QQ截图20181028194446.png" style="width:50%"><br><img src="/images/QQ截图20181028194836.png"><br><img src="/images/QQ截图20181028195525.png" style="width:50%"></p><p>这样就把 WEB-INF web.xml 添加上了 。<br><img src="/images/QQ截图20181028195719.png" style="width:50%"></p><p>.idea文件夹和webapp.iml是IDEA自动创建的，包含了工程和模块的配置数据<br>src文件夹是源码目录<br>web文件夹相当于eclipse创建的web工程WebContent文件夹，包含了WEB-INF/web.xml及index.jsp<br>External Libraries包含了JDK及Tomcat带的jsp-api、servlet-api jar文件</p><p>(4)完善工程目录，点击WEF-INF  ,右键，NEW–&gt;Directory  创建两个文件夹，classes 和 lib  <strong>这个名字不要改哦！</strong></p><p>4.1 创建classes文件夹<br><img src="/images/QQ截图20181028200211.png"><br><img src="/images/QQ截图20181028200344.png" style="width:50%"></p><p>4.2 同理，创建lib文件夹<br><img src="/images/QQ截图20181028200618.png" style="width:50%"></p><p>(5) 完成后再点击File ,选择Project Structure  </p><p>点击Modules ,选择Paths,选中Use module compile output path ,将Outputpath 和Test output path 都设置为刚刚创建的classes文件夹。<br><img src="/images/QQ截图20181028201015.png"></p><p><strong>点击apply就行，接着第六步。</strong></p><p>(6) 点击path旁边的Dependencies, 点击”+”号，选择1 JARs or directories<br><img src="/images/QQ截图20181028201526.png"></p><p>选择刚刚创建的lib。<br><img src="/images/QQ截图20181028201634.png"></p><p>选择第三个，jar Directory。一路ok到底！<br><img src="/images/QQ截图20181028201803.png" style="width:50%"></p><p>(7) 配置servlet容器：Tomcat<br>点击右上角的tomcat的向下的小三角，然后点击Edit Configurations<br><img src="/images/QQ截图20181028202512.png" style="width:30%"></p><p>看tomcat已经有啦，这是java Enterprise的好处啦，点击Deployment。<br><img src="/images/QQ截图20181028203004.png"><br>1，设置On frame deactivation : Update classes and resources<br>2，设置自己的jre位置路径。（jdk对应的jre）</p><p>Application context可以填也可以不填，配置后，访问网站就必须加上这个路径了。<br><img src="/images/QQ截图20181028203156.png"><br>点击ok。</p><p>(8) 点击index.jsp，随便写一段话，比如helloworld。<br><img src="/images/QQ截图20181028203422.png"></p><p>(9) 运行程序，就点击右上角的绿色图标<br><img src="/images/QQ截图20181028203713.png"></p><h3 id="WEB-INF目录与META-INF目录的作用"><a href="#WEB-INF目录与META-INF目录的作用" class="headerlink" title="WEB-INF目录与META-INF目录的作用"></a>WEB-INF目录与META-INF目录的作用</h3><p>1) /WEB-INF/web.xml</p><p>Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。</p><p>2) /WEB-INF/classes/</p><p>包含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中。</p><p>3) /WEB-INF/lib/</p><p>存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件。</p><p>4) /WEB-INF/src/</p><p>源码目录，按照包名结构放置各个Java文件。</p><p>5) /WEB-INF/database.properties</p><p>数据库配置文件</p><p>6) /WEB-INF/tags/</p><p>存放了自定义标签文件，该目录并不一定为 tags，可以根据自己的喜好和习惯为自己的标签文件库命名，当使用自定义的标签文件库名称时，在使用标签文件时就必须声明正确的标签文件库路径。例如：当自定义标签文件库名称为 simpleTags 时，在使用 simpleTags 目录下的标签文件时，就必须在 jsp 文件头声明为：&lt;%@ taglibprefix=”tags” tagdir=”/WEB-INF /simpleTags” % &gt;。</p><p>7) /WEB-INF/jsp/</p><p>jsp 1.2 以下版本的文件存放位置。改目录没有特定的声明，同样，可以根据自己的喜好与习惯来命名。此目录主要存放的是 jsp 1.2 以下版本的文件，为区分 jsp 2.0 文件，通常使用 jsp 命名，当然你也可以命名为 jspOldEdition 。</p><p>8) /WEB-INF/jsp2/</p><p>与 jsp 文件目录相比，该目录下主要存放 Jsp 2.0 以下版本的文件，当然，它也是可以任意命名的，同样为区别 Jsp 1.2以下版本的文件目录，通常才命名为 jsp2。</p><p>9) META-INF</p><p>相当于一个信息包，目录中的文件和目录获得Java 2平台的认可与解释，用来配置应用程序、扩展程序、类加载器和服务manifest.mf文件，在用jar打包时自动生成。</p><h3 id="META-INF有什么用？它跟WEB-INF有什么区别？"><a href="#META-INF有什么用？它跟WEB-INF有什么区别？" class="headerlink" title="META-INF有什么用？它跟WEB-INF有什么区别？"></a>META-INF有什么用？它跟WEB-INF有什么区别？</h3><p>WEB-INF使用web 项目才会有这个文件夹,普通的j2se项目是没有这个文件夹的。</p><p>META-INF存在程序入口相关信息, 每个jar 都会有这个文件夹,里面的 MANIFEST文件 记录下面这些信息。我们把MANIFEST中的配置信息进行分类，可以归纳出下面几个大类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs undefined">一. 一般属性　　<br>1. Manifest-Version　　用来定义manifest文件的版本，例如：Manifest-Version: 1.0　　<br>2. Created-By　　声明该文件的生成者，一般该属性是由jar命令行工具生成的，例如：Created-By: Apache Ant 1.5.1　　<br>3. Signature-Version　　定义jar文件的签名版本　　<br>4. Class-Path　　应用程序或者类装载器使用该值来构建内部的类搜索路径　　<br>二. 应用程序相关属性　　<br>1. Main-Class　　定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过 java -jar x.jar来运行该jar文件。　　<br>三. 小程序(Applet)相关属性　　<br>1. Extendsion-List　　该属性指定了小程序需要的扩展信息列表，列表中的每个名字对应以下的属性　　<br>2. &lt;extension&gt;-Extension-Name　　<br>3. &lt;extension&gt;-Specification-Version　　<br>4. &lt;extension&gt;-Implementation-Version　　<br>5. &lt;extension&gt;-Implementation-Vendor-Id　　<br>6. &lt;extension&gt;-Implementation-URL　　<br>四. 扩展标识属性　　<br>1. Extension-Name　　该属性定义了jar文件的标识，例如Extension-Name: Struts Framework　　<br>五. 包扩展属性　　<br>1. Implementation-Title 定义了扩展实现的标题　　<br>2. Implementation-Version 定义扩展实现的版本　　<br>3. Implementation-Vendor 定义扩展实现的组织 　　<br>4. Implementation-Vendor-Id 定义扩展实现的组织的标识　　<br>5. Implementation-URL : 定义该扩展包的下载地址(URL)　　<br>6. Specification-Title 定义扩展规范的标题　　<br>7. Specification-Version 定义扩展规范的版本　　<br>8. Specification-Vendor 声明了维护该规范的组织　　<br>9. Sealed 定义jar文件是否封存，值可以是true或者false (这点我还不是很理解)　　<br>六. 签名相关属性　　<br>签名方面的属性我们可以来参照JavaMail所提供的mail.jar中的一段　　<br>Name: javax/mail/Address.class　　<br>Digest-Algorithms: SHA MD5 　　<br>SHA-Digest: AjR7RqnN//cdYGouxbd06mSVfI4=　　<br>MD5-Digest: ZnTIQ2aQAtSNIOWXI1pQpw==　　<br>这段内容定义类签名的类名、计算摘要的算法名以及对应的摘要内容(使用BASE64方法进行编码)<br></code></pre></td></tr></table></figure></p><h3 id="为什么需要把页面放在WEB-INF文件夹下面？"><a href="#为什么需要把页面放在WEB-INF文件夹下面？" class="headerlink" title="为什么需要把页面放在WEB-INF文件夹下面？"></a>为什么需要把页面放在WEB-INF文件夹下面？</h3><ol><li>基于不同的功能 JSP 被放置在不同的目录下</li></ol><p>这种方法的问题是这些页面文件容易被偷看到源代码，或被直接调用。某些场合下这可能不是个大问题，可是在特定情形中却可能构成安全隐患。用户可以绕过Struts的controller直接调用JSP同样也是个问题。</p><p>为了减少风险，可以把这些页面文件移到WEB-INF 目录下。基于Servlet的声明，WEB-INF不作为Web应用的公共文档树的一部分。因此，WEB-INF 目录下的资源不是为客户直接服务的。我们仍然可以使用WEB-INF目录下的JSP页面来提供视图给客户，客户却不能直接请求访问JSP。</p><ol start="2"><li>JSP存放在 WEB-INF 目录下更为安全</li></ol><p>如果把这些JSP页面文件移到WEB-INF 目录下，在调用页面的时候就必须把”WEB-INF”添加到URL中。</p><p>我们知道，实现页面的跳转有两种方式，一种是通过redirect的方式，一种是通过forward的方式。redirect方式的跳转，系统会在一个新的页面打开要跳转的网页；而forward方式跳转，系统会在原来的页面上打开一个要跳转的网页。所以放到WEB-INF目录下的文件是不允许采用redirect方式的跳转来访问的.</p><p>WEB-INF文件夹是受保护的文件夹，外部无法访问这个文件夹内的文件，只有服务器内部才能访问。</p><p>重要的服务器初始化核心文件web.xml就这在个文件夹内。</p><p>为了达到服务器端访问的目的，我们可以使用action进行转向，我们先去请求一个action，然后由这个action转发到WEB-INF下的页面，这样客户端就可以访问</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git初级入门</title>
      <link href="/2018/10/25/Git%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8/"/>
      <url>/2018/10/25/Git%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>git的初级用法</strong></p><a id="more"></a><h3 id="Git的下载"><a href="#Git的下载" class="headerlink" title="Git的下载"></a>Git的下载</h3><p>git的官网：<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><p>点击右下角的：Downloade xxxx for Windows</p><p>由于是国外的网站，下载速度或许会很慢，请耐心等待~~</p><p>下载完后，直接安装就行。</p><p>安装完成，在桌面会创建Git Bash快捷方式。</p><p><strong>在任意目录下右击鼠标：会看到Git GUI Here 和 Git Bash Here 两个命令</strong></p><h3 id="Git的初步设置"><a href="#Git的初步设置" class="headerlink" title="Git的初步设置"></a>Git的初步设置</h3><ol><li>首先复制git的安装路径，追加到高级环境变量的PATH之后。确定保存退出。</li><li><p>打开cmd命令窗口（可用win+r,输入cmd确定即可）,输入git –vision命令（version前是两杠),显示版本号：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">C:\Users\liuzhuo&gt;git --version<br>git version 2.15.0.windows.1<br><br>C:\Users\liuzhuo&gt;<br></code></pre></td></tr></table></figure></li><li><p>进入Git界面，就是在任意目录下，右键，点击Git Bash Here<br><img src="/images/20181025091705.png"></p></li><li><p>配置全局的用户名和密码：</p></li></ol><p>git config –global user.name 你的用户名 #用户名<br>git config –global user.email 你的邮箱 #邮箱 </p><p>这里加了 –global的选项，说明是全局配置，意思是在当前windows下，使用的git都是在这个用户下，也可以给一个项目配置单独的用户名和密码。</p><ol start="5"><li>查看配置信息</li></ol><p>使用 git config –list<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 ~/Desktop<br>$ git config --list<br>core.symlinks=false<br>core.autocrlf=true<br>core.fscache=true<br>color.diff=auto<br>color.status=auto<br>color.branch=auto<br>color.interactive=true<br>help.format=html<br>rebase.autosquash=true<br>http.sslcainfo=D:/Git/mingw64/ssl/certs/ca-bundle.crt<br>http.sslbackend=openssl<br>diff.astextplain.textconv=astextplain<br>filter.lfs.clean=git-lfs clean -- %f<br>filter.lfs.smudge=git-lfs smudge -- %f<br>filter.lfs.process=git-lfs filter-process<br>filter.lfs.required=true<br>credential.helper=manager<br>user.name=liuzhuo<br>user.email=575920824@qq.com<br></code></pre></td></tr></table></figure></p><p>使用git config –global –list:查看全局配置信息<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 ~/Desktop<br>$ git config --global --list<br>user.name=liuzhuo<br>user.email=575920824@qq.com<br></code></pre></td></tr></table></figure></p><ol start="6"><li><p>常用的配置命令</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//查<br>git config --global --list<br> <br>git config --global user.name<br> <br>//增<br>git config  --global --add user.name jianan<br> <br>//删<br>git config  --global --unset user.name<br> <br>//改<br>git config --global user.name zhangsan<br></code></pre></td></tr></table></figure></li><li><p>全局配置文件的地方</p></li></ol><p><code>~/.gitconfig</code></p><p>例如Windows下，则是</p><p><code>C:\Users\用户名\.gitconfig</code></p><ol start="8"><li>各个仓库的配置</li></ol><p><code>.git/config</code></p><p>例如orange仓库目录下</p><p><code>/home/lanyang/orange/.git/config</code></p><h3 id="Git的GUI界面"><a href="#Git的GUI界面" class="headerlink" title="Git的GUI界面"></a>Git的GUI界面</h3><p>这里，我们使用SourceTree</p><p>官网：<a href="https://www.sourcetreeapp.com" target="_blank" rel="noopener">https://www.sourcetreeapp.com</a></p><p>点击：Downloade for Windows</p><h3 id="Git-仓库"><a href="#Git-仓库" class="headerlink" title="Git 仓库"></a>Git 仓库</h3><p>1) 初始化版本库</p><p>git init</p><p>2) 添加文件到版本库</p><p>git add</p><p>git commit</p><p>3) 查看仓库状态</p><p>git status</p><hr><p>首先，使用SourceTree来创建本地仓库：</p><p>1）打开SourceTree<br><img src="/images/20181025103910.png"></p><p>左上角：</p><p>Local： 代表本地仓库</p><p>Remote：代表远程仓库</p><p>右边：</p><p>Clone：代表克隆其他人的仓库</p><p>Add： 在原有仓库的基础上添加新的仓库</p><p>Create：创建新的仓库</p><p>2）点击Local和Create来创建本地仓库<br><img src="/images/20181025104307.png"></p><p>第一行：仓库的路径</p><p>第二行：仓库的名字<br><img src="/images/20181025104441.png"></p><p>这里：选择了E盘下的gitdemo\demo1目录。</p><p>点击创建</p><p>3）在demo1目录下，创建一个新的文件(.txt)，并随便写入几句话。</p><p>demo test······</p><p>4）观察SourceTree界面：<br><img src="/images/20181025104851.png"></p><p>此时，在未暂存区域出现了我们刚刚创建的文件。</p><p>说明，刚刚创建的文件现在只是在我们的工作目录下，还没有提交到本地仓库中。</p><p><strong>ps：此时，有三个区域，第一个是我们的工作目录，第二个是暂存区域，第三个是本地仓库区域</strong></p><p>我们一般在自己的工作目录下，编写自己的代码，然后提加到暂存区域，最后没有问题后，再提交到本地仓库保存起来。</p><p>5）点击text.txt，然后点击暂存所选<br><img src="/images/20181025105356.png"></p><p>此时，我们的文件就保存到暂存区域了。</p><p>6）提交到本地仓库中</p><p>在最下面，填写我们的提交信息，然后点击提交。<br><img src="/images/20181025105612.png"></p><p>7) 提交成功后，查看仓库的状态</p><p>第一次添加都是在主分支下面的，即master分支。</p><p>点击master分支<br><img src="/images/20181025105822.png"></p><p>我们，就看到了，自己刚刚提交到本地仓库中的记录了。</p><hr><p>现在，使用命令行界面来操作：</p><p>在一个目录下，右键，点击Git Bush：</p><p>我选择的是：E:\gitdemo<br><img src="/images/20181025110804.png"></p><p>1) git init demo2<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo<br>$ git init demo2<br>Initialized empty Git repository in E:/gitdemo/demo2/.git/<br></code></pre></td></tr></table></figure></p><p>2) 进入仓库的目录<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo<br>$ cd demo2<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$<br></code></pre></td></tr></table></figure></p><p><strong>ps:上面的右边的括号(master)，代表现在是主分支。</strong></p><p>3) 创建新的文件</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ echo &quot;demo2 text~~~~&quot; &gt;&gt; text2.txt<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$<br></code></pre></td></tr></table></figure><p>此时，在demo2工作目录下，就会出现一个新的文件，text2.txt文件。</p><p>4）查看状态</p><p>git status<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br><br>No commits yet<br><br>Untracked files:<br>  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)<br><br>        text2.txt<br><br>nothing added to commit but untracked files present (use &quot;git add&quot; to track)<br></code></pre></td></tr></table></figure></p><p>说明，当前是在主分支下，新建的text2.txt文件还没有提交。</p><p>5）先添加到暂存区</p><p>git add text2.txt</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git add text2.txt<br>warning: LF will be replaced by CRLF in text2.txt.<br>The file will have its original line endings in your working directory.<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br><br>No commits yet<br><br>Changes to be committed:<br>  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)<br><br>        new file:   text2.txt<br></code></pre></td></tr></table></figure><p>此时，文件已经加入到暂存区域了，最后，需要提交到本地仓库中</p><p>6）提交到本地仓库</p><p>git commit -m “repo2 first commit”<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git commit -m &quot;repo2 first commit&quot;<br>[master (root-commit) 8f22147] repo2 first commit<br> 1 file changed, 1 insertion(+)<br> create mode 100644 text2.txt<br></code></pre></td></tr></table></figure></p><p>7) 查看本地仓库的状态</p><p>git status<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure></p><hr><h3 id="Git-工作流"><a href="#Git-工作流" class="headerlink" title="Git 工作流"></a>Git 工作流</h3><p>现在，模拟一下，你上班的情况。第一天上班，创建自己的本地仓库，提交自己的完成的代码需求。</p><h4 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a>SourceTree</h4><p>1）新建一个本地仓库</p><p>这里，我选择的是 E:\gitdemo\demo3，大家可以根据自己的喜好自由创建。<br><img src="/images/20181025113245.png"></p><p>2) 添加新的文件</p><p>点击中间的：在文件管理器中打开</p><p>然后，创建demo3.txt文件，并输入：第一天的需要，已经完成</p><p>再回到SourceTree中：</p><p><img src="/images/20181025113527.png"></p><p>3）add + commit<br><img src="/images/20181025114112.png"></p><p>4) 提交成功<br><img src="/images/20181025114212.png"></p><hr><p>现在，快到下班了，产品经理提了一个临时的需求，所以，我们快马加鞭的写完，但是还没有自测，就只将先写的代码，保存到暂存区域中，不提交到本地仓库中。</p><p>1）打开，demo3.txt 文件，先加入一句话：临时需求已做完！<br><img src="/images/20181025114518.png"></p><p>2) 在SourceTree中，将先修改的demo3文件，保存到暂存区域中：</p><p><img src="/images/20181025114641.png"></p><p><img src="/images/20181025114717.png"></p><p>此时，拿起我们的背包，下班回家。</p><p>第二天，上班，那个该死的产品经理，说昨天的临时需求不要了，内心一万个曹尼玛~~~</p><p>所以，我们需要将暂存区域的代码和工作区域的代码，回滚到上一个阶段。</p><p>3）点击demo3.text，右键：丢弃<br><img src="/images/20181025115021.png"></p><p>4) 点击确定丢弃<br><img src="/images/20181025115425.png"></p><p>5) 点击demo3.txt文件<br><img src="/images/QQ截图20181025115532.png"></p><p><strong>发现，demo3.txt文件中，回滚到了上一次提交的状态。</strong></p><p><strong>删除了：临时需求已做完</strong></p><hr><p>第二天，继续codeing，编写产品经理提出的新需求。</p><p>1）打开demo3.txt文件</p><p>添加：第二天的需要已经完成！<br><img src="/images/QQ截图20181025115902.png"></p><p>2) add + commit<br><img src="/images/QQ截图20181025120045.png"></p><p><img src="/images/QQ截图20181025120147.png"></p><p>能看到，有两次的提交记录。</p><p>3）突然，产品经理说，这个需要不要了。内心无话可说</p><p>所以，我们需要回滚到上一次提交的状态。</p><p>点击 first commit ，<strong>右键：重置当前分支到此次提交</strong></p><p><img src="/images/QQ截图20181025124253.png"></p><p>要回到哪个状态，就点击哪个状态，然后右键重置当前分支到此次提交：</p><p><img src="/images/QQ截图20181025124921.png"></p><p>点击确定。</p><p>4）现在在工作区域下，能看到，上次修改后的没有提交的代码。<br><img src="/images/QQ截图20181025125125.png"></p><p>5) 丢弃修改的demo3.txt<br><img src="/images/QQ截图20181025125317.png"></p><p>6）打开demo3.txt文件：<br><img src="/images/QQ截图20181025125416.png"></p><p>回滚到第一次提交成功的状态了。</p><hr><p>现在，产品经理，说第一次提交的需求，也不需要了，需要删除这个文件。</p><p>1）直接在工作目录下，直接删除demo3.txt文件<br><img src="/images/QQ截图20181025125817.png"></p><p>2）add + commit<br><img src="/images/QQ截图20181025125922.png"></p><p><img src="/images/QQ截图20181025125959.png"></p><p>3) 此时，工作目录，暂存区域，本地仓库都删除了demo3.txt文件了。</p><hr><h4 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h4><p>现在使用命令行来操作：</p><p>1）打开命令行<br><img src="/images/QQ截图20181025130301.png"></p><p>2）在demo2下，创建bash_demo.txt文件</p><p>在文件中，输入：bash_demo 第一次提交成功.<br><img src="/images/QQ截图20181025130624.png"></p><p>3) 在命令行查看状态</p><p> git status<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>Untracked files:<br>  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)<br><br>        bash_demo.txt<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br></code></pre></td></tr></table></figure></p><p>4) 报存到暂存区：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git add bash_demo.txt<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>        new file:   bash_demo.txt<br></code></pre></td></tr></table></figure></p><p>5) 提交到本地仓库中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git commit -m &quot;bash_demo first commit&quot;<br>[master 136ecd0] bash_demo first commit<br> 1 file changed, 1 insertion(+)<br> create mode 100644 bash_demo.txt<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure></p><hr><p>6) 产品经理提出了临时的需要</p><p>打开bash_demo.txt文件，添加：产品经理临时变更需要。<br><img src="/images/QQ截图20181025131337.png"></p><p>7) 查看 + add到暂存区域中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>        modified:   bash_demo.txt<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br><br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git add bash_demo.txt<br></code></pre></td></tr></table></figure></p><p>下班走人。</p><p>8）产品经理说，临时需要不要了</p><p>使用 git reset head xxx.txt （重置）<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git reset head bash_demo.txt<br>Unstaged changes after reset:<br>M       bash_demo.txt<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>        modified:   bash_demo.txt<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br></code></pre></td></tr></table></figure></p><p>此时，只是将本地仓库的文件替换了暂存区域中的bash_demo文件。我们工作区域的文件还没有替换。</p><p>需要使用：git checkout – bash_demo.txt<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git checkout -- bash_demo.txt<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br></code></pre></td></tr></table></figure></p><p>打开bash_demo.txt文件。发现：产品经理临时变更需要。删除了</p><p>9）第二天继续开发</p><p>修改bash_demo.txt 文件。</p><p>添加：第二天的需要已经完成<br><img src="/images/QQ截图20181025132555.png"></p><p>10) 将修改后的文件，add + commit<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git add bash_demo.txt<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>        modified:   bash_demo.txt<br><br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git commit -m &quot;second commit&quot;<br>[master b8412ec] second commit<br> 1 file changed, 3 insertions(+), 1 deletion(-)<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure></p><p>不幸的是，产品经理说，第二天的需要不需要了。</p><p>11）查看提交日志</p><p>git log</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git log<br>commit b8412ec81784d6be4a5097fca881a811fe1b1a58 (HEAD -&gt; master)<br>Author: liuzhuo &lt;575920824@qq.com&gt;<br>Date:   Thu Oct 25 13:27:36 2018 +0800<br><br>    second commit<br><br><br>commit 136ecd07ab2b0742dff45dcdcfbde1d51da2df42<br>Author: liuzhuo &lt;575920824@qq.com&gt;<br>Date:   Thu Oct 25 13:10:32 2018 +0800<br><br>    bash_demo first commit<br></code></pre></td></tr></table></figure><p>找到：bash_demo第一次提交的序列号：</p><p>commit 136ecd07ab2b0742dff45dcdcfbde1d51da2df42<br>Author: liuzhuo <a href="mailto:&#x35;&#x37;&#x35;&#x39;&#50;&#48;&#56;&#x32;&#52;&#64;&#x71;&#x71;&#x2e;&#99;&#x6f;&#x6d;" target="_blank" rel="noopener">&#x35;&#x37;&#x35;&#x39;&#50;&#48;&#56;&#x32;&#52;&#64;&#x71;&#x71;&#x2e;&#99;&#x6f;&#x6d;</a><br>Date:   Thu Oct 25 13:10:32 2018 +0800</p><p>bash_demo first commit</p><p>这里，就是：136ecd07ab2b0742dff45dcdcfbde1d51da2df42</p><p>12）回滚</p><p>git reset –hard 136ecd07ab2b0742dff45dcdcfbde1d51da2df42<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git reset --hard 136ecd07ab2b0742dff45dcdcfbde1d51da2df42<br>HEAD is now at 136ecd0 bash_demo first commit<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure></p><p>查看，bash_demo.txt文件：<br><img src="/images/QQ截图20181025133411.png"></p><p>bash_demo文件就回滚到第一次提交的状态了。</p><p>13）现在产品经理说，所做的工作都不需要了。</p><p>删除bash_demo文件</p><p>git rm bash_demo<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git rm bash_demo.txt<br>rm &apos;bash_demo.txt&apos;<br></code></pre></td></tr></table></figure></p><p>git commit -m “delete bash demo”<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git commit -m &quot;delete bash demo&quot;<br>[master 6d7eacc] delete bash demo<br> 1 file changed, 1 deletion(-)<br> delete mode 100644 bash_demo.txt<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure></p><p>这样工作目录和本地仓库都删除了bash_demo文件了。</p><hr><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><img src="/images/QQ截图20181025134253.png"></p><p>1) 在工作区，先创建的文件，使用add，添加到暂存区，然后commit提交到本地仓库中。</p><p>2）reset head命令：head是指向本地仓库的指针。<br>reset head file 就是重置本地仓库中版本文件到暂存区中。<br>然后使用checkout – file 命令，将暂存区中的版本文件，重写到工作区中。</p><p>3）rm – file: 直接删除暂存区中的文件。然后commit提交，就更新到本地仓库中了。</p><p>4）checkout head file: 一般不用，比较危险，因为使用这个命令，会把本地仓库中的版本文件，直接覆写到暂存区和工作区中。</p><hr><p>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage/index），标记为 “master” 的是 master 分支所代表的目录树。</p><p>图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个“指针”。所以，图示的命令中出现 HEAD 的地方可以用 master 来替换。</p><p>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下。</p><p>当对工作区新增或修改的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区新增或修改的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。（如上图）</p><p>当执行提交操作 “git commit” 时，暂存区的目录树写到版本库的对象库（objects）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。（如上图）</p><p>当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 “git rm –cached <file>“ 命令时，会直接从暂存区删除文件，工作区则不做出改变。</file></p><p>当执行 “git checkout “ 或者 “git checkout – <file>“ 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</file></p><p>当执行 “git checkout HEAD .” 或者 “git checkout HEAD <file>“ 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</file></p><hr><h3 id="创建ssh-key"><a href="#创建ssh-key" class="headerlink" title="创建ssh key"></a>创建ssh key</h3><p>1）我们如果需要使用ssh来连接远程仓库的话，这里使用github当做远程仓库。</p><p>首先，生成我们的ssh的公钥：<br>ssh-keygen -t rsa -C “<a href="mailto:youremail@exmple.com" target="_blank" rel="noopener">youremail@exmple.com</a>“</p><p>在github上面，创建我们的账号。在setting里面，找到 SSH and GPG keys<br><img src="/images/QQ截图20181025144339.png"></p><p>点击右上角的：New SSH key<br><img src="/images/QQ截图20181025144438.png"></p><p>填写title，自己定义。key，需要使用命令来生成。</p><p>在Git bash界面下，输入生成ssh的命令：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ ssh-keygen -t rsa -C &quot;575920824@qq.com&quot;<br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/c/Users/liuzhuo/.ssh/id_rsa):<br></code></pre></td></tr></table></figure></p><p>直接回车，覆盖以前的就好了。</p><p>这样就会在c盘的用户目录生成一个.ssh文件夹</p><p>C:\Users\liuzhuo.ssh</p><p>打开<strong>id_rsa.pub</strong>文件，将里面的key复制到github的ssh中key中：<br><img src="/images/QQ截图20181025145015.png"></p><p>2) 测试是否连接github成功：</p><p>使用命令：ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ ssh -T git@github.com<br>Hi liuzhuo19940206! You&apos;ve successfully authenticated, but GitHub does not provide shell access.<br></code></pre></td></tr></table></figure></p><p>连接成功！！</p><hr><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><h4 id="使用命令行的方式"><a href="#使用命令行的方式" class="headerlink" title="使用命令行的方式"></a>使用命令行的方式</h4><p>在自己的github上面的，添加新的远程仓库<br><img src="/images/QQ截图20181025145915.png" style="width:50%"></p><p>点击 New repository<br><img src="/images/QQ截图20181025150029.png"></p><p>填写  </p><p>Repository name:仓库的名字</p><p>Description：仓库的描述信息</p><p>public：公共的仓库</p><p>private：私有的仓库<br><img src="/images/QQ截图20181025150238.png"></p><p>点击：Create repository<br><img src="/images/QQ截图20181025150341.png"></p><p>上面的两块部分，描述了，将本地仓库和这个远程仓库连接起来的方法！</p><p>第一种：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">…or create a new repository on the command line<br>echo &quot;# gitDemo&quot; &gt;&gt; README.md<br>git init<br>git add README.md<br>git commit -m &quot;first commit&quot;<br>git remote add origin https://github.com/liuzhuo19940206/gitDemo.git<br>git push -u origin master<br></code></pre></td></tr></table></figure></p><p>按照上面的步骤来，就行了。</p><p>在E:\gitdemo\demo4目录下，启动git的命令行界面<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4<br>$ echo &quot;# gitDemo&quot; &gt;&gt; README.md      //创建一个文件<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4<br>$ git init                          //创建一个本地仓库<br>Initialized empty Git repository in E:/gitdemo/demo4/.git/<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)<br>$ git add README.md                 //添加文件到暂存区<br>warning: LF will be replaced by CRLF in README.md.<br>The file will have its original line endings in your working directory.<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)<br>$ git commit -m &quot;first commit&quot;      //提交信息到本地仓库<br>[master (root-commit) e1e56e5] first commit<br> 1 file changed, 1 insertion(+)<br> create mode 100644 README.md<br></code></pre></td></tr></table></figure></p><p>接下来，连接本地仓库和远程仓库：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)<br>$ git remote add origin https://github.com/liuzhuo19940206/gitDemo.git<br></code></pre></td></tr></table></figure></p><p>最后，将本地仓库的提交到远程仓库中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)<br>$ git push -u origin master<br></code></pre></td></tr></table></figure></p><p>第一次提交会出现验证信息的弹窗：<br><img src="/images/QQ截图20181025151356.png" style="width:50%"></p><p>输入用户名和密码即可。</p><p>出现了 fatal: HttpRequestException encountered.</p><p>解决：Github 禁用了TLS v1.0 and v1.1，必须更新Windows的git凭证管理器 </p><p>通过此网址 <a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/" target="_blank" rel="noopener">https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/</a><br><img src="/images/QQ截图20181025152916.png"></p><p>点击GCMW-1.14.0.exe，下载并安装。</p><p>重启git窗口：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)<br>$ git push -u origin master<br>Counting objects: 3, done.<br>Writing objects: 100% (3/3), 217 bytes | 217.00 KiB/s, done.<br>Total 3 (delta 0), reused 0 (delta 0)<br>remote:<br>remote: Create a pull request for &apos;master&apos; on GitHub by visiting:<br>remote:      https://github.com/liuzhuo19940206/gitDemo/pull/new/master<br>remote:<br>To https://github.com/liuzhuo19940206/gitDemo.git<br> * [new branch]      master -&gt; master<br>Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;.<br></code></pre></td></tr></table></figure></p><p>就可以了，说明你的git和github已经可以同步了</p><p>在github上面，刷新你刚刚创建的项目：<br><img src="/images/QQ截图20181025154108.png"></p><hr><p>现在，修改README.md文件<br><img src="/images/QQ截图20181025154259.png"></p><p>然后  </p><p>git add README.md</p><p>git commit -m “second commit”</p><p>最后</p><p>将本地仓库同步到远程仓库</p><p>git push</p><p>这里不用指明远程仓库的名字，因为第一次同步后，就不需要了。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)<br>$ git push<br>Counting objects: 3, done.<br>Writing objects: 100% (3/3), 277 bytes | 277.00 KiB/s, done.<br>Total 3 (delta 0), reused 0 (delta 0)<br>To https://github.com/liuzhuo19940206/gitDemo.git<br>   e1e56e5..39e3593  master -&gt; master<br></code></pre></td></tr></table></figure><p>刷新远程仓库：<br><img src="/images/QQ截图20181025154719.png"></p><p>说明，本地仓库和远程仓库同步成功!!!!</p><hr><h4 id="使用SourceTree"><a href="#使用SourceTree" class="headerlink" title="使用SourceTree"></a>使用SourceTree</h4><p>1）创建新的远程仓库<br><img src="/images/QQ截图20181025155615.png"><br><img src="/images/QQ截图20181025155703.png"></p><p>2) 打开SourceTree创建本地仓库<br><img src="/images/QQ截图20181025155817.png"></p><p>在本地仓库中，新建文件sourcetree.txt文件<br><img src="/images/QQ截图20181025160003.png"></p><p>3）使用SourceTree添加到本地仓库中<br><img src="/images/QQ截图20181025160104.png"><br><img src="/images/QQ截图20181025160120.png"><br><img src="/images/QQ截图20181025160210.png"></p><p>4）将本地仓库和远程仓库连接起来</p><p>点击master，然后点击右上角的设置<br><img src="/images/QQ截图20181025160348.png"></p><p>点击添加远程仓库：<br><img src="/images/QQ截图20181025160430.png"></p><p>填写信息：</p><p>远程仓库名称：origin（自定义）</p><p>URL：在github中远程仓库复制。<br>这里是：<a href="https://github.com/liuzhuo19940206/gitDemo_SourceTree.git" target="_blank" rel="noopener">https://github.com/liuzhuo19940206/gitDemo_SourceTree.git</a></p><p>用户名：提交的用户名<br><img src="/images/QQ截图20181025160716.png"></p><p>点击确认。</p><p>在SourceTree中的左边的远程中：出现origin。<br><img src="/images/QQ截图20181025160844.png"></p><p>到此，我们就将远程仓库和本地仓库连接起来了。还没有同步！</p><p>5) 将本地仓库和远程仓库同步</p><p>点击菜单栏的推送<br><img src="/images/QQ截图20181025161056.png"></p><p>选好推送的远程仓库，添上加号，点击推送！</p><p>6）刷新远程仓库<br><img src="/images/QQ截图20181025161257.png"></p><p>发现，同步成功，点击sourcetree.txt文件<br><img src="/images/QQ截图20181025161359.png"></p><p>7）修改本地仓库中的sourcetree.txt文件<br><img src="/images/QQ截图20181025161447.png"></p><p>8）使用SourceTree提交<br><img src="/images/QQ截图20181025161550.png"><br><img src="/images/QQ截图20181025174045.png"><br><img src="/images/QQ截图20181025174124.png"></p><p>9）推送到远程仓库</p><p>此时，会发现推送上面会出现一个 1<br><img src="/images/QQ截图20181025174248.png"></p><p>点击推送<br><img src="/images/QQ截图20181025174319.png"></p><p>10）刷新远程仓库<br><img src="/images/QQ截图20181025174433.png"></p><p>这里出现了乱码，不影响我们的操作。</p><hr><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><p>克隆仓库：将远程的仓库克隆到本地当中。</p><p>使用的命令是：<br>git clone htt或ssh地址<br>git clone <a href="https://github.com/liuzhuo19940206/clone_repo_demo.git" target="_blank" rel="noopener">https://github.com/liuzhuo19940206/clone_repo_demo.git</a></p><p>1）在github上创建一个新的仓库<br><img src="/images/QQ截图20181025175600.png"></p><p>2) 直接在github上面创建一个README.md文件<br><img src="/images/QQ截图20181025175832.png"></p><p>上面两个步骤，就是假设刚刚创建的项目是别人的远程仓库，我们需要克隆别人的远程仓库，来进行多人开发。</p><h4 id="使用命令行来克隆"><a href="#使用命令行来克隆" class="headerlink" title="使用命令行来克隆"></a>使用命令行来克隆</h4><p>1）在E:\gitdemo\demo6下，启动git窗口<br><img src="/images/QQ截图20181025180055.png"></p><p>使用 ls -a<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo6<br>$ ls -a<br>./  ../<br></code></pre></td></tr></table></figure></p><p>如果没有出现.git文件，说明此目录才能克隆仓库。不能在已经是本地仓库下的情况下克隆远程仓库</p><p>2）执行克隆命令</p><p>git clone <a href="https://github.com/liuzhuo19940206/clone_repo_demo.git" target="_blank" rel="noopener">https://github.com/liuzhuo19940206/clone_repo_demo.git</a><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo6<br>$ git clone https://github.com/liuzhuo19940206/clone_repo_demo.git<br>Cloning into &apos;clone_repo_demo&apos;...<br>remote: Enumerating objects: 3, done.<br>remote: Counting objects: 100% (3/3), done.<br>remote: Compressing objects: 100% (2/2), done.<br>remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0<br>Unpacking objects: 100% (3/3), done.<br></code></pre></td></tr></table></figure></p><p>此时，打开demo6目录：在该目录下面会出远程仓库的名称和README.md文件<br><img src="/images/QQ截图20181025183824.png"><br><img src="/images/QQ截图20181025183908.png"><br><img src="/images/QQ截图20181025183938.png"></p><p>到此，克隆成功。</p><hr><h4 id="使用SourceTree来克隆"><a href="#使用SourceTree来克隆" class="headerlink" title="使用SourceTree来克隆"></a>使用SourceTree来克隆</h4><p>1）打开SourceTree，新建窗口<br><img src="/images/QQ截图20181025184546.png"></p><p>2）点击Clone按钮<br><img src="/images/QQ截图20181025184631.png"></p><p>第一行：远程仓库的地址<br><a href="https://github.com/liuzhuo19940206/clone_repo_demo.git" target="_blank" rel="noopener">https://github.com/liuzhuo19940206/clone_repo_demo.git</a></p><p>第二行：本地仓库的地址<br>E:\gitdemo\demo7</p><p><img src="/images/QQ截图20181025184839.png"></p><p>点击克隆<br><img src="/images/QQ截图20181025184925.png"></p><p>3）打开E:\gitdemo\demo7目录<br><img src="/images/QQ截图20181025185035.png"></p><hr><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>标签的作用是，给某个时刻的版本加上一个标签，然后，可以回滚到指定的标签。</p><p>标签的命令：</p><p>1) 查看所有标签 　　　　 git tag</p><p>2) 创建标签 　　　　　　 git tag name</p><p>3) 指定提交信息 　　　　 git tag -a name -m “comment”</p><p>4) 删除标签 　　　　　　 git tag -d neam</p><p>5) 标签发布 　　　　　 　git push origin name</p><p><strong>ps:markdown中使用空格</strong></p><p><strong>1) 手动输入空格 （&amp;nbsp；）。注意！此时的分号为英文分号，但是不推荐使用此方法，太麻烦！</strong></p><p><strong>2) 使用全角空格。即：在全角输入状态下直接使用空格键就ok了</strong></p><h4 id="使用命令行创建标签"><a href="#使用命令行创建标签" class="headerlink" title="使用命令行创建标签"></a>使用命令行创建标签</h4><p>现在是在E:\gitdemo\demo7目录下。<br><img src="/images/QQ截图20181025192253.png"></p><p>1）git tag 查看标签<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)<br>$ git tag<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)<br>$<br></code></pre></td></tr></table></figure></p><p>发现，没有标签</p><p>2）创建标签<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)<br>$ git tag v1.0.1<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)<br>$ git tag<br>v1.0.1<br></code></pre></td></tr></table></figure></p><p>3) push标签<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)<br>$ git push origin v1.0.1<br>Total 0 (delta 0), reused 0 (delta 0)<br>To https://github.com/liuzhuo19940206/clone_repo_demo.git<br> * [new tag]         v1.0.1 -&gt; v1.0.1<br></code></pre></td></tr></table></figure></p><p>4) 在远程仓库中验证标签是否推送成功<br><img src="/images/QQ截图20181025192912.png"></p><hr><h4 id="使用SourceTree创建标签"><a href="#使用SourceTree创建标签" class="headerlink" title="使用SourceTree创建标签"></a>使用SourceTree创建标签</h4><p>1) 现在修改一下E:\gitdemo\demo7下的README.md文件，为了和命令行创建的标签形成对比.<br><img src="/images/QQ截图20181025193635.png"></p><p>使用SourceTree，add + commit + push<br><img src="/images/QQ截图20181025193833.png"><br><img src="/images/QQ截图20181025193850.png"><br><img src="/images/QQ截图20181025193916.png"><br><img src="/images/QQ截图20181025194050.png"></p><p>2) 在SourceTree下创建新的标签</p><p>在SourceTree的菜单栏上面有一个标签的按钮，点击<br><img src="/images/QQ截图20181025194223.png"></p><p>第一行：标签的名称</p><p>提交：点击指定的提交<br><img src="/images/QQ截图20181025194327.png"></p><p>此时，可以选择在哪个提交的版本上面，创建新的标签，因为first commit上面有一个v1.0.1的标签了，为了区别，现在选择second commit的提交。点击确认</p><p>点击推送标签前面的方格，会将本地的标签推送到远程仓库上面。<br><img src="/images/QQ截图20181025194613.png"></p><p>3）点击添加标签<br><img src="/images/QQ截图20181025194731.png"><br><img src="/images/QQ截图20181025194804.png"></p><p>4）在远程仓库上面验证<br><img src="/images/QQ截图20181025194853.png"></p><p>5）切换标签</p><p>点击v1.0.1标签：<br><img src="/images/QQ截图20181025195005.png"><br><strong>下面的README.md文件中，没有second commit。</strong></p><p>点击v2.0.1标签：<br><img src="/images/QQ截图20181025195110.png"><br><strong>下面的README.md文件中，有second commit。</strong></p><font color="red"><strong>以后，就可以切换标签，来回滚到自己想要的版本。</strong></font><hr><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p><img src="/images/QQ截图20181025200337.png"></p><p>一般是，在我们开发的过程中，在主分支master上面写。但是，每个人都有自己的任务，这个任务，不能短时间内完成，不能只完成一部分就提交到master主分支上面，这样会使的其他人无法使用master主分支了。我们也不能等到我们开发完后，一次性提交代码到master主分支上面。因为我们想记录我们的每一个开发流程。</p><p>所以，需要创建子分支来记录我们的开发流程。最后与主分支合并。</p><h4 id="使用命令行的方式-1"><a href="#使用命令行的方式-1" class="headerlink" title="使用命令行的方式"></a>使用命令行的方式</h4><p>1）新建一个目录：E:\gitdemo\branch_demo</p><p>2）在该目录下，打开git窗口<br><img src="/images/QQ截图20181025201915.png"></p><p>3) 添加一个新的文件，模拟开发流程。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo<br>$ echo &quot;branch first&quot; &gt;&gt; branch_demo.txt            //创建新的文件<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo <br>$ git init                                         //创建本地仓库<br>Initialized empty Git repository in E:/gitdemo/branch_demo/.git/<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git status<br>On branch master<br><br>No commits yet<br><br>Untracked files:<br>  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)<br><br>        branch_demo.txt<br><br>nothing added to commit but untracked files present (use &quot;git add&quot; to track)<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git add branch_demo.txt                         //添加到暂存区<br>warning: LF will be replaced by CRLF in branch_demo.txt.<br>The file will have its original line endings in your working directory.<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git status<br>On branch master<br><br>No commits yet<br><br>Changes to be committed:<br>  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)<br><br>        new file:   branch_demo.txt<br><br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git commit -m &quot;branch first commit&quot;           //提交到本地仓库中<br>[master (root-commit) ac97673] branch first commit<br> 1 file changed, 1 insertion(+)<br> create mode 100644 branch_demo.txt<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure><p>4）开启新的分支<br>git brach  : 查看所有分支<br>git brach 分支名称 ：创建新的分支<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git branch<br>* master<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git branch new_branch<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git branch<br>* master<br>  new_branch<br></code></pre></td></tr></table></figure></p><p>5）切换分支<br>git checkout 分支名称<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git checkout new_branch<br>Switched to branch &apos;new_branch&apos;<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br></code></pre></td></tr></table></figure></p><p>切换成功后，右边的括号内就是分支的名称。</p><p>6）在新分支继续开发<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ echo &quot; new_branch&quot; &gt;&gt; branch_demo.txt<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git status<br>On branch new_branch<br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>        modified:   branch_demo.txt<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git add branch_demo.txt<br>warning: LF will be replaced by CRLF in branch_demo.txt.<br>The file will have its original line endings in your working directory.<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git status<br>On branch new_branch<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>        modified:   branch_demo.txt<br><br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git commit -m &quot;new_branch commit&quot;<br>[new_branch 25fe8ff] new_branch commit<br> 1 file changed, 2 insertions(+), 1 deletion(-)<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git status<br>On branch new_branch<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure></p><p>7) 分别在每个分支查看branch_demo.txt文件</p><p>在新的分支下查看：<br>cat branch_demo.txt<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git branch<br>  master<br>* new_branch<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ cat branch_demo.txt<br>branch first<br>new_branch<br></code></pre></td></tr></table></figure></p><p>切换到主分支查看：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git checkout master<br>Switched to branch &apos;master&apos;<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ cat branch_demo.txt<br>branch first<br></code></pre></td></tr></table></figure></p><p>8) 合并分支</p><p>git merge 子分支的名字</p><font color="red">在主分支(master)下，执行该命令</font><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git merge new_branch<br>Updating ac97673..25fe8ff<br>Fast-forward<br> branch_demo.txt | 3 ++-<br> 1 file changed, 2 insertions(+), 1 deletion(-)<br></code></pre></td></tr></table></figure><p>9）查看主分支中的文件<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ cat branch_demo.txt<br>branch first<br>new_branch<br></code></pre></td></tr></table></figure></p><p><strong>现在，主分支与子分支合并成功，文件中出现了new_branch的信息。</strong></p><p>10）删除分支</p><p>当我们的项目接着开发，之前的new_brach分子不需要，浪费空间，所有需要删除。</p><p>git branch -d 分支的名称</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git branch -d new_branch<br>Deleted branch new_branch (was 25fe8ff).<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git branch<br>* master<br></code></pre></td></tr></table></figure><p>此时，new_branch分支删除成功。</p><h4 id="使用SourceTree的方式"><a href="#使用SourceTree的方式" class="headerlink" title="使用SourceTree的方式"></a>使用SourceTree的方式</h4><p>1）打开SourceTree</p><p>在E:\gitdemo\branch_sourcetree_demo下创建本地仓库<br><img src="/images/QQ截图20181025205416.png"></p><p>2）在E:\gitdemo\branch_sourcetree_demo下创建branch_demo.txt文件：<br><img src="/images/QQ截图20181025205522.png"></p><p>3）add + commit<br><img src="/images/QQ截图20181025205642.png"><br><img src="/images/QQ截图20181025205658.png"><br><img src="/images/QQ截图20181025205724.png"><br><img src="/images/QQ截图20181025205758.png"></p><p>4) 创建新的分支</p><p>在SourceTree的菜单栏上面有一个分支的按钮<br><img src="/images/QQ截图20181025205849.png"><br><img src="/images/QQ截图20181025205950.png"></p><p>创建分支成功后，在SourceTree左边，会出现新的分支<br><img src="/images/QQ截图20181025210021.png"></p><p><strong>选中的分支前面会有一个圆圈</strong></p><p>5）在新的分支下，修改branch_demo.txt文件<br><img src="/images/QQ截图20181025210235.png"></p><p>6) 在新的分支下，add + commit<br><img src="/images/QQ截图20181025210332.png"><br><img src="/images/QQ截图20181025210426.png"><br><img src="/images/QQ截图20181025210509.png"></p><p>7）切换到master分支下</p><p>双击master主分支，就切换成功了。<br><img src="/images/QQ截图20181025210659.png"></p><p>8）打开E:\gitdemo\branch_sourcetree_demo下的branch_demo.txt文件<br><img src="/images/QQ截图20181025210750.png"></p><p>发现文件里面，没有new_branch second信息。</p><p>9）将子分支合并到主分支中</p><p>在主分支的情况下，点击菜单栏下的合并按钮<br><img src="/images/QQ截图20181025211021.png"></p><p>点击我们要合并的分支。然后点击确定。<br><img src="/images/QQ截图20181025211223.png"></p><p>现在，再打开E:\gitdemo\branch_sourcetree_demo下的branch_demo.txt文件。<br><img src="/images/QQ截图20181025211400.png"></p><p>现在，合并成功了。</p><p>10）删除分支</p><p>直接在要删除的分支上面右键<br><img src="/images/QQ截图20181025211604.png"><br><img src="/images/QQ截图20181025211636.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC注解</title>
      <link href="/2018/10/24/SpringMVC%E6%B3%A8%E8%A7%A3/"/>
      <url>/2018/10/24/SpringMVC%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><strong>SpringMVC注解</strong></p><p>SpringMVC注解的详细解答<br><a id="more"></a></p><h3 id="注解概观"><a href="#注解概观" class="headerlink" title="注解概观"></a>注解概观</h3><p><strong>Spring2.5 引入注解式处理器</strong></p><p>@Controller：用于标识是处理器类；</p><p>@RequestMapping：请求到处理器功能方法的映射规则；</p><p>@RequestParam：请求参数到处理器功能处理方法的方法参数上的绑定；</p><p>@ModelAttribute：请求参数到命令对象的绑定；</p><p>@SessionAttributes：用于声明session级别存储的属性，放置在处理器类上，通常列出模型属性（如@ModelAttribute）对应的名称，则这些属性会透明的保存到session中；</p><p>@InitBinder：自定义数据绑定注册支持，用于将请求参数转换到命令对象属性的对应类型；</p><hr><p><strong>Spring3.0 引入RESTful架构风格支持(通过@PathVariable注解和一些其他特性支持),且又引入了更多的注解支持</strong></p><p>@CookieValue：cookie数据到处理器功能处理方法的方法参数上的绑定；</p><p>@RequestHeader：请求头（header）数据到处理器功能处理方法的方法参数上的绑定；</p><p>@RequestBody：请求的body体的绑定（通过HttpMessageConverter进行类型转换）；</p><p>@ResponseBody：处理器功能处理方法的返回值作为响应体（通过HttpMessageConverter进行类型转换）；</p><p>@ResponseStatus：定义处理器功能处理方法/异常处理器返回的状态码和原因；</p><p>@ExceptionHandler：注解式声明异常处理器；</p><p>@PathVariable：请求URI中的模板变量部分到处理器功能处理方法的方法参数上的绑定</p><h3 id="类与方法注解"><a href="#类与方法注解" class="headerlink" title="类与方法注解"></a>类与方法注解</h3><p>@Controller @RestController</p><p>@RestContrller注解相当于@ResponseBody和@Controller的结合 :</p><h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h4><p>通过HttpMessageConverter接口转换为指定格式的数据</p><h4 id="InitBinder-局部转换器"><a href="#InitBinder-局部转换器" class="headerlink" title="@InitBinder-局部转换器"></a>@InitBinder-局部转换器</h4><p>如果希望某个属性编辑器仅作用于特定的 Controller ，</p><p>可以在 Controller 中定义一个标注 @InitBinder 注解的方法，</p><p>可以在该方法中向 Controller 了注册若干个属性编辑器</p><p>例如:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@InitBinder<br>public void initBinder(WebDataBinder binder) &#123;<br>SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);<br>dateFormat.setLenient(false);<br>binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="RequestMapping-请求路径映射"><a href="#RequestMapping-请求路径映射" class="headerlink" title="@RequestMapping-请求路径映射"></a>@RequestMapping-请求路径映射</h4><p>RequestMapping是一个用来处理请求地址映射的注解（将请求映射到对应的控制器方法中），可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>RequestMapping请求路径映射，如果标注在某个controller的类级别上，则表明访问此类路径下的方法都要加上其配置的路径；最常用是标注在方法上，表明哪个具体的方法来接受处理某次请求。</p><p>属性:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。<br>1、 value， method；<br>value：   指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；<br>method：  指定请求的method类型， GET、POST、PUT、DELETE等；<br>2、consumes，produces<br>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;<br>produces:  指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；<br>3、params，headers<br>params：  指定request中必须包含某些参数值是，才让该方法处理。<br>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。<br></code></pre></td></tr></table></figure></p><p>派生的子类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Ø  @GetMapping<br><br>Ø  @PostMapping<br><br>Ø  @PutMapping<br><br>Ø  @DeleteMapping<br><br>Ø  @PatchMapping<br></code></pre></td></tr></table></figure></p><p>属性详解：</p><h5 id="value"><a href="#value" class="headerlink" title="value"></a><font size="4">value</font></h5><p>用法</p><p>(1)普通的具体值。如前面的 value=”/book”。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RequestMapping(value=&quot;/get/&#123;bookId&#125;&quot;)<br>public String getBookById(@PathVariable String bookId,Model model)&#123;<br>  model.addAttribute(&quot;bookId&quot;, bookId);<br>  return &quot;book&quot;;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>(2)含某变量的一类值。</p><p>(3)ant风格<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RequestMapping(value=&quot;/get/id?&quot;)：可匹配“/get/id1”或“/get/ida”，但不匹配“/get/id”或“/get/idaa”;<br>@RequestMapping(value=&quot;/get/id*&quot;)：可匹配“/get/idabc”或“/get/id”，但不匹配“/get/idabc/abc”;<br>@RequestMapping(value=&quot;/get/id/*&quot;)：可匹配“/get/id/abc”，但不匹配“/get/idabc”;<br>@RequestMapping(value=&quot;/get/id/**/&#123;id&#125;&quot;)：可匹配“/get/id/abc/abc/123”或“/get/id/123”，也就是Ant风格和URI模板变量风格可混用。<br></code></pre></td></tr></table></figure></p><p>(4)含正则表达式的一类值<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RequestMapping(value=&quot;/get/&#123;idPre:\d+&#125;-&#123;idNum:\d+&#125;&quot;)：<br>可以匹配“/get/123-1”，但不能匹配“/get/abc-1”，这样可以设计更加严格的规则。<br>可以通过@PathVariable 注解提取路径中的变量(idPre,idNum)<br></code></pre></td></tr></table></figure></p><p>(5)或关系<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RequestMapping(value=&#123;&quot;/get&quot;,&quot;/fetch&quot;&#125; ) 即 /get或/fetch都会映射到该方法上。<br></code></pre></td></tr></table></figure></p><h5 id="method"><a href="#method" class="headerlink" title="method"></a><font size="4">method</font></h5><p>指定请求的method类型， GET、POST、PUT、DELETE等；</p><p>用法:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RequestMapping(value=&quot;/get/&#123;bookid&#125;&quot;,method=&#123;RequestMethod.GET,RequestMethod.POST&#125;)<br></code></pre></td></tr></table></figure></p><h5 id="params："><a href="#params：" class="headerlink" title="params："></a><font size="4">params：</font></h5><p><strong>指定request中必须包含某些参数值是，才让该方法处理。</strong></p><p>@RequestMapping(params=”action=del”)，请求参数包含”action=del”,如：</p><p><code>http://localhost:8080/book?action=del</code></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Controller<br>@RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)<br>public class RelativePathUriTemplateController &#123;<br>@RequestMapping(value = &quot;/pets/&#123;petId&#125;&quot;, method = RequestMethod.GET, params=&quot;myParam=myValue&quot;)<br>public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) &#123;    <br>  // implementation omitted<br>&#125;<br>&#125;<br>仅处理请求中包含了名为“myParam”，值为“myValue”的请求<br></code></pre></td></tr></table></figure><h5 id="headers："><a href="#headers：" class="headerlink" title="headers："></a><font size="4">headers：</font></h5><p>指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><p>@RequestMapping(value=”/header/id”, headers = “Accept=application/json”)：</p><p>表示请求的URL必须为“/header/id 且请求头中必须有“Accept =application/json”参数即可匹配。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Controller<br>@RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)<br>public class RelativePathUriTemplateController &#123;<br><br>@RequestMapping(value = &quot;/pets&quot;, method = RequestMethod.GET, headers=&quot;Referer=http://www.ifeng.com/&quot;)<br>public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) &#123;    <br>  // implementation omitted<br>&#125;<br><br>&#125;<br>    仅处理request的header中包含了指定“Refer”请求头和对应值为“http://www.ifeng.com/”的请求。<br></code></pre></td></tr></table></figure></p><h5 id="consumes："><a href="#consumes：" class="headerlink" title="consumes："></a><font size="4">consumes：</font></h5><p>指定处理请求的提交内容类型（Content-Type），例如application/json, text/html。</p><p>用法:</p><p>@RequestMapping(value = “/pets”, method = RequestMethod.POST, consumes=”application/json”)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Controller<br>@RequestMapping(value = &quot;/pets&quot;, method = RequestMethod.POST, consumes=&quot;application/json&quot;)<br>public void addPet(@RequestBody Pet pet, Model model) &#123;    <br>  // implementation omitted<br>&#125;<br>          方法仅处理request Content-Type为“application/json”类型的请求。<br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC-参数绑定</title>
      <link href="/2018/10/24/SpringMVC-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/"/>
      <url>/2018/10/24/SpringMVC-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p><strong>SpringMVC-参数绑定</strong></p><p>探究SpringMVC中控制层的方法中的参数绑定<br><a id="more"></a></p><h4 id="Model-ModelMap-ModelAndView"><a href="#Model-ModelMap-ModelAndView" class="headerlink" title="Model/ModelMap/ModelAndView"></a>Model/ModelMap/ModelAndView</h4><p>ModelMap是Model接口的实现类，通过Model或ModelMap向页面传递数据，如下<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RequestMapping(&quot;/itemEdit&quot;)<br>    public String itemEdit(Integer id, Model model) &#123;<br>        Items items = itemService.getItemById(id);<br>        //向jsp传递数据<br>        model.addAttribute(&quot;item&quot;, items);<br>        //设置跳转的jsp页面<br>        return &quot;editItem&quot;;<br>    &#125;<br>    /*@RequestMapping(&quot;/itemEdit&quot;)<br>    public String editItem(HttpServletRequest request, <br>            HttpServletResponse response, HttpSession session, Model model) &#123;<br>        //从request中取参数<br>        String strId = request.getParameter(&quot;id&quot;);<br>        int id = new Integer(strId);<br>        //调用服务<br>        Items items = itemService.getItemById(id);<br>        //把结果传递给页面<br>        //ModelAndView modelAndView = new ModelAndView();<br>        //modelAndView.addObject(&quot;item&quot;, items);<br>        //设置逻辑视图<br>        //modelAndView.setViewName(&quot;editItem&quot;);<br>        //return modelAndView;<br>        //设置返回结果<br>        model.addAttribute(&quot;item&quot;, items);<br>        //返回逻辑视图<br>        return &quot;editItem&quot;;<br>    &#125;<br>    */<br></code></pre></td></tr></table></figure></p><h4 id="Any-other-argument原始参数"><a href="#Any-other-argument原始参数" class="headerlink" title="Any other argument原始参数"></a>Any other argument原始参数</h4><p>当请求的参数名称和处理器形参<strong>名称一致时</strong>会将请求参数与形参进行绑定。从Request取参数的方法可以进一步简化。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RequestMapping(&quot;/itemEdit&quot;)<br>    public String itemEdit(Integer id, Model model) &#123;<br>        Items items = itemService.getItemById(id);<br>        //向jsp传递数据<br>        model.addAttribute(&quot;item&quot;, items);<br>        //设置跳转的jsp页面<br>        return &quot;editItem&quot;;<br>    &#125;<br>参数类型推荐使用包装数据类型，因为基础数据类型不可以为null<br>整形：  Integer、int<br>字符串：String<br>单精度：Float、float<br>双精度：Double、double<br>布尔型：Boolean、boolean<br>说明：对于布尔类型的参数，请求的参数值为true或false。<br>处理方法：<br>public String editItem(Model model,Integer id,Boolean status) throws Exception<br>请求url：<br>http://localhost:8080/xxx.action?id=2&amp;status=false<br>处理器形参中添加如下类型的参数处理适配器会默认识别并进行赋值。<br></code></pre></td></tr></table></figure></p><h3 id="注解形式："><a href="#注解形式：" class="headerlink" title="注解形式："></a>注解形式：</h3><p>下面是具体使用说明，几乎都是下面这种格式：Public String (@RequestParam int id){..}</p><h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h4><p>@RequestParam用来接收路径后面的参数<br><code>http:www.lifeibai.com?petId = 1.</code><br> 一般用来处理接收的参数和形参的参数不一致的情况<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RequestParam(value = &quot;id&quot;,defaultValue = &quot;10&quot;,required = false)<br>defaultValue 表示设置默认值，<br>required     通过boolean设置是否是必须要传入的参数，<br>value        值表示接受的传入的参数名称<br>使用@RequestParam常用于处理简单类型的绑定。<br></code></pre></td></tr></table></figure></p><p>例子：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Controller<br>@RequestMapping(&quot;/pets&quot;)<br>public class EditPetForm &#123;<br>  // ...<br>  @GetMapping<br>  public String setupForm(@RequestParam(&quot;petId&quot;) int Id, Model model) &#123;<br>      Pet pet = this.clinic.loadPet(petId);<br>      model.addAttribute(&quot;pet&quot;, pet);<br>      return &quot;petForm&quot;;<br>  &#125;<br>  // ...<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h4><p>@RequestHeader用来接收指定参数的请求头信息<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@GetMapping(&quot;/demo&quot;)<br>public void handle(<br>      @RequestHeader(&quot;Accept-Encoding&quot;) String encoding,<br>      @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive) &#123;<br>  //...<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h4><p>用来接收指定名称的cookie的值<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public void handle(@CookieValue(&quot;JSESSIONID&quot;) String cookie) &#123;<br>  //...<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a><font color="red">@ModelAttribute</font></h4><p>ModelAttribute可以应用在<strong>方法参数上</strong>或<strong>方法上</strong>，他的作用主要是当注解在方法参数上时会将注解的参数对象添加到Model中；</p><p>当注解在请求处理方法Action上时会将该方法变成一个非请求处理的方法，但其它Action被调用时会<strong>首先</strong>调用该方法。</p><p><font color="#FF3E96">被@ModelAttribute注释的方法会在此controller每个方法执行前被执行，下面访问 http:localhost:8080/test_project/test.action</font><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RestController<br>@SessionAttributes(&quot;user&quot;)<br>public class TestController &#123;<br>    @ModelAttribute(&quot;age2&quot;)<br>    public String mdoeltest1()&#123;<br>        System.out.println(&quot;This is ModelAttribute1 !&quot;);<br>        return &quot;33&quot;;<br>    &#125;<br>    @ModelAttribute(&quot;age1&quot;)<br>    public String mdoeltestrrr()&#123;<br>        System.out.println(&quot;This is ModelAttributee1 !&quot;);<br>        return &quot;22&quot;;<br>    &#125;<br>    @RequestMapping(&quot;/test.action&quot;)<br>    public String test(User user , <br>                       @ModelAttribute(&quot;age1&quot;) String age1 ,<br>                       @ModelAttribute(&quot;age2&quot;) String age2 ,<br>                       HttpSession session)&#123;<br>        Object user2 = session.getAttribute(&quot;user&quot;);<br>        System.out.println(user2);<br>        System.out.println(user);<br>        System.out.println(&quot;age1:&quot;+age1);<br>        System.out.println(&quot;age2:&quot;+age2);<br>        return &quot;test&quot;;<br>    &#125;<br>&#125;<br>结果：<br>This is ModelAttributee1 !<br>This is ModelAttribute1 !<br>User&#123;name=&apos;李四&apos;, age=22&#125;<br>User&#123;name=&apos;李四&apos;, age=22&#125;<br>age1:22<br>age2:33<br></code></pre></td></tr></table></figure></p><h4 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a>@SessionAttributes</h4><p>Value={“name”,“age”} 取出name或者value、或者把model中的name，age扔到session中<br>Type=User.Class   将一个实体类扔到session中<br>这个玩意加在 类上面，然后所有的方法的参数都可以在sesssion中找，找到了就赋值。<br>@SessionAttributes需要清除时，使用SessionStatus.setComplete();来清除。</p><p>1、  将model中的值，扔到session中</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Controller<br>@SessionAttributes(types = User.class)<br>public class LoginController &#123;<br>  @RequestMapping(&quot;/login&quot;)<br>  public String login(HttpServletRequest req,Model model,SessionStatus status)&#123;<br>      User user = new User();<br>      user.setName(&quot;李四&quot;);<br>      user.setAge(22);<br>      model.addAttribute(&quot;user&quot; , user);<br>      return &quot;forward:test.action&quot;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、  从session取出来<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RestController<br>@SessionAttributes(&quot;user&quot;)<br>public class TestController &#123;<br>  @RequestMapping(&quot;/test.action&quot;)<br>  public String  test(User user, HttpSession session)&#123;<br>      Object user2 = session.getAttribute(&quot;user&quot;);<br>      System.out.println(user2);<br>      System.out.println(user);<br>      return &quot;test&quot;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="@SessionAttribute"></a>@SessionAttribute</h4><p>这玩意是加在方法上的参数的，将session中的数据赋值给参数 。但是4.3以后的版本才支持<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RequestMapping(&quot;/&quot;)<br>public String handle(@SessionAttribute User user) &#123;<br>    // ...<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h4><p>@RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容转换为json、xml等格式的数据并绑定到controller方法的参数上<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">List.action?id=1&amp;name=zhangsan&amp;age=12<br>本例子应用：<br>@RequestBody注解实现接收http请求的json数据，将json数据转换为java对象<br>// 商品修改提交json信息，响应json信息<br>  @RequestMapping(&quot;/editItemSubmit_RequestJson&quot;)<br>  public @ResponseBody Items editItemSubmit_RequestJson(@RequestBody Items items) throws Exception &#123;<br>      System.out.println(items);<br>      //itemService.saveItem(items);<br>      return items;<br>  &#125;<br></code></pre></td></tr></table></figure></p><h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h4><p>该注解用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端</p><p>@ResponseBody注解实现将controller方法返回对象转换为json响应给客户端</p><p><strong><font color="red">使用这个注解 ，sessionAttributes注解将会失效</font></strong></p><h4 id="PathVariable（RESTful）"><a href="#PathVariable（RESTful）" class="headerlink" title="@PathVariable（RESTful）"></a>@PathVariable（RESTful）</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">用法<br>     @RequestMapping(value=&quot;/users/&#123;userId&#125;/topics/&#123;topicId&#125;&quot;)<br>     public String test(<br>     @PathVariable(value=&quot;userId&quot;) int userId, <br>     @PathVariable(value=&quot;topicId&quot;) int topicId) <br>     如请求的URL为“控制器URL/users/123/topics/456”，<br>     则自动将URL中模板变量&#123;userId&#125;和&#123;topicId&#125;绑定到<br>     通过@PathVariable注解的同名参数上，即入参后userId=123、topicId=456。<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC-Return Values返回值</title>
      <link href="/2018/10/24/Values%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
      <url>/2018/10/24/Values%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p><strong>SpringMVC-Return Values返回值</strong></p><p>本篇文章，主要讲解SpringMVC的返回值的使用。</p><a id="more"></a><hr><h3 id="Handler-Return-Values返回值"><a href="#Handler-Return-Values返回值" class="headerlink" title="Handler-Return Values返回值"></a>Handler-Return Values返回值</h3><h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h4><p> 返回值通过HttpMessageConverters转换并写入响应。   请参阅@ResponseBody。<br> 处理器功能处理方法的返回值作为响应体（通过HttpMessageConverter进行类型转换）；<br> 作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。<br> 使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p><h4 id="HttpEntity-ResponseEntity"><a href="#HttpEntity-ResponseEntity" class="headerlink" title="HttpEntity,ResponseEntity"></a>HttpEntity,ResponseEntity</h4><p>返回值:指定完整响应，包括HTTP标头和正文通过HttpMessageConverters转换并写入响应。 请参阅ResponseEntity。</p><h4 id="HttpHeaders"><a href="#HttpHeaders" class="headerlink" title="HttpHeaders"></a>HttpHeaders</h4><p>为了返回一个响应头和没有正文。</p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>一个视图名称，用ViewResolver解决，并与隐式模型一起使用 - 通过命令对象和@ModelAttribute方法确定。 处理程序方法也可以通过声明一个Model参数来以编程方式丰富模型。</p><h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><p>用于与隐式模型一起渲染的View实例 - 通过命令对象和@ModelAttribute方法确定。 处理程序方法也可以通过声明一个Model参数来以编程方式丰富模型。</p><h4 id="java-util-Map-org-springframework-ui-Model"><a href="#java-util-Map-org-springframework-ui-Model" class="headerlink" title="java.util.Map,org.springframework.ui.Model"></a>java.util.Map,org.springframework.ui.Model</h4><p>要通过RequestToViewNameTranslator隐式确定的视图名称添加到隐式模型的属性。</p><h4 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h4><p>要通过RequestToViewNameTranslator隐式确定的视图名称添加到模型的属性。   请注意@ModelAttribute是可选的。</p><h4 id="ModelAndView-，object"><a href="#ModelAndView-，object" class="headerlink" title="ModelAndView ，object"></a>ModelAndView ，object</h4><p>要使用的视图和模型属性，以及可选的响应状态。</p><h4 id="void"><a href="#void" class="headerlink" title="void"></a>void</h4><p>具有void返回类型（或返回值为null）的方法如果还有ServletResponse，OutputStream参数或@ResponseStatus注释，则认为它已完全处理响应。<br>如果控制器进行了积极的ETag或lastModified时间戳检查（请参阅@Controller缓存了解详细信息），情况也是如此。<br>如果以上都不是这样，那么void返回类型也可能指示REST控制器的“无响应主体”，或HTML控制器的默认视图名称选择。</p><h4 id="DeferredResult"><a href="#DeferredResult" class="headerlink" title="DeferredResult"></a><font color="red">DeferredResult</font></h4><p>从任何线程异步生成任何上述返回值 - 例如 可能是由于某些事件或回调。</p><h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a><font color="red">Callable</font></h4><p>Produce any of the above return values asynchronously in a Spring MVC managed thread. See Async Requests and Callable.使用异步线程来执行请求，然后返回给handler。</p><h4 id="ListenableFuture-java-util-concurrent-CompletionStage-java-util-concurrent-CompletableFuture"><a href="#ListenableFuture-java-util-concurrent-CompletionStage-java-util-concurrent-CompletableFuture" class="headerlink" title="ListenableFuture, java.util.concurrent.CompletionStage,   java.util.concurrent.CompletableFuture"></a>ListenableFuture, java.util.concurrent.CompletionStage,   java.util.concurrent.CompletableFuture</h4><p>在Spring MVC托管线程中异步生成上述任何返回值。</p><h4 id="ResponseBodyEmitter-SseEmitter"><a href="#ResponseBodyEmitter-SseEmitter" class="headerlink" title="ResponseBodyEmitter,   SseEmitter"></a>ResponseBodyEmitter,   SseEmitter</h4><p>用HttpMessageConverter’s异步发出一个对象流写入响应; 也支持作为ResponseEntity的主体。</p><h4 id="StreamingResponseBody"><a href="#StreamingResponseBody" class="headerlink" title="StreamingResponseBody"></a>StreamingResponseBody</h4><p>异步写入响应的OutputStream; 也支持作为ResponseEntity的主体。</p><h4 id="Reactive-types-—-Reactor-RxJava-or-others-via-ReactiveAdapterRegistry"><a href="#Reactive-types-—-Reactor-RxJava-or-others-via-ReactiveAdapterRegistry" class="headerlink" title="Reactive   types — Reactor, RxJava, or others via ReactiveAdapterRegistry"></a>Reactive   types — Reactor, RxJava, or others via ReactiveAdapterRegistry</h4><p>具有多值流的DeferredResult（例如Flux，Observable）的替代方法被收集到列表中。<br>对于流式场景 - 例如 text / event-stream，application / json +   stream - 使用SseEmitter和ResponseBodyEmitter，而在Spring MVC托管线程上执行ServletOutputStream阻塞I / O，并在每次写入完成时施加背压。</p><h4 id="Any-other-return-value"><a href="#Any-other-return-value" class="headerlink" title="Any other return  value"></a>Any other return  value</h4><p> 如果返回值与以上任何一个不匹配，默认情况下它被视为视图名称，如果它是String或void（通过RequestToViewNameTranslator应用的默认视图名称选择）; 或者作为要添加到模型的模型属性，除非它是一个简单的类型，由BeanUtils＃isSimpleProperty确定，在这种情况下，它仍然未解决。</p><hr><h3 id="返回ModelAndView-Model"><a href="#返回ModelAndView-Model" class="headerlink" title="返回ModelAndView/Model"></a>返回ModelAndView/Model</h3><p>controller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view。</p><p>Model与ModelAndView的传递效果是一样的，且传递是数据不能是引用类型。<br>重定向时，会把数据拼接到Url后面</p><p>@返回void </p><p>啥也不做 - -</p><hr><p>返回字符串</p><p>这玩意需要用到@ResponseBody注解</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RestController<br>public class TestController &#123;<br>  @RequestMapping(&quot;/test.action&quot;)<br>  public String  test( int ids)&#123;<br>      System.out.println(&quot;id:&quot;+ids);<br>      return &quot;this is test&quot;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑视图名</p><p>这玩意需要你配置视图解析器</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">INF/jsp/item/editItem.jsp<br>return &quot;item/editItem&quot;;<br></code></pre></td></tr></table></figure><p>Redirect重定向</p><p>Contrller方法返回结果重定向到一个url地址，如下商品修改提交后重定向到商品查询方法，参数无法带到商品查询方法中.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//重定向到queryItem.action地址,request无法带过去<br>return &quot;redirect:queryItem.action&quot;;<br></code></pre></td></tr></table></figure></p><p>redirect方式相当于“response.sendRedirect()”，转发后浏览器的地址栏变为转发后的地址，因为转发即执行了一个新的request和response。</p><p>由于新发起一个request原来的参数在转发时就不能传递到下一个url，如果要传参数可以/item/queryItem.action后边加参数，如下：</p><p>/item/queryItem?…&amp;…..</p><p>对于model设置的值，重定向会拼接到？key=value…. 版本4.3以后好像改了，记不太清了，你们可以自己去玩一下</p><hr><p>forward转发</p><p>跟Redirect一样的用法，不同的是 转发可以传递参数<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//结果转发到editItem.action，request可以带过去<br>return &quot;forward:editItem.action&quot;;<br>forward方式相当于“request.getRequestDispatcher().forward(request,response)”，转发后浏览器地址栏还是原来的地址。转发并没有执行新的request和response，而是和转发前的请求共用一个request和response。所以转发前请求的参数在转发后仍然可以读取到。<br>带域的返回<br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC架构与流程</title>
      <link href="/2018/10/24/SpringMVC%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/10/24/SpringMVC%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>SpringMVC的架构与流程</strong></p><p>探究MVC在SpringMVC中的关系。<br><a id="more"></a><br><strong>前言：</strong></p><p>顾名思义SpringMVC是一个基于MVC设计思想的框架。</p><p>什么是mvc？MVC是模型(model)－视图(view)－控制器(controller)的缩写 ，是一种软件设计思想，主要的作用就是解决应用开发的耦合性，将应用的输入、控制、输出进行强制解耦。</p><p>mvc中的模型、视图、控制器分别担负着不同的角色：</p><p>模型：页数的数据和业务的处理。我们平常用的service和dao层就属于这一层面</p><p>视图：只用于用户的显示，不进行任何的业务处理。主要用来获取和显示数据</p><p>控制器：控制视图层与用户的交互，将对应的操作调用对应的模型。简单的说，就是管理交互的</p><p>理解了mvc，我们就来说一说mvc的执行过程：用户通过view层向服务器发出请求，controller接收请求后，调用对应的model后获取数据，控制器在将数据返回给view。</p><p><strong>好了，我们可以进入正题了，既然SpringMVC是基于MVC的软件设计思想的框架，我们就先看一下SpringMVC的M、V、C分别是什么</strong></p><p><img src="/images/20181024152707.png"></p><p>上图里的东西我们不用细看，只需要大概晓得对应的mvc是啥的就行</p><p>M:这里的模型指定是具体执行的Handler(Controller)。</p><p>V:就是试图View</p><p>C:指的的前端控制器</p><p><strong>了解的springMVC的架构思想（mvc），我就开始继续深入的学习springmvc的执行流程吧。</strong></p><p>下面的顺序并不代表图中的顺序：</p><p>用户将请求发送给前端控制器（DispatcherServlet）也就是SpringMVC的控制器</p><p>然后 前端控制器 请求调用HandlerMapper（处理器映射器）</p><p>处理器映射器 根据请求的url返回 Handler和处理器拦截器（如果有）给前端控制器（DispatcherServlet）</p><p>前端控制器（DispatcherServlet）找到合适的 处理器适配器(HanderAdatper)，由处理器适配器调用Handler</p><p>Handler（以后统称为Controller）执行操作，Handler通常就是我们定义的controller(这里的controller是springmvc的model层),执行完后返回ModelAndView</p><p>处理器映射器(HanderAdatper)将ModelAndView返回给 前端控制器</p><p>然后 前端控制器将ModelAndView 传递给 视图解析器（ViewReslover )</p><p>视图解析器解析（ViewReslover )后 返回具体view，给前端控制器（DispatcherServlet）</p><p>前端控制器（DispatcherServlet）对视图进行渲染（将数据填充到视图中）</p><p>前端控制器（DispatcherServlet）将视图返回给用户。</p><hr><p>了解了流程，我们在详细了解一下里面讲到的部件：</p><p>前端控制器（DispatcherServlet）：这玩意是 SpringMVC的入口（实际上呢就是一个Servlet对象），所有的请求都要通过它，因为是个Servlet所以不可避免的你要在web.xml进行配置(Servlet3.0以后，可以不使用web.xml配置文件了)。</p><p>处理器映射器(HandlerMapper)，这个玩意就是根据不同的方式找到处理器（Handler），它支持的有配置文件形式，接口形式，注解形式等等</p><p>处理器适配器（HandlAdapter ）这玩意就是 分析处理器是那种方式的处理器（配置文件，接口、注解等形式）然后执行Handler</p><p>ModelAndView 封装了数据和视图信息，如果想进行页面的数据交互，可以选择这玩意进行传输，数据的存放位置，默认的是Request域</p><p>视图解析器（ViewResolver ），负责将处理结果生成View视图。</p><p>视图（View ） SpringMVC提供了很多视图，比如jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp</p><hr><p><strong>在spring-mvc.xml文件中配置：</strong><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!-- 配置处理器映射器 --&gt;<br>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;<br>&lt;!-- 配置处理器适配器 --&gt;<br>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt; <br>为什么这么配置spring就能用呢？因为spring对bean的加载有一个顺序，同名称的spring只会认第一次加载的bean，也就是配置文件最先配置的bean<br></code></pre></td></tr></table></figure></p><p><strong>当然了还有更简洁的配置，添加这个配置即可 mvc:annotation-driven</strong><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;<br>       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;<br>       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd<br>        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd<br>        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;<br>    &lt;context:component-scan base-package=&quot;com.lifeibai&quot;/&gt;<br>    &lt;mvc:annotation-driven/&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_16</title>
      <link href="/2018/10/23/spring-annotation-day-16/"/>
      <url>/2018/10/23/spring-annotation-day-16/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring容器的创建过程</strong></p><p>今天，我们来统一学习一下，Spring容器的整个创建过程。</p><a id="more"></a><hr><p><strong>Spring容器的refresh()[创建刷新]</strong></p><h3 id="prepareRefresh-【刷新前的预处理】"><a href="#prepareRefresh-【刷新前的预处理】" class="headerlink" title="prepareRefresh();【刷新前的预处理】"></a>prepareRefresh();【刷新前的预处理】</h3><p>1）initPropertySources();初始化一些属性设置；子类自定义个性化的属性设置方法；<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined"> protected void initPropertySources() &#123;<br> // For subclasses: do nothing by default.<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2)  getEnvironment().validateRequiredProperties();检验属性的合法性等</p><p>3）earlyApplicationEvents = new LinkedHashSet<applicationevent>();保存容器的一些早期的事件；</applicationevent></p><h3 id="obtainFreshBeanFactory；【获取BeanFactory】"><a href="#obtainFreshBeanFactory；【获取BeanFactory】" class="headerlink" title="obtainFreshBeanFactory；【获取BeanFactory】"></a>obtainFreshBeanFactory；【获取BeanFactory】</h3><p>1）refreshBeanFactory();刷新BeanFactory<br>创建 this.beanFactory = new DefaultListableBeanFactory();<br>设置id。</p><p>2）getBeanFactory();<br>返回GenericApplicationContext创建的beanFactory对象;return this.beanFactory;</p><p>3)将创建好的BeanFactory【GenericApplicationContext】对象返回；</p><h3 id="prepareBeanFactory-beanFactory"><a href="#prepareBeanFactory-beanFactory" class="headerlink" title="prepareBeanFactory(beanFactory);"></a>prepareBeanFactory(beanFactory);</h3><p>BeanFactory的预准备工作（BeanFactory进行一些设置）</p><p>1）设置BeanFactory的类加载、支持表达式解析器····</p><p>2）添加部分BeanPostProcessor【ApplicationContextAwareProcessor】</p><p>3）设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、ResourceLoaderAware等</p><p>4）注册可以解析的自动装配：我们能直接在任何组件中自动注入：BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext。</p><p>5）添加BeanPostProcessor【ApplicationListenerDetector】</p><p>6）添加编译时Aspectj<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined"> // Detect a LoadTimeWeaver and prepare for weaving, if found.<br>if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;<br>beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));<br>// Set a temporary ClassLoader for type matching.<br>beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));<br>&#125;<br></code></pre></td></tr></table></figure></p><p>7) 给BeanFactory中注册一些能用的组件</p><p>environment【ConfigurableEnvironment】</p><p>systemProperties【Map&lt;String, Object&gt;】</p><p>systemEnvironment【Map&lt;String, Object&gt;】</p><h3 id="postProcessBeanFactory-beanFactory"><a href="#postProcessBeanFactory-beanFactory" class="headerlink" title="postProcessBeanFactory(beanFactory);"></a>postProcessBeanFactory(beanFactory);</h3><p>BeanFactory准备工作完成后进行的后置处理工作<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>子类通过覆写这个方法来在BeanFactory创建并准备完成以后做进一步的设置。</p><div style="text-align: center;"><font color="#00ffff" size="4">以上是BeanFactory的创建以及准备工作</font></div><hr><h3 id="invokeBeanFactoryPostProcessors-beanFactory"><a href="#invokeBeanFactoryPostProcessors-beanFactory" class="headerlink" title="invokeBeanFactoryPostProcessors(beanFactory);"></a>invokeBeanFactoryPostProcessors(beanFactory);</h3><p>执行BeanFactoryPostProcessor</p><p>BeanFactoryPostProcessor：BeanFactory的后置处理器。在BeanFactory标准化初始化之后执行。</p><p>两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor。</p><p>一、执行BeanFactoryPostProcessor的方法：</p><p><strong>先执行BeanDefinitionRegistryPostProcessor</strong></p><p>1）获取所有的BeanDefinitionRegistryPostProcessor  </p><p>2）先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor<br>postProcessor.postProcessBeanDefinitionRegistry(registry);</p><p>3）再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor<br>postProcessor.postProcessBeanDefinitionRegistry(registry);</p><p>4）最后执行没有实现任何优先级或者顺序接口的BeanDefinitionRegistryPostProcessor<br>postProcessor.postProcessBeanDefinitionRegistry(registry);</p><p><strong>后执行BeanFactoryPostProcessor的方法</strong></p><p>1）获取所有的BeanFactoryPostProcessor</p><p>2）先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor<br>postProcessor.postProcessBeanFactory();</p><p>3）再执行实现了Ordered顺序接口的BeanFactoryPostProcessor<br>postProcessor.postProcessBeanFactory();</p><p>4）最后执行没有实现任何优先级或者顺序接口的BeanFactoryPostProcessor<br>postProcessor.postProcessBeanFactory();</p><h3 id="registerBeanPostProcessors（BeanFactory）"><a href="#registerBeanPostProcessors（BeanFactory）" class="headerlink" title="registerBeanPostProcessors（BeanFactory）"></a>registerBeanPostProcessors（BeanFactory）</h3><p>注册BeanPostProcessor（Bean的后置处理器）【Intercept bean creation.】</p><p>不同类型的BeanPostProcessor：在Bean的创建前后的执行顺序是不同的</p><p>DestructionAwareBeanPostProcessor</p><p>InstantiationAwareBeanPostProcessor</p><p>MergedBeanDefinitionPostProcessor【internalPostProcessor】</p><p>SmartInstantiationAwareBeanPostProcessor</p><p>1）获取所有的BeanPostProcessor；后置处理器默认都可以通过PriorityOrdered、Ordered接口来执行优先级</p><p>2）先注册PriorityOrdered优先级接口的BeanPostProcessor；把每一个BeanPostProcessor添加到BeanFactory中</p><p>3）再注册Ordered</p><p>4）注册其他的没有实现任何接口的BeanPostProcessor</p><p>5）最终注册MergedBeanDefinitionPostProcessor</p><p>6）注册一个ApplicationListenerDetector；来在Bean创建后检查是否是ApplicationListener，如果是，就添加到容器中：applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</p><h3 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource();"></a>initMessageSource();</h3><p>初始化MessageSource组件，做国家化功能；消息绑定；消息解析。</p><p>1）获取BeanFactory</p><p>2）看容器中是否有id=messageSource，类型是MessageSource的组件。如果有就赋值给messageSource，如果没有就自己创建一个DelegatingMessageSource组件。</p><p>MessageSource：取出国际化配置文件中的某个key的值；能按照区域信息获取。</p><p>3）把创建好的messageSource注册到容器中，以后获取国际化配置文件时，可以自动注入MessageSource</p><h3 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster();"></a>initApplicationEventMulticaster();</h3><p>初始化事件派发器</p><p>1）获取BeanFactory</p><p>2）从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster</p><p>3）如果上一步没有配置，就创建一个SimpleApplicationEventMulticaster</p><p>4）将创建好的ApplicationEventMulticaster添加到容器中，以后其他组件直接自动注入</p><h3 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh();"></a>onRefresh();</h3><p>留给子类，重写onRefresh()方法.在容器刷新的时候自定义逻辑。</p><h3 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners();"></a>registerListeners();</h3><p>给容器中将所有项目里面的ApplicationListener注册进来</p><p>1）从容器中拿到所有的ApplicationListener组件</p><p>2）将每个监听器添加到事件派发器中：getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</p><p>3）派发之前步骤中产生的事件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;<br>this.earlyApplicationEvents = null;<br>if (earlyEventsToProcess != null) &#123;<br>for (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;<br>getApplicationEventMulticaster().multicastEvent(earlyEvent);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="finishBeanFactoryInitialization-beanFactory"><a href="#finishBeanFactoryInitialization-beanFactory" class="headerlink" title="finishBeanFactoryInitialization(beanFactory);"></a>finishBeanFactoryInitialization(beanFactory);</h3><p>初始化所有的剩下的单实例Bean对象</p><p>1）beanFactory.preInstantiateSingletons();初始化剩下的单实例Bean</p><p>1.1 获取容器中的所有Bean，依次初始化和创建对象</p><p>1.2 获取Bean的定义信息：RootBeanDefinition</p><p>1.3 Bean不是抽象的、是单实例、是懒加载<br>1.3.1 判断是不是FactoryBean；是否是实现FactoryBean接口的Bean<br>1.3.2 不是工厂Bean，就利用getBean()获取Bean对象。 </p><hr><p>1.3.2.1）getBean(beanName);ioc.getBean();</p><p>1.3.2.2) doGetBean(name,null,null,false);</p><p>1.3.2.3) 先获取缓存中保存的单实例bean。如果能获取说明这个Bean之前创建过（所有创建过的单实例Bean都会被保存起来）</p><p>1.3.2.4）缓存中获取不到，开始Bean的创建对象流程</p><p>1.3.2.5）标记当前Bean已经被创建，防止多线程下创建多个单实例Bean</p><p>1.3.2.6）获取Bean的定义信息</p><p>1.3.2.7）获取当前Bean依赖的其他Bean；如果有按照getBean()把依赖的Bean先创建出来；</p><p>1.3.2.8）启动单实例Bean的创建过程：</p><hr><p>1.3.2.8.1) createBean(beanName,mbd,args)</p><p>1.3.2.8.2) resolveBeforeInstantiation(beanName, mbdToUse);让BeanPostProcessor在Bean的创建之前执行，是InstantiationAwareBeanPostProcessor类型的后置处理器。看是否是需要创建代理对象。</p><p>先触发applyBeanPostProcessorsBeforeInstantiation：postProcessBeforeInstantiation()</p><p>如果有返回值：applyBeanPostProcessorsAfterInitialization：postProcessAfterInitialization()</p><p>1.3.2.8.3)如果前面InstantiationAwareBeanPostProcessor没有返回值，说明不需要创建代理对象。</p><p>1.3.2.8.4)Object beanInstance = doCreateBean(beanName, mbdToUse, args);创建Bean</p><hr><p>1.3.2.8.4.1) instanceWrapper = createBeanInstance(beanName, mbd, args);创建Bean对象；利用工厂方法或者构造器创建出Bean对象</p><p>1.3.2.8.4.2) applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);</p><p>1.3.2.8.4.3) 【属性赋值】populateBean(beanName, mbd, instanceWrapper);</p><hr><p>赋值之前：<br>1.3.2.8.4.3.1) InstantiationAwareBeanPostProcessor后置处理器；<br>postProcessAfterInstrantiation();</p><p>1.3.2.8.4.3.2) InstantiationAwareBeanPostProcessor后置处理器；<br>postProcessPropertyValues();</p><p>赋值之后：<br>1.3.2.8.4.3.3) 应用Bean属性的值：为属性利用setter方法等进行赋值<br>applyPropertyValues(beanName, mbd, bw, pvs);</p><p>1.3.2.8.4.4) 【Bean初始化】initializeBean(beanName, exposedObject, mbd)；</p><hr><p>1.3.2.8.4.4.1) 【执行Aware接口方法】invokeAwareMethods(beanName, bean);<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">   if (bean instanceof Aware) &#123;<br>if (bean instanceof BeanNameAware) &#123;<br>((BeanNameAware) bean).setBeanName(beanName);<br>&#125;<br>if (bean instanceof BeanClassLoaderAware) &#123;<br>((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());<br>&#125;<br>if (bean instanceof BeanFactoryAware) &#123;<br>((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>1.3.2.8.4.4.2) 【执行后置处理器初始化之前】 </p><p>applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>beanProcessor.postProcessBeforeInitialization(result, beanName);</p><p>1.3.2.8.4.4.3)【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);</p><hr><p>1.3.2.8.4.4.3.1) 是否是InitializingBean接口的实现；执行接口规定的初始化</p><p>1.3.2.8.4.4.3.2) 是否自定义初始化方法：invokeCustomInitMethod(beanName, bean, mbd);</p><hr><p>1.3.2.8.4.4.4)【执行后置处理器初始化之后】  </p><p>applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>beanProcessor.postProcessAfterInitialization(result, beanName);</p><p>1.3.2.8.4.5)【注册Bean的销毁方法】：DisposableBeanAdapter</p><p>1.3.2.8.5）将创建的Bean添加到缓存中singletonObjects；<br>ioc容器就是这些Map：很多的Map里面保存了单实例Bean，环境信息····</p><p>所有的Bean都利用getBean()创建完后：<br> 检查所有的Bean是否是SmartInitializingSingleton接口类型；如果是，就执行afterSingletonsInstantion()方法</p><h3 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh();"></a>finishRefresh();</h3><p>完成BeanFactory的初始化创建工作；IoC容器就创建完了。</p><p>1）initLifecycleProcessor();初始化和生命周期有关的后置处理器：LifecycleProcessor</p><p>默认从容器中找是否是lifecycleProcessor的组件；如果没有，创建一个默认的 new DefaultLifecycleProcessor()；并加入到容器中。</p><p>2）getLifecycleProcessor().onRefresh();</p><p>拿到前面定义的生命周期处理器，并回调onRefresh()方法。</p><p>3）publishEvent(new ContextRefreshedEvent(this));发布容器刷新完成事件。</p><p>4）LiveBeansView.registerApplicationContext(this);</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1）<strong>Spring容器在启动的时候，先会保存所有注册进来的Bean定义信息。</strong></p><p>1.1 xml注册的bean；<bean></bean></p><p>1.2 注解注册Bean:@Bean、@Service、@Component、XXX</p><p>2）<strong>Spring容器会在合适的时候创建这些Bean</strong></p><p>2.1 用到这个bean的时候，利用getBean创建bean；创建好以后保存在容器中；</p><p>2.2 统一创建剩下的所有单实例bean；finishBeanFactoryInitialization(beanFactory);</p><p>3）<strong>后置处理器</strong></p><p>每个bean创建完后，都会使用各种后置处理器进行处理；来增强bean的功能；  </p><p>AutowiredAnnotationBeanPostProcessor：处理自动注入</p><p>AnnotationAwareAspectJAutoProxyCreator：来做AOP功能</p><p>XXX····</p><p>增强的功能注解：</p><p>AsyncAnnotationBeanPostProcessor</p><p>4）<strong>事件驱动模型：</strong></p><p>ApplicationListener：事件监听器</p><p>ApplicationEventMulticaster：事件派发</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_15</title>
      <link href="/2018/10/22/spring-annotation-day-15/"/>
      <url>/2018/10/22/spring-annotation-day-15/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong> </p><p>今天，来讲解其他的扩展原理，帮助大家学习其他的小知识点<br><a id="more"></a></p><h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>BeanPostProcessor：bean的后置处理器，bean创建对象初始化前后进行拦截工作的。  </p><p>BeanFactoryPostProcessor：BeanFactory的后置处理器，在BeanFactory标准初始化之后调用，来定制和修改BeanFactory的内容，所有的Bean的定义已经保存加载到BeanFactory，<strong>但是bean的实例还没有创建</strong>。</p><h4 id="创建ExConfig配置类："><a href="#创建ExConfig配置类：" class="headerlink" title="创建ExConfig配置类："></a>创建ExConfig配置类：</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(&quot;com.liuzhuo.ext&quot;)<br>public class ExtConfig &#123;<br><br>    @Bean<br>    public Blue blue() &#123;<br>        return new Blue();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建自定义的BeanFactoryPostProcessor："><a href="#创建自定义的BeanFactoryPostProcessor：" class="headerlink" title="创建自定义的BeanFactoryPostProcessor："></a>创建自定义的BeanFactoryPostProcessor：</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;<br>    /**<br>     * @param beanFactory<br>     * @throws BeansException<br>     * 在BeanFactory标准初始化之后调用，来定制和修改BeanFactory的内容，<br>     * 此时，所有的bean的定义信息已经保存到BeanFactory，但是Bean还没有创建<br>     */<br>    @Override<br>    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;<br><br>        System.out.println(&quot;postProcessBeanFactory·······&quot;);<br><br>        int count = beanFactory.getBeanDefinitionCount();<br>        String[] names = beanFactory.getBeanDefinitionNames();<br>        for (String name : names) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建新的测试类："><a href="#创建新的测试类：" class="headerlink" title="创建新的测试类："></a>创建新的测试类：</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IoCTest_EXT &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ExtConfig.class);<br>        applicationContext.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运行："><a href="#运行：" class="headerlink" title="运行："></a>运行：</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">postProcessBeanFactory·······<br>org.springframework.context.annotation.internalConfigurationAnnotationProcessor<br>org.springframework.context.annotation.internalAutowiredAnnotationProcessor<br>org.springframework.context.annotation.internalRequiredAnnotationProcessor<br>org.springframework.context.annotation.internalCommonAnnotationProcessor<br>org.springframework.context.event.internalEventListenerProcessor<br>org.springframework.context.event.internalEventListenerFactory<br>extConfig<br>myBeanFactoryPostProcessor<br>blue<br></code></pre></td></tr></table></figure><p><strong>能看到，我们获取了所有的BeanFactory中定义的bean了，但是还没有创建bean的实例对象</strong>。</p><h4 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h4><p>给MyBeanFactoryPostProcessor中的postProcessBeanFactory方法加上断点，并运行。</p><p>过程：<br>1）加载容器。<br>2）refresh();刷新容器<br>3）invokeBeanFactoryPostProcessors(beanFactory);<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>public void refresh() throws BeansException, IllegalStateException &#123;<br>    <br>    try &#123;<br>// Allows post-processing of the bean factory in context subclasses.<br>postProcessBeanFactory(beanFactory);<br><br>// Invoke factory processors registered as beans in the context.<br>invokeBeanFactoryPostProcessors(beanFactory);<br><br>// Register bean processors that intercept bean creation.<br>registerBeanPostProcessors(beanFactory);<br><br>// Initialize message source for this context.<br>initMessageSource();<br><br>// Initialize event multicaster for this context.<br>initApplicationEventMulticaster();<br><br>// Initialize other special beans in specific context subclasses.<br>onRefresh();<br><br>// Check for listener beans and register them.<br>registerListeners();<br><br>// Instantiate all remaining (non-lazy-init) singletons.<br>finishBeanFactoryInitialization(beanFactory);<br><br>// Last step: publish corresponding event.<br>finishRefresh();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>能发现，invokeBeanFactoryPostProcessors(beanFactory);是在finishBeanFactoryInitialization(beanFactory);方法之前的，就说明了BeanFactoryPostProcessor是在bean的实例化之前的，是在BeanFactory实例化之后的。</p><hr><h3 id="BeanDefinitionRegisterPostProcessor"><a href="#BeanDefinitionRegisterPostProcessor" class="headerlink" title="BeanDefinitionRegisterPostProcessor"></a>BeanDefinitionRegisterPostProcessor</h3><p>BeanDefinitionRegisterPostProcessor extends BeanFactoryPostProcessor</p><p>在所有bean定义信息将要被加载，bean实例还未创建。</p><p>优先于BeanFactoryPostProcessor执行<br>利用BeanDefinitionRegisterPostProcessor给容器中再额外添加一些组件。</p><p>原理：<br>1）ioc创建对象<br>2）refresh() -&gt; invokeBeanFactoryPostProcessors(beanFactory);<br>3) 从容器中获取所有的BeanDefinitionRegisterPostProcessor组件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1)依次触发所有的postProcessorBeanDefinitionRegistry()方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)再次触发postProcessorBeanFactory()方法的BeanFactoryPostProcessor；<br>4）再来从容器中找到BeanFactoryPostProcessor组件；然后依次触发postProcessorBeanFactory()方法</p><h4 id="创建MyBeanDefinitionRegisterPostProcessor类："><a href="#创建MyBeanDefinitionRegisterPostProcessor类：" class="headerlink" title="创建MyBeanDefinitionRegisterPostProcessor类："></a>创建MyBeanDefinitionRegisterPostProcessor类：</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class MyBeanDefinitionRegisterPostProcessor implements BeanDefinitionRegistryPostProcessor &#123;<br><br>    //先执行<br>    @Override<br>    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;<br>        System.out.println(&quot;postProcessBeanDefinitionRegistry······&quot;);<br><br>        int count = registry.getBeanDefinitionCount();<br>        System.out.println(&quot;容器中注册的bean的个数(1)：&quot; + count);<br><br>        //还能注册新的bean组件<br>        RootBeanDefinition beanDefinition = new RootBeanDefinition(Blue.class);<br>        registry.registerBeanDefinition(&quot;hello&quot;, beanDefinition);<br>    &#125;<br><br>    //后执行<br>    @Override<br>    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;<br><br>        System.out.println(&quot;postProcessBeanFactory··········&quot;);<br>        int count = beanFactory.getBeanDefinitionCount();<br>        System.out.println(&quot;容器中注册的bean的个数(2)：&quot; + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运行测试类"><a href="#运行测试类" class="headerlink" title="运行测试类:"></a>运行测试类:</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 22, 2018 11:32:15 上午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 11:32:15 CST 2018]; root of context hierarchy<br>postProcessBeanDefinitionRegistry······<br>容器中注册的bean的个数(1)：10<br>postProcessBeanFactory··········<br>容器中注册的bean的个数(2)：11<br><br>十月 22, 2018 11:32:15 上午 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &lt;init&gt;<br>信息: JSR-330 &apos;javax.inject.Inject&apos; annotation found and supported for autowiring<br>postProcessBeanFactory·······<br>org.springframework.context.annotation.internalConfigurationAnnotationProcessor<br>org.springframework.context.annotation.internalAutowiredAnnotationProcessor<br>org.springframework.context.annotation.internalRequiredAnnotationProcessor<br>org.springframework.context.annotation.internalCommonAnnotationProcessor<br>org.springframework.context.event.internalEventListenerProcessor<br>org.springframework.context.event.internalEventListenerFactory<br>extConfig<br>myBeanDefinitionRegisterPostProcessor<br>myBeanFactoryPostProcessor<br>blue<br>hello<br><br>十月 22, 2018 11:32:15 上午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 11:32:15 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure><p>能发现<br>1）首先执行BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法<br>2）再执行BeanDefinitionRegistryPostProcessor的postProcessBeanFactory()方法<br>3）最后执行BeanFactoryPostProcessor的postProcessBeanFactory()方法</p><h4 id="调试-原理"><a href="#调试-原理" class="headerlink" title="调试(原理)"></a>调试(原理)</h4><p>给MyBeanDefinitionRegisterPostProcessor的postProcessBeanDefinitionRegistry()方法打上断点，并debug。</p><p>1）加载容器<br>2）refresh();刷新容器<br>3）invokeBeanFactoryPostProcessors(beanFactory);和BeanFactoryPostProcessor的流程一样<br>4）invokeBeanFactoryPostProcessors()</p><p>在invokeBeanFactoryPostProcessors()方法中，可以看到<br>1）首先获取所有的BeanDefinitionRegistryPostProcessor的定义信息<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">String[] postProcessorNames =<br>beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);<br>for (String ppName : postProcessorNames) &#123;<br>if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br>currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br>processedBeans.add(ppName);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2）然后调用invokeBeanDefinitionRegistryPostProcessors()方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">private static void invokeBeanDefinitionRegistryPostProcessors(<br>Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry) &#123;<br><br>for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;<br>postProcessor.postProcessBeanDefinitionRegistry(registry);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 再调用invokeBeanFactoryPostProcessors：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">private static void invokeBeanFactoryPostProcessors(<br>Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory) &#123;<br><br>for (BeanFactoryPostProcessor postProcessor : postProcessors) &#123;<br>postProcessor.postProcessBeanFactory(beanFactory);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 获取所有的BeanFactoryPostProcessor的定义信息<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">String[] postProcessorNames =<br>beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);<br></code></pre></td></tr></table></figure></p><p>5）调用invokeBeanFactoryPostProcessors：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">private static void invokeBeanFactoryPostProcessors(<br>Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory) &#123;<br><br>for (BeanFactoryPostProcessor postProcessor : postProcessors) &#123;<br>postProcessor.postProcessBeanFactory(beanFactory);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><h3 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener:"></a>ApplicationListener:</h3><p>监听容器中发布的事件。事件驱动模型开发。</p><p>步骤：</p><p>1）写一个监听器(ApplicationListener实现类)来监听某个事件(ApplicationEvent及其子类)</p><p>2) 把监听器加入到容器中</p><p>3）只要容器中有相关事件的发布，我们就能监听到这个事件</p><p>4）发布一个事件: applicationContext.publishEvent();</p><h4 id="编写一个MyApplicationListener"><a href="#编写一个MyApplicationListener" class="headerlink" title="编写一个MyApplicationListener"></a>编写一个MyApplicationListener</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class MyApplicationListener implements ApplicationListener&lt;ApplicationEvent&gt; &#123;<br>    @Override<br>    public void onApplicationEvent(ApplicationEvent event) &#123;<br>        System.out.println(&quot;监听:&quot; + event);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运行测试类："><a href="#运行测试类：" class="headerlink" title="运行测试类："></a>运行测试类：</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 22, 2018 8:42:11 下午 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &lt;init&gt;<br>信息: JSR-330 &apos;javax.inject.Inject&apos; annotation found and supported for autowiring<br>监听:org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:42:11 CST 2018]; root of context hierarchy]<br><br>十月 22, 2018 8:42:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:42:11 CST 2018]; root of context hierarchy<br>监听:org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:42:11 CST 2018]; root of context hierarchy]<br></code></pre></td></tr></table></figure><p>说明容器，为我们发布了两个事件：ContextRefreshedEvent 和 ContextClosedEvent</p><h4 id="发布自己的事件"><a href="#发布自己的事件" class="headerlink" title="发布自己的事件"></a>发布自己的事件</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ExtConfig.class);<br><br>        applicationContext.publishEvent(new ApplicationEvent(new String(&quot;自定义事件&quot;)) &#123;<br>        &#125;);<br><br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">监听:org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:47:38 CST 2018]; root of context hierarchy]<br>监听:com.liuzhuo.test.IoCTest_EXT$1[source=自定义事件]<br>监听:org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:47:38 CST 2018]; root of context hierarchy]<br></code></pre></td></tr></table></figure></p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>1）初始化容器；refresh();</p><p>2）finishRefresh();  // Last step: publish corresponding event.</p><p>3）publishEvent(new ContextRefreshedEvent(this));发布事件</p><p>4）getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);获取派发器</p><p>5）获取所有的ApplicationListener：for (final ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type))</p><p>6）如果有Executor，可以支持使用Executor进行异步派发，否则，使用同步方式直接执行invokeListener(listener, event);</p><p>7）doInvokeListener(listener, event);回调listener.onApplicationEvent(event);</p><p>我们这里的三个事件：  </p><p>1）finishRefresh();容器刷新完成后，执行ContextRefreshedEvent事件。</p><p>2）自己发布的事件</p><p>3）容器关闭会发布ContextClosedEvent事件</p><hr><p>事件派发器(EventMulticaster)：</p><p>1）容器创建对象；refresh();</p><p>2）initApplicationEventMulticaster();初始化事件派发器</p><p>3）先去查看容器中是否有id=“applicationEventMulticaster”组件，如果有直接使用，没有的话，new SimpleApplicationEventMulticaster()组件。并且加入到容器中。我们就可以在其他组件要派发事件时，自动注入这个applicationEventMulticaster组件。</p><hr><p>容器中有哪些监听器：</p><p>1）容器创建对象；refresh();</p><p>2）registerListeners(); //注册监听器<br>从容器中拿到所有的监听器，把它们注册到applicationEventMulticaster中。<br>String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);<br>getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</p><h3 id="EventListener"><a href="#EventListener" class="headerlink" title="@EventListener"></a>@EventListener</h3><p>@EventListener注解，可以使普通类的普通方法来监听事件，不用去实现ApplicationEvent接口。</p><p>1）在com.liuzhuo.ext包下，创建UserService类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class UserService &#123;<br><br>    @EventListener(value = &#123;ApplicationEvent.class&#125;)<br>    public void listen(ApplicationEvent event) &#123;<br>        System.out.println(&quot;UserService监听:&quot; + event);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 运行IoCTest_EXT测试类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">UserService监听:org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Tue Oct 23 09:52:08 CST 2018]; root of context hierarchy]<br>监听:org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Tue Oct 23 09:52:08 CST 2018]; root of context hierarchy]<br>UserService监听:com.liuzhuo.test.IoCTest_EXT$1[source=自定义事件]<br>监听:com.liuzhuo.test.IoCTest_EXT$1[source=自定义事件]<br>UserService监听:org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Tue Oct 23 09:52:08 CST 2018]; root of context hierarchy]<br>监听:org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Tue Oct 23 09:52:08 CST 2018]; root of context hierarchy]<br></code></pre></td></tr></table></figure></p><p>3) 原理：</p><p>@EventListener使用EventListenerMethodProcessor处理器来完成的<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">* @author Stephane Nicoll<br> * @since 4.2<br> * @see EventListenerMethodProcessor<br> */<br>@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>public @interface EventListener<br></code></pre></td></tr></table></figure></p><p>点击EventListenerMethodProcessor处理器：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class EventListenerMethodProcessor implements SmartInitializingSingleton, ApplicationContextAware<br></code></pre></td></tr></table></figure></p><p>实现了SmartInitializingSingleton接口，所有重点是SmartInitializingSingleton接口。</p><p>点击SmartInitializingSingleton接口：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public interface SmartInitializingSingleton &#123;<br><br>/**<br> * Invoked right at the end of the singleton pre-instantiation phase,<br> * with a guarantee that all regular singleton beans have been created<br> * already. &#123;@link ListableBeanFactory#getBeansOfType&#125; calls within<br> * this method won&apos;t trigger accidental side effects during bootstrap.<br> * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; This callback won&apos;t be triggered for singleton beans<br> * lazily initialized on demand after &#123;@link BeanFactory&#125; bootstrap,<br> * and not for any other bean scope either. Carefully use it for beans<br> * with the intended bootstrap semantics only.<br> */<br>void afterSingletonsInstantiated();<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>其中有一个方法：afterSingletonsInstantiated(); 该方法是在所有的单实例初始化完成后才调用的。</p><p>调试：<br>给UserService类打上断点，并debug。</p><p>1）ioc容器创建对象；refresh();刷新容器</p><p>2）finishBeanFactoryInitialization(beanFactory)；初始化剩下的单实例bean</p><p>3）先创建所有的单实例bean；getBean();</p><p>4) 获取所有创建好的单实例bean，判断是否是SmartInitializingSingleton类型的，如果是就调用afterSingletonsInstantiated()方法</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_14</title>
      <link href="/2018/10/20/spring-annotation-day-14/"/>
      <url>/2018/10/20/spring-annotation-day-14/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong> </p><p>今天来学习Spring的声明式事务。</p><a id="more"></a><h3 id="不使用事务"><a href="#不使用事务" class="headerlink" title="不使用事务"></a>不使用事务</h3><p>环境搭建</p><p>1）导入相关依赖</p><p>数据源、数据驱动、Spring-jdbc模块.<br>数据源、数据驱动之前已经导入过，现在只需要Spring-jdbc模块.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;<br>    &lt;version&gt;5.1.1.RELEASE&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>2）创建com.liuzhuo.tx包，并创建TxConfig类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(&quot;com.liuzhuo.tx&quot;)<br>public class TxConfig &#123;<br><br>    //c3p0的数据源<br>    @Bean<br>    public DataSource dataSource() throws Exception &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(&quot;root&quot;);<br>        dataSource.setPassword(&quot;123456&quot;);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8&quot;);<br>        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);<br>        return dataSource;<br>    &#125;<br><br>    //注入jdbcTemplate模板<br>    @Bean<br>    public JdbcTemplate jdbcTemplate() throws Exception &#123;<br>        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource());<br>        return jdbcTemplate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>注意，这里的数据链接url，必须加上?serverTimezone=GMT%2B8，这是在使用MySQL 8.0以上版本时候必须加上的，否则会出现时区问题！！！！</strong></p><p>3）在com.liuzhuo.tx包下，创建UserService和UserDao类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class UserService &#123;<br><br>    @Autowired<br>    private UserDao userDao;<br><br>    public void insertUser()&#123;<br>        userDao.insert();<br>        System.out.println(&quot;插入成功!!!!&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Repository<br>public class UserDao &#123;<br><br>    @Autowired<br>    private JdbcTemplate jdbcTemplate;<br><br>    public void insert() &#123;<br>        String sql = &quot;insert into tbl_user(username,age) VALUES(?,?);&quot;;<br>        String username = UUID.randomUUID().toString().substring(0, 4);<br>        int age = 16;<br>        jdbcTemplate.update(sql, username, age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4) 创建新的测试类IoCTest_TX：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IoCTest_TX &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(TxConfig.class);<br><br>        UserService userService = applicationContext.getBean(UserService.class);<br>        userService.insertUser();<br><br>        applicationContext.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5) 运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 20, 2018 10:42:43 上午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Sat Oct 20 10:42:43 CST 2018]; root of context hierarchy<br>十月 20, 2018 10:42:43 上午 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &lt;init&gt;<br>信息: JSR-330 &apos;javax.inject.Inject&apos; annotation found and supported for autowiring<br>十月 20, 2018 10:42:43 上午 com.mchange.v2.log.MLog <br>信息: MLog clients using java 1.4+ standard logging.<br>十月 20, 2018 10:42:44 上午 com.mchange.v2.c3p0.C3P0Registry <br>信息: Initializing c3p0-0.9.5.2 [built 08-December-2015 22:06:04 -0800; debug? true; trace: 10]<br>十月 20, 2018 10:42:44 上午 com.mchange.v2.c3p0.impl.AbstractPoolBackedDataSource <br>信息: Initializing c3p0 pool... com.mchange.v2.c3p0.ComboPooledDataSource [ acquireIncrement -&gt; 3, acquireRetryAttempts -&gt; 30, acquireRetryDelay -&gt; 1000, autoCommitOnClose -&gt; false, automaticTestTable -&gt; null, breakAfterAcquireFailure -&gt; false, checkoutTimeout -&gt; 0, connectionCustomizerClassName -&gt; null, connectionTesterClassName -&gt; com.mchange.v2.c3p0.impl.DefaultConnectionTester, contextClassLoaderSource -&gt; caller, dataSourceName -&gt; 2s4fkk9y13rx1eqqia0s|69b2283a, debugUnreturnedConnectionStackTraces -&gt; false, description -&gt; null, driverClass -&gt; com.mysql.jdbc.Driver, extensions -&gt; &#123;&#125;, factoryClassLocation -&gt; null, forceIgnoreUnresolvedTransactions -&gt; false, forceSynchronousCheckins -&gt; false, forceUseNamedDriverClass -&gt; false, identityToken -&gt; 2s4fkk9y13rx1eqqia0s|69b2283a, idleConnectionTestPeriod -&gt; 0, initialPoolSize -&gt; 3, jdbcUrl -&gt; jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8, maxAdministrativeTaskTime -&gt; 0, maxConnectionAge -&gt; 0, maxIdleTime -&gt; 0, maxIdleTimeExcessConnections -&gt; 0, maxPoolSize -&gt; 15, maxStatements -&gt; 0, maxStatementsPerConnection -&gt; 0, minPoolSize -&gt; 3, numHelperThreads -&gt; 3, preferredTestQuery -&gt; null, privilegeSpawnedThreads -&gt; false, properties -&gt; &#123;user=******, password=******&#125;, propertyCycle -&gt; 0, statementCacheNumDeferredCloseThreads -&gt; 0, testConnectionOnCheckin -&gt; false, testConnectionOnCheckout -&gt; false, unreturnedConnectionTimeout -&gt; 0, userOverrides -&gt; &#123;&#125;, usesTraditionalReflectiveProxies -&gt; false ]<br>Loading class `com.mysql.jdbc.Driver&apos;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&apos;. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.<br>Sat Oct 20 10:42:45 CST 2018 WARN: Establishing SSL connection without server&apos;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&apos;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &apos;false&apos;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.<br>Sat Oct 20 10:42:45 CST 2018 WARN: Establishing SSL connection without server&apos;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&apos;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &apos;false&apos;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.<br>Sat Oct 20 10:42:45 CST 2018 WARN: Establishing SSL connection without server&apos;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&apos;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &apos;false&apos;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.<br>插入成功!!!!<br>十月 20, 2018 10:42:45 上午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Sat Oct 20 10:42:43 CST 2018]; root of context hierarchy<br></code></pre></td></tr></table></figure></p><p>看到插入成功，打开数据库也能发现数据库中多了一条新的记录。</p><p>ps：以上操作是建立在本地存在数据库test，和一个表，表的字段有id自增，username用户名，age用户的年龄，这里就不详细描述数据库的创建过程了。</p><hr><p>6）修改UserService类：<br>添加 int res = 1 / 0;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class UserService &#123;<br><br>    @Autowired<br>    private UserDao userDao;<br><br>    public void insertUser() &#123;<br>        userDao.insert();<br>        System.out.println(&quot;插入成功!!!!&quot;);<br>        int res = 1 / 0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>7）再次运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">插入成功!!!!<br><br>java.lang.ArithmeticException: / by zero<br><br>at com.liuzhuo.tx.UserService.insertUser(UserService.java:21)<br>at com.liuzhuo.test.IoCTest_TX.test01(IoCTest_TX.java:23)<br></code></pre></td></tr></table></figure></p><p><strong>会出现异常。打开数据库，发现还是会添加一条新的记录，这是因为没有添加事务的原因。</strong></p><h3 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h3><p>1）修改UserService类：<br>添加@Transactional注解<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class UserService &#123;<br><br>    @Autowired<br>    private UserDao userDao;<br><br>    @Transactional<br>    public void insertUser() &#123;<br>        userDao.insert();<br>        System.out.println(&quot;插入成功!!!!&quot;);<br>        int res = 1 / 0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">插入成功!!!!<br><br>java.lang.ArithmeticException: / by zero<br></code></pre></td></tr></table></figure></p><p>出现ArithmeticException异常，打开数据库，发现还是会添加一条数据，说明事务还没有添加上去，<strong>因为没有开启注解时事务</strong>。</p><p>3）修改配置类<br>添加@EnableTransactionManagement注解<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(&quot;com.liuzhuo.tx&quot;)<br>@EnableTransactionManagement<br>public class TxConfig<br></code></pre></td></tr></table></figure></p><p>4) 运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">No qualifying bean of type &apos;org.springframework.transaction.PlatformTransactionManager&apos; available<br></code></pre></td></tr></table></figure></p><p>发现出现没有PlatformTransactionManager这个组件的异常，此时虽然数据库没有添加一条数据，但是是出现了其他异常，而不是出现ArithmeticException异常。</p><p>出现没有PlatformTransactionManager这个组件异常，说明我们还需要配置事务管理器。</p><p>5) 添加事务管理器<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//添加事务管理器<br> @Bean<br> public PlatformTransactionManager transactionManager() throws Exception &#123;<br>     return new DataSourceTransactionManager(dataSource());<br> &#125;<br></code></pre></td></tr></table></figure></p><p>6) 运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">插入成功!!!!<br><br>java.lang.ArithmeticException: / by zero<br></code></pre></td></tr></table></figure></p><p>出现了ArithmeticException异常，打开数据库，发现也没有添加新的一条记录，说明事务起作用了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用事务的步骤：</p><ol><li>添加相关的依赖(Spring-jdbc)</li><li>配置数据源、事务管理器(PlatformTransactionManager)</li><li>开始注解式事务(@EnableTransactionManagement)</li><li>给相关的方法添加@Transactional注解</li></ol><hr><h3 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h3><p>点击@EnableTransactionManagement注解：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Target(&#123;ElementType.TYPE&#125;)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>@Import(&#123;TransactionManagementConfigurationSelector.class&#125;)<br>public @interface EnableTransactionManagement &#123;<br>    boolean proxyTargetClass() default false;<br><br>    AdviceMode mode() default AdviceMode.PROXY;<br><br>    int order() default 2147483647;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>@Import({TransactionManagementConfigurationSelector.class})<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>protected String[] selectImports(AdviceMode adviceMode) &#123;<br>switch (adviceMode) &#123;<br>case PROXY:<br>return new String[] &#123;AutoProxyRegistrar.class.getName(),<br>ProxyTransactionManagementConfiguration.class.getName()&#125;;<br>case ASPECTJ:<br>return new String[] &#123;determineTransactionAspectClass()&#125;;<br>default:<br>return null;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>会导入AutoProxyRegistrar和ProxyTransactionManagementConfiguration两个组件。</p><p>1）AutoProxyRegistrar会给容器注入InfrastructureAdvisorAutoProxyCreator组件（也是一个后置处理器）。</p><p>InfrastructureAdvisorAutoProxyCreator组件利用后置处理器机制在对象创建时，包装对象，返回一个代理对象（增强器），代理对象执行方法利用拦截器链执行。</p><p>2）ProxyTransactionManagementConfiguration</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给容器注入事务增强器<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务增强器要用事务注解的信息<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务拦截器：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TransactionInterceptor：保存了事务属性信息，事务管理器<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是一个MethodInterceptor<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在目标方法执行的时候：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行拦截器链：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务拦截器：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先获取事务相关的属性<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再获取事务管理器<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行目标方法：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果异常，获取事务管理器，回滚<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果正常，利用事务管理器，提交事务</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring4配置文件详解</title>
      <link href="/2018/10/19/Spring4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/10/19/Spring4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>总结Spring4中的各种配置文件的信息。</p><a id="more"></a><p>欢迎大家补充，完善各种配置信息。</p><p>好的习惯，将会伴随你的一生。</p><p>开始今天的主题！！！</p><h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><hr><p>基本的加载properties配置文件</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;context:property-placeholder location=&quot;classpath*:/appConfig.properties&quot; /&gt;<br></code></pre></td></tr></table></figure><h4 id="JNDI方式"><a href="#JNDI方式" class="headerlink" title="JNDI方式"></a>JNDI方式</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;/jdbc/mysqlDS&quot; resource-ref=&quot;true&quot;/&gt;<br></code></pre></td></tr></table></figure><p>jndi-name：指定JNDI中资源名称</p><p>resource-ref：如果应用程序运行在java应用程序服务器中，值设为true，这样jndi-name会自动加上java:comp/env/前缀</p><h4 id="数据连接池方式"><a href="#数据连接池方式" class="headerlink" title="数据连接池方式"></a>数据连接池方式</h4><h5 id="DBCP连接池："><a href="#DBCP连接池：" class="headerlink" title="DBCP连接池："></a>DBCP连接池：</h5><p>使用：org.apache.commons.dbcp.BasicDataSource进行配置<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;<br><br>  &lt;!-- 【必须】  数据库驱动--&gt;<br>  &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;<br><br>  &lt;!-- 【必须】 数据库连接地址 --&gt;<br>  &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;<br><br>  &lt;!-- 【必须】 数据库用户名 --&gt;<br>  &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;<br><br>  &lt;!-- 【必须】 数据库密码 --&gt;<br>  &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;<br><br>  &lt;!-- 可选 启动时创建的连接数 --&gt;<br>  &lt;property name=&quot;initialSize&quot; value=&quot;5&quot;/&gt;<br><br>  &lt;!-- 可选 同时可从池中分配的最多连接数，0无限制 --&gt;<br>  &lt;property name=&quot;maxActive&quot; value=&quot;10&quot;/&gt;<br><br>  &lt;!-- 可选 池中不会被释放的最多空闲连接数 0无限制 --&gt;<br>  &lt;property name=&quot;maxIdle&quot; value=&quot;&quot;/&gt;<br><br>  &lt;!-- 可选 同时能从语句池中分配的预处理语句最大值，0无限制 --&gt;<br>  &lt;property name=&quot;maxOpenPreparedStatement&quot; value=&quot;100&quot;/&gt;<br><br>  &lt;!-- 可选 抛异常前池等待连接回收最大时间（当无可用连接），-1无限等待 --&gt;<br>  &lt;property name=&quot;maxWait&quot; value=&quot;1000&quot;/&gt;<br><br>  &lt;!-- 可选 连接在池中保持空闲而不被回收的最大时间 --&gt;<br>  &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;2000&quot;/&gt;<br><br>  &lt;!-- 可选 不创建新连接情况下池中保持空闲的最小连接数 --&gt;<br>  &lt;property name=&quot;minIdle&quot; value=&quot;2&quot;/&gt;<br><br>  &lt;!-- 可选 布尔值，是否对预处理语句进行池管理 --&gt;<br>  &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><h5 id="C3P0连接池："><a href="#C3P0连接池：" class="headerlink" title="C3P0连接池："></a>C3P0连接池：</h5><p>使用：com.mchange.v2.c3p0.ComboPooledDataSource进行配置<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; destroy-method=&quot;close&quot;&gt;<br><br>  &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;<br>  &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;<br>  &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;<br>  &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;<br>  <br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><h5 id="alibaba-DRUID连接池："><a href="#alibaba-DRUID连接池：" class="headerlink" title="alibaba DRUID连接池："></a>alibaba DRUID连接池：</h5><p>使用：com.alibaba.druid.pool.DruidDataSource进行配置<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;  <br><br>   &lt;!-- 基本属性 url、user、password --&gt; <br>   &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc_url&#125;&quot; /&gt; <br>   &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc_user&#125;&quot; /&gt; <br>   &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc_password&#125;&quot; /&gt; <br>   &lt;!-- 配置初始化大小、最小、最大 --&gt; <br>   &lt;property name=&quot;initialSize&quot; value=&quot;1&quot; /&gt; <br>   &lt;property name=&quot;minIdle&quot; value=&quot;1&quot; /&gt;  <br>   &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt; <br>   &lt;!-- 配置获取连接等待超时的时间 --&gt; <br>   &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt; <br>   &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; <br>   &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot; /&gt; <br>   &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; <br>   &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;300000&quot; /&gt; <br>   &lt;property name=&quot;validationQuery&quot; value=&quot;SELECT &apos;x&apos;&quot; /&gt; <br>   &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; <br>   &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot; /&gt; <br>   &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot; /&gt; <br>   &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt; <br>   &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot; /&gt; <br>   &lt;property name=&quot;maxPoolPreparedStatementPerConnectionSize&quot; value=&quot;20&quot; /&gt; <br>   &lt;!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 --&gt; <br>   &lt;property name=&quot;filters&quot; value=&quot;stat&quot; /&gt;  <br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><h4 id="JDBC驱动的数据源"><a href="#JDBC驱动的数据源" class="headerlink" title="JDBC驱动的数据源"></a>JDBC驱动的数据源</h4><p>使用：</p><p>org.springframework.jdbc.datasource.SingleConnectionDataSource【每个链接请求会返回同一个连接，不推荐】</p><p>org.springframework.jdbc.datasource.DriverManagerDataSource进行配置<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;<br><br>  &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;<br>  &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;<br>  &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;<br>  &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><hr><h4 id="spring-JDBC模板"><a href="#spring-JDBC模板" class="headerlink" title="spring JDBC模板"></a>spring JDBC模板</h4><p>模板类选择：</p><p>JdbcTemplate：提供最简单的数据访问等功能。</p><p>NamedParameterJdbcTemplate：通过该模板，可以把参数作为查询的条件传入方法中。</p><p>SimpleJdbcTemplate（推荐）：结合了一些自动装箱等功能，2.5以后，整合了NamedParameterJdbcTemplate。</p><p>配置方式：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.simple.SimpleJdbcTemplate&quot;&gt;<br>  &lt;constructor-arg ref=&quot;dataSource&quot;/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><h4 id="与ORM框架集成"><a href="#与ORM框架集成" class="headerlink" title="与ORM框架集成"></a>与ORM框架集成</h4><p>主要是配置spring的Session工厂（sessionFactory），可以使用到诸如延迟加载、预先抓取、级联复杂特性。</p><p>spring对ORM框架的支持提供提供了一些附加服务：</p><p>spring声明式事务集成支持</p><p>透明的异常处理</p><p>线程安全、轻量级的模板类</p><p>DAO支持</p><p>资源管理</p><h5 id="集成Hibernate方式：-hibernate4为例"><a href="#集成Hibernate方式：-hibernate4为例" class="headerlink" title="集成Hibernate方式：[hibernate4为例]"></a>集成Hibernate方式：[hibernate4为例]</h5><p>hibernate的HBM文件配置方式（Xxx.hbm.xml)：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;&gt;<br><br>  &lt;!-- 数据源 --&gt;<br>  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;<br>  &lt;!-- 映射文件形式--&gt;<br>  &lt;property name=&quot;mappingResources&quot;&gt;<br>     &lt;list&gt;<br>        &lt;value&gt;User.hbm.xml&lt;/value&gt;<br>     &lt;/list&gt;<br>  &lt;/property&gt;<br>  &lt;!-- Hibernate属性配置 --&gt;<br>  &lt;property name=&quot;hibernateProperties&quot;&gt;<br>     &lt;props&gt;<br>         &lt;prop key=&quot;dialect&quot;&gt;<br>            org.hibernate.dialect.MySQLDialect &lt;!-- 数据库方言 --&gt;<br>         &lt;/prop&gt;<br>        &lt;!-- ……其他 --&gt;<br>     &lt;/props&gt;<br>  &lt;/property&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>代码中使用注解的方式：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;&gt;<br><br>  &lt;!-- 数据源 --&gt;<br>  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;  <br>  &lt;!-- 自动扫描实体对象 tdxy.bean的包结构中存放实体类  --&gt;<br>  &lt;property name=&quot;packagesToScan&quot; value=&quot;com.test.entity&quot;/&gt;<br>  &lt;!-- hibernate的相关属性配置 --&gt;<br>  &lt;property name=&quot;hibernateProperties&quot;&gt;<br>     &lt;value&gt;<br>        &lt;!-- 设置数据库方言 --&gt;<br>        hibernate.dialect=org.hibernate.dialect.MySQLDialect<br>        &lt;!-- 设置自动创建|更新|验证数据库表结构 --&gt;<br>        hibernate.hbm2ddl.auto=update                 <br>        &lt;!-- 是否在控制台显示sql --&gt;<br>        hibernate.show_sql=true                 <br>        &lt;!-- 是否格式化sql，优化显示 --&gt;<br>        hibernate.format_sql=true                <br>        &lt;!-- 是否开启二级缓存 --&gt;<br>        hibernate.cache.use_second_level_cache=false                <br>        &lt;!-- 是否开启查询缓存 --&gt;<br>        hibernate.cache.use_query_cache=false                <br>        &lt;!-- 数据库批量查询最大数 --&gt;<br>        hibernate.jdbc.fetch_size=50<br>        &lt;!-- 数据库批量更新、添加、删除操作最大数  --&gt;<br>        hibernate.jdbc.batch_size=50                <br>        &lt;!-- 是否自动提交事务  --&gt;<br>        hibernate.connection.autocommit=true<br>        &lt;!-- 指定hibernate在何时释放JDBC连接  --&gt;<br>        hibernate.connection.release_mode=auto<br>        &lt;!-- 创建session方式 hibernate4.x 的方式  --&gt;<br>        hibernate.current_session_context_class=org.springframework.orm.hibernate4.SpringSessionContext<br>        &lt;!-- javax.persistence.validation.mode默认情况下是auto的，就是说如果不设置的话它是会自动去你的classpath下面找一个bean-validation**包，所以把它设置为none即可  --&gt;<br>        javax.persistence.validation.mode=none            <br>     &lt;/value&gt;<br>  &lt;/property&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>针对少量实体类，还可以通过annotatedClasses属性来将应用程序中所有的持久化类以全局定名的方式明确列出：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;property name=&quot;annotatedClasses&quot;&gt;<br>  &lt;list&gt;<br>     &lt;value&gt;com.demo.entity.User&lt;/value&gt;<br>     &lt;value&gt;com.demo.entity.Blog&lt;/value&gt;<br>  &lt;/list&gt;<br>&lt;/property&gt;<br></code></pre></td></tr></table></figure></p><p><strong>推荐使用packagesToScan属性扫描包方式。</strong></p><p>【构建不依赖于spring的Hibernate代码】<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package com.demo.dao;<br><br>import org.hibernate.Session;<br>import org.hibernate.SessionFactory;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.stereotype.Repository;<br>import com.demo.entity.User;<br><br>@Repository<br>public class UserDaoImpl implements IUserDao  &#123;<br><br>  private SessionFactory sessionFactory;<br><br>  // 构造注入<br>  @Autowired<br>  public UserDaoImpl(SessionFactory sessionFactory) &#123;<br>     this.sessionFactory = sessionFactory;<br>  &#125;<br><br>  private Session currentSession()&#123;<br>     return sessionFactory.getCurrentSession();<br>  &#125;<br><br>  @Override<br>  public void addUser(User param) &#123;<br>     Session session = currentSession();<br>     session.save(param);<br>     System.out.println(&quot;Add User&quot;);<br>  &#125;<br><br>  @Override<br>  public User get(Integer id) &#123;<br>     return (User) currentSession().get(User.class, id);<br>  &#125;<br><br>  @Override<br>  public void save(User user) &#123;<br>     currentSession().update(user);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>还需配置：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;context:component-scan base-package=&quot;com.demo.dao&quot;/&gt;<br></code></pre></td></tr></table></figure></p><p>就会像扫描其他注解一样扫描带@Repository注解的类到容器中。</p><h5 id="集成MyBatis方式"><a href="#集成MyBatis方式" class="headerlink" title="集成MyBatis方式"></a>集成MyBatis方式</h5><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;<br>  p:dataSource-ref=&quot;dataSource&quot; p:configLocation=&quot;classpath:mybatis-config.xml&quot;<br>  p:mapperLocations=&quot;classpath:com/demo/dao/*.xml&quot; /&gt;<br><br>&lt;!-- spring与mybatis整合配置，扫描所有dao --&gt;<br>&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;<br>  p:basePackage=&quot;com.demo.dao&quot; p:sqlSessionFactoryBeanName=&quot;sqlSessionFactory&quot; /&gt;<br></code></pre></td></tr></table></figure><h4 id="与其他JPA集成方式"><a href="#与其他JPA集成方式" class="headerlink" title="与其他JPA集成方式"></a>与其他JPA集成方式</h4><p>配置实体管理工厂</p><p>应用程序管理类型的JPA（LocalEntityManagerFactoryBean）：它的EntityManager是由EntityManagerFactory创建的；</p><p>容器管理类型的JPA（LocalContainerEntityManagerFactoryBean）：通过PersistenceProvider的createEntityManagerFactory()方法得到，即它的EntityManagerFactory是通过PersistenceProvider的createContainerEntityManagerFactory()方法得到。</p><p>使用应用程序管理类型的JPA</p><p>绝大部分配置文件来源于名为persistence.xml的配置文件，这个文件位置必须位于类路径下的WETA-INF目录下<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;persistence version=&quot;2.0&quot;<br>     xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot;<br>     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>     xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd&quot;&gt;<br>     <br>  &lt;persistence-unit name=&quot;persistenceUnit&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;<br><br>     &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;<br><br>     &lt;properties&gt;<br>        &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.MySQL5Dialect&quot; /&gt;<br>        &lt;property name=&quot;hibernate.max_fetch_depth&quot; value=&quot;3&quot;/&gt;<br>        &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot;/&gt;<br>        &lt;property name=&quot;hibernate.jdbc.fetch_size&quot; value=&quot;18&quot;/&gt;<br>        &lt;property name=&quot;hibernate.jdbc.batch_size&quot; value=&quot;10&quot;/&gt;<br>        &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;false&quot;/&gt;<br>        &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;false&quot;/&gt;<br>     &lt;/properties&gt;<br><br>     &lt;class&gt;com.demo.entity.User&lt;/class&gt;<br>     &lt;class&gt;com.demo.entity.Blog&lt;/class&gt;<br>     &lt;!-- …… ……--&gt;<br>   &lt;/persistence-unit&gt;<br><br>&lt;/persistence&gt;<br></code></pre></td></tr></table></figure></p><p>这样在spring的配置文件中配置的信息就很少了：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;demo&quot; class=&quot;org.springframework.orm.jpa.LocalEntityManagerFactoryBean&quot;&gt;<br>  &lt;property name=&quot;persistenceUnit&quot; &gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>【TIPS】上面persistence.xml文件中的配置会出现问题：</p><p>如果每次请求EntityManagerFactory时都要定义持久化单元，代码回迅速膨胀</p><p>借助spring对JPA的支持，不再需要直接处理PersistenceProvider了，就是下面的容器管理的JPA！</p><p>使用容器管理类型的JPA</p><p>将数据源信息配置在spring的应用上下文中，而不是在persistence.xml文件中。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;emf&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;<br>  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;<br>   &lt;!-- 指定使用的是哪一个厂商的JPA实现 如Hibernate --&gt;<br>  &lt;property name=&quot;jpaVendorAdapter&quot; ref=&quot;hibernateJpaVendorAdapter&quot;/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>配置JPA实现：</p><p>可选的有：EclipseLinkJpaVendorAdapter、HibernateJpaVendorAdapter、OpenJpaVendorAdapter、TopLinkJpaVendorAdapter</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;hibernateJpaVendorAdapter&quot; class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&gt;<br>  &lt;property name=&quot;database&quot; value=&quot;MYSQL&quot;/&gt;<br>  &lt;property name=&quot;showSql&quot; value=&quot;true&quot;/&gt;<br>  &lt;property name=&quot;generateDdl&quot; value=&quot;true&quot;/&gt;<br>  &lt;property name=&quot;databasePlatform&quot; value=&quot;org.hibernate.dialect.MySQL5Dialect&quot;/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>【TIPS】database属性：属性值表示支持哪种数据库，下面Hibernate的JPA是一些支持的数据库：<br><img src="/images/20181019214107.png"></p><p><strong>【注】JNDI获取实体管理工厂：</strong></p><p>如果spring应用部署在应用服务器中，Spring可能已经创建好EntityManagerFactory并将其置于JNDI中等饭查询使用，这种情况可使用JNDI来获取对EntityManagerFactory的引用：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;jee:jndi-lookup id=&quot;emf&quot; jndi-name=&quot;persistence/testDS&quot;/&gt;<br></code></pre></td></tr></table></figure></p><p>编写基于JPA的DAO<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package com.demo.dao;<br><br>import javax.persistence.EntityManager;<br>import javax.persistence.PersistenceContext;<br>import org.springframework.stereotype.Repository;<br>import org.springframework.transaction.annotation.Transactional;<br>import com.demo.entity.User;<br><br>@Repository<br>@Transactional<br>public class JpaDao implements IUserDao &#123;<br><br>  // 注入EntityManager<br>  @PersistenceContext<br>  private EntityManager em;<br><br>  // 使用EntityManager<br>  @Override<br>  public void addUser(User param) &#123;<br>     em.persist(param);<br>  &#125;<br><br>  @Override<br>  public User get(Integer id) &#123;<br>     return em.find(User.class, id);<br>  &#125;<br><br>  @Override<br>  public void save(User user) &#123;<br>     em.merge(user);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>上面使用到了@PersistenceContext注解将EntityManager注入。</p><p>这样用需要在spring的上下文配置文件中配置一个PersistenceAnnotationBeanPostProcessor：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!-- 使用EntityManager --&gt;<br>&lt;bean class=&quot;org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor&quot;/&gt;<br></code></pre></td></tr></table></figure></p><p>以上，是如何使用JDBC、Hibernate或JPA为spring应用程序构建持久层，至于选择哪种方案完全取决于偏好.</p><h3 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h3><p>通过毁掉机制将实际事务实现从事务性代码中抽象出来。</p><h4 id="选择事务管理器"><a href="#选择事务管理器" class="headerlink" title="选择事务管理器"></a>选择事务管理器</h4><p>事务管理器结构</p><p>事务处理流程：</p><p>开始事务-&gt;绑定资源-&gt;使用资源-&gt;完成事务-&gt;释放资源</p><h5 id="JDBC事务"><a href="#JDBC事务" class="headerlink" title="JDBC事务"></a>JDBC事务</h5><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;<br>     &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>DataSourceTransactionManager通过调用java.sql.Connection来管理事务，由java.sql.Connection对象来提交、回滚事务。</p><h5 id="Hibernate事务"><a href="#Hibernate事务" class="headerlink" title="Hibernate事务"></a>Hibernate事务</h5><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;transactionManager&quot;<br>class=&quot;org.springframework.orm.hibernate4.HibernateTransactionManager&quot;&gt;<br>  &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>HibernateTransactionManager通过将事务管理的职责委托给org.hibernate.Transaction对象，org.hibernate.Transaction对象从Hibernate Session中获取，然后由Transaction对象来提交、回滚事务。</p><h5 id="JPA事务"><a href="#JPA事务" class="headerlink" title="JPA事务"></a>JPA事务</h5><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;<br>  &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>JpaTransactionManager只需要装配一个JPA实体管理工厂（EntityManagerFactory的任意实现），然后与由工厂产生的JPA EntityManager合作构建事务。</p><p>如果你还希望将事务应用于简单JDBC操作（JDBC操作使用的datasource和EntityManagerFactory使用的dataSource必须相同），那么JpaTransactionManager必须装配一个JpaDialect的实现：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;jpaDialect&quot; class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;/&gt;<br><br><br>&lt;!--然后将jpaDialect装配到transactionManager中 --&gt;<br>&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;<br>  &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;/&gt;<br>  &lt;property name=&quot;jpaDialect&quot; ref=&quot;jpaDialect&quot;/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><h5 id="JTA事务"><a href="#JTA事务" class="headerlink" title="JTA事务"></a>JTA事务</h5><p>如果前面的事务管理器不能满足需求或事物需要跨多个事务资源（两个及以上数据库），需要使用JtaTrasactionManager了：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;transactionManager&quot;<br>  class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;&gt;<br>  &lt;property name=&quot;transactionManagerName&quot; value=&quot;java:/TrasactionManager&quot;/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>JtaTransactionManager将事务委托给一个JTA的实现（java.transaction.UserTransaction和javax.transaction.TransactionManager），通过UserTransaction来操作事务。JTA规定了应用程序晕一个或多个数据源之间协调事务的标准API，transactionManagerName属性指定了要在JNDI上查找JTA事务管理器。</p><h4 id="Spring事务实现方式"><a href="#Spring事务实现方式" class="headerlink" title="Spring事务实现方式"></a>Spring事务实现方式</h4><p>1）编码事务</p><p>通过TransactionTemplate的回调机制，例如：（UserSeriveImpl.java）<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public void addUser(final User u) &#123;<br><br>  TransactionTemplate temp = new TransactionTemplate();<br>  <br>  temp.execute(new TransactionCallback&lt;Void&gt;() &#123;<br>  <br>     @Override<br>     public Void doInTransaction(TransactionStatus txtStatus) &#123;<br>          // 要执行的事务代码<br>        try &#123;<br>           userDao.save(u);<br>        &#125; catch (RuntimeException e) &#123;<br>           e.printStackTrace();<br>           txtStatus.setRollbackOnly();<br>        &#125;<br>        return null;<br>     &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>此时UserService需要如下装配：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;userSerive&quot; class=&quot;com.demo.service.UserServiceImpl&quot;&gt;<br>  &lt;property name=&quot;transactionTemplate&quot;&gt;<br>     &lt;bean class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt;<br>        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;<br>     &lt;/bean&gt;<br>  &lt;/property&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>优点：可以完全控制事务边界，精确控制事务。</p><p>缺点：侵入性的，事务控制在代码中实现，耦合度高</p><p>2）声明式事务</p><p>传播行为</p><p>传播行为回答了新的事务是该被启动还是被挂起，或者方法是否要在事务环境中运行。</p><p>事务的传播行为都在org.springframework.transaction.TransactionDefinition接口中以常量的方式定义出来。</p><p>隔离级别</p><p>隔离级别定义了一个事务可能受其他并发事务影响的程度。</p><p>隔离级别都在org.springframework.transaction.TransactionDefinition接口中以常量的方式定义出来。</p><p>只读</p><p>事务启动的时候由数据库实施的，只有针对具备启动一个新事务传播行为（PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW和PROPAGATION_NESTED）的方法来说才有意义。【tips】如果使用Hibernate，将事务声明为只读会导致flush模式被设置为FLUSH_NEVER，这会告诉hibernate避免和数据库进行不必要的对象同步，并将所有的更新延迟到事务结束。</p><p>事务超时</p><p>长时间事务会导致一些不必要的数据库资源占用。</p><p>超时时钟会在事务开始时启动，只有针对具备启动一个新事务传播行为（PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW和PROPAGATION_NESTED）的方法来说才有意义。</p><p>回滚规则</p><p>这些规则定义了哪些异常会导致事务回滚哪些不会，默认情况下，运行时异常会回滚，检查异常不回滚，但是可以声明事务遇到检查异常回滚，运行时异常不回滚。</p><p>3）Spring在XML中定义事务</p><p>需要包括beans、aop、tx命名空间。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;<br>  &lt;tx:attributes&gt;<br>     &lt;!-- 事务执行方式 REQUIRED：指定当前方法必需在事务环境中运行，<br>     如果当前有事务环境就加入当前正在执行的事务环境，<br>     如果当前没有事务，就新建一个事务。 这是默认值。 --&gt;<br>     &lt;tx:method name=&quot;create*&quot; propagation=&quot;REQUIRED&quot; /&gt;<br>     &lt;tx:method name=&quot;save*&quot;   propagation=&quot;REQUIRED&quot; /&gt;<br>     &lt;tx:method name=&quot;add*&quot;    propagation=&quot;REQUIRED&quot; /&gt;<br>     &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt;<br>     &lt;tx:method name=&quot;remove*&quot; propagation=&quot;REQUIRED&quot; /&gt;<br>     &lt;tx:method name=&quot;del*&quot;    propagation=&quot;REQUIRED&quot; /&gt;<br>     &lt;tx:method name=&quot;import*&quot; propagation=&quot;REQUIRED&quot; /&gt;<br>     &lt;!-- 指定当前方法以非事务方式执行操作，如果当前存在事务，就把当前事务挂起，等我以非事务的状态运行完，再继续原来的事务。 查询定义即可<br>        read-only=&quot;true&quot; 表示只读 --&gt;<br>     &lt;tx:method name=&quot;*&quot;       propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot; /&gt;<br>  &lt;/tx:attributes&gt;<br>&lt;/tx:advice&gt;<br></code></pre></td></tr></table></figure></p><p>其中&lt;tx:method /&gt;有很多属性用来帮助定义方法的事务策略：<br><img src="/images/20181019215056.png"></p><p>4）定义注解驱动的事务</p><p>在XML配置文件中添加：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;tx:annotation-driven/&gt;<br></code></pre></td></tr></table></figure></p><p>可通过transaction-manager属性（默认值”transactionManager”）来指定事务管理器，如：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;<br></code></pre></td></tr></table></figure></p><p><code>&lt;tx:annotation-driven/&gt;</code>告诉Spring检查上下文中所有bean并检查使用到@Transactional注解的bean。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring中无处不在的Properties</title>
      <link href="/2018/10/19/Spring%E4%B8%AD%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E7%9A%84Properties/"/>
      <url>/2018/10/19/Spring%E4%B8%AD%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E7%9A%84Properties/</url>
      
        <content type="html"><![CDATA[<p>对 Spring 里面的 Properties 不理解的开发者可能会觉得有点乱，主要是因为配置方式很多种，使用方式也很多种。</p><p>本文不是原理分析、源码分析文章，只是希望可以帮助读者更好地理解和使用 Spring Properties。</p><a id="more"></a><h3 id="Properties-的使用"><a href="#Properties-的使用" class="headerlink" title="Properties 的使用"></a>Properties 的使用</h3><p>先来看看 Properties 是怎么使用的，Spring 中常用的有以下几种使用方式：</p><h4 id="在-xml-配置文件中使用"><a href="#在-xml-配置文件中使用" class="headerlink" title="在 xml 配置文件中使用"></a>在 xml 配置文件中使用</h4><p>即自动替换 ${} 里面的值。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;xxx&quot; class=&quot;com.javadoop.Xxx&quot;&gt;<br>     &lt;property name=&quot;url&quot; value=&quot;$&#123;javadoop.jdbc.url&#125;&quot; /&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><h4 id="通过-Value-注入使用"><a href="#通过-Value-注入使用" class="headerlink" title="通过 @Value 注入使用"></a>通过 @Value 注入使用</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Value(&quot;$&#123;javadoop.jdbc.url&#125;&quot;)<br>private String url;<br></code></pre></td></tr></table></figure><h4 id="通过-Environment-获取"><a href="#通过-Environment-获取" class="headerlink" title="通过 Environment 获取"></a>通过 Environment 获取</h4><p>此法有需要注意的地方。并不是所有的配置方式都支持通过 Environment 接口来获取属性值，亲测只有使用注解 @PropertySource 的时候可以用，否则会得到 null，至于怎么配置，下面马上就会说。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Autowired<br>private Environment env;<br><br>public String getUrl() &#123;<br>   return env.getProperty(&quot;javadoop.jdbc.url&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注：如果是 Spring Boot 的 application.properties 注册的，那也是可以的。</strong></p><hr><h3 id="Properties-配置"><a href="#Properties-配置" class="headerlink" title="Properties 配置"></a>Properties 配置</h3><p>前面我们说了怎么使用我们配置的 Properties，那么该怎么配置呢？Spring 提供了很多种配置方式。</p><h4 id="通过-xml-配置"><a href="#通过-xml-配置" class="headerlink" title="通过 xml 配置"></a>通过 xml 配置</h4><p>下面这个是最常用的配置方式了，很多项目都是这么写的：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;context:property-placeholder location=&quot;classpath:sys.properties&quot; /&gt;<br></code></pre></td></tr></table></figure></p><h4 id="通过-PropertySource-配置"><a href="#通过-PropertySource-配置" class="headerlink" title="通过 @PropertySource 配置"></a>通过 @PropertySource 配置</h4><p>前面的通过 xml 配置非常常用，但是如果你也有一种要消灭所有 xml 配置文件的冲动的话，你应该使用以下方式：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@PropertySource(&quot;classpath:sys.properties&quot;)<br>@Configuration<br>public class JavaDoopConfig &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>注：@PropertySource 在这里必须搭配 @Configuration 来使用，具体不展开说了。</strong></p><h4 id="PropertyPlaceholderConfigurer"><a href="#PropertyPlaceholderConfigurer" class="headerlink" title="PropertyPlaceholderConfigurer"></a>PropertyPlaceholderConfigurer</h4><p>如果读者见过这个，也不必觉得奇怪，在 Spring 3.1 之前，经常就是这么使用的：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;<br>   &lt;property name=&quot;locations&quot;&gt;<br>       &lt;list&gt;<br>           &lt;value&gt;classpath:sys.properties&lt;/value&gt;<br>       &lt;/list&gt;<br>   &lt;/property&gt;<br>   &lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot;/&gt;<br>     &lt;!-- 这里可以配置一些属性 --&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>当然，我们也可以用相应的 java configuration 的版本：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean<br>public PropertyPlaceholderConfigurer propertiess() &#123;<br>   PropertyPlaceholderConfigurer ppc = new PropertyPlaceholderConfigurer();<br>   Resource[] resources = new ClassPathResource[]&#123;new ClassPathResource(&quot;sys.properties&quot;)&#125;;<br>   ppc.setLocations(resources);<br>   ppc.setIgnoreUnresolvablePlaceholders(true);<br>   return ppc;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="PropertySourcesPlaceholderConfigurer"><a href="#PropertySourcesPlaceholderConfigurer" class="headerlink" title="PropertySourcesPlaceholderConfigurer"></a>PropertySourcesPlaceholderConfigurer</h4><p>到了 Spring 3.1 的时候，引入了 PropertySourcesPlaceholderConfigurer，这是一个新的类，注意看和之前的 PropertyPlaceholderConfigurer 在名字上多了一个 Sources，所属的包也不一样，它在 Spring-Context 包中。</p><p>在配置上倒是没有什么区别：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean class=&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;&gt;<br>   &lt;property name=&quot;locations&quot;&gt;<br>       &lt;list&gt;<br>           &lt;value&gt;classpath:sys.properties&lt;/value&gt;<br>       &lt;/list&gt;<br>   &lt;/property&gt;<br>   &lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot;/&gt;<br>   &lt;!-- 这里可以配置一些属性 --&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>也来一个 java configuration 版本吧：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean<br>public PropertySourcesPlaceholderConfigurer properties() &#123;<br>   PropertySourcesPlaceholderConfigurer pspc = new PropertySourcesPlaceholderConfigurer();<br>   Resource[] resources = new ClassPathResource[]&#123;new ClassPathResource(&quot;sys.properties&quot;)&#125;;<br>   pspc.setLocations(resources);<br>   pspc.setIgnoreUnresolvablePlaceholders(true);<br>   return pspc;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="Spring-Boot-相关"><a href="#Spring-Boot-相关" class="headerlink" title="Spring Boot 相关"></a>Spring Boot 相关</h3><p>Spring Boot 真的是好东西，开箱即用的感觉实在是太好了。这里简单介绍下相关的内容。</p><p>快速生成一个 Spring Boot 项目：</p><p><a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a></p><p><strong>application.properties</strong></p><p>我们每个项目都默认有一个 application.properties 文件，这个配置文件不需要像前面说的那样进行注册，Spring Boot 会帮我们自动注册。</p><p>当然，也许你想换个名字也是可以的，在启动的时候指定你的文件名字就可以了：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">java -Dspring.config.location=classpath:sys.properties -jar app.jar<br></code></pre></td></tr></table></figure></p><p><strong>application-{env}.properties</strong></p><p>为了给不同的环境指定不同的配置，我们会用到这个。比如测试环境和生产环境的数据库连接信息就不一样。</p><p>所以，在 application.properties 的基础上，我们还需要新建 application-dev.properties 和 application-prd.properties，用于配置环境相关的信息，然后启动的时候指定环境。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">java -Dspring.profiles.active=prd -jar app.jar<br></code></pre></td></tr></table></figure></p><p>结果就是，application.properties 和 application-prd.properties 两个文件中的配置都会注册进去，如果有重复的 key，application-prd.properties 文件中的优先级较高。</p><p><strong>@ConfigurationProperties</strong></p><p>这个注解是 Spring Boot 中才有的。即使大家不使用这个注解，大家也可能会在开源项目中看到这个，这里简单介绍下。</p><p>来一个例子直观一些。按照之前说的，在配置文件中填入下面的信息，你可以选择写入 application.properties 也可以用第一节介绍的方法。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">javadoop.database.url=jdbc:mysql:<br>javadoop.database.username=admin<br>javadoop.database.password=admin123456<br></code></pre></td></tr></table></figure></p><p>java 文件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ConfigurationProperties(prefix = &quot;javadoop.database&quot;)<br>public class DataBase &#123;<br>   String url;<br>   String username;<br>   String password;<br>   // getters and setters<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这样，就在 Spring 的容器中就自动注册了一个类型为 DataBase 的 bean 了，而且属性都已经 set 好了。</p><p><strong>在启动过程中动态修改属性值</strong></p><p>这个我觉得都不需要太多介绍，用 Spring Boot 的应该基本上都知道。</p><p>属性配置有个覆盖顺序，也就是当出现相同的 key 的时候，以哪里的值为准。</p><p>启动参数 &gt; application-{env}.properties &gt; application.properties</p><p>启动参数动态设置属性：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">java -Djavadoop.database.password=admin4321 -jar app.jar<br></code></pre></td></tr></table></figure></p><p>另外，还可以利用系统环境变量设置属性，还可以指定随机数等等，确实很灵活，不过没什么用，就不介绍了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>读者如果想要更加深入地了解 Spring 的 Properties，需要去理解 Spring 的 Environment 接口相关的源码。建议感兴趣的读者去翻翻源代码看看</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_13</title>
      <link href="/2018/10/19/spring-annotation-day-13/"/>
      <url>/2018/10/19/spring-annotation-day-13/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong> </p><p>今天来学习AOP原理。</p><a id="more"></a><p>我们上篇文章已经描述了AOP的使用情况，现在来研究一下AOP的原理。首先从@EnableAspectJAutoProxy注解开始。</p><hr><h3 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h3><p>1）点击@EnableAspectJAutoProxy注解：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Target(ElementType.TYPE)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>@Import(AspectJAutoProxyRegistrar.class)<br>public @interface EnableAspectJAutoProxy<br></code></pre></td></tr></table></figure></p><p>发现，使用了@Import注解来注入组件。组件是AspectJAutoProxyRegistrar类。</p><p>2）点击AspectJAutoProxyRegistrar类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar&#123;<br>  ···<br>&#125;<br></code></pre></td></tr></table></figure></p><p>该类，实现了ImportBeanDefinitionRegistrar接口，说明是用来自定义注入组件的。其中有一个registerBeanDefinitions（）方法。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;<br><br>AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);<br><br>AnnotationAttributes enableAspectJAutoProxy =<br>AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);<br>if (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;)) &#123;<br>AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);<br>&#125;<br>if (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;)) &#123;<br>AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>查看其中的AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</p><p>最终会调用registerOrEscalateApcAsRequired方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs undefined">private static BeanDefinition registerOrEscalateApcAsRequired(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source) &#123;<br>Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);<br>if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;<br>BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);<br>if (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;<br>int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());<br>int requiredPriority = findPriorityForClass(cls);<br>if (currentPriority &lt; requiredPriority) &#123;<br>apcDefinition.setBeanClassName(cls.getName());<br>&#125;<br>&#125;<br>return null;<br>&#125;<br>RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);<br>beanDefinition.setSource(source);<br>beanDefinition.getPropertyValues().add(&quot;order&quot;, Ordered.HIGHEST_PRECEDENCE);<br>beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<br>registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);<br>return beanDefinition;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>最后是给容器注入了一个Bean：<br>id：internalAutoProxyCreator ==》 Class：AnnotationAwareAspectJAutoProxyCreator</p><hr><h3 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h3><p>@EnableAspectJAutoProxy注解帮我们注入了AnnotationAwareAspectJAutoProxyCreator组件，这个组件有什么作用呢？</p><p>我们观察一下AnnotationAwareAspectJAutoProxyCreator的继承关系：</p><p>AnnotationAwareAspectJAutoProxyCreator</p><p>&nbsp;&nbsp;&nbsp;AspectJAwareAdvisorAutoProxyCreator  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractAdvisorAutoProxyCreator  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractAutoProxyCreator</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware</strong></p><p><strong>关键:实现了两个接口，一个后置处理器(在Bean初始化完成前后做事情)、一个自动装配BeanFactory</strong></p><hr><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>打上断点：(与后置处理器，自动装配有关的)</p><p>1）AbstractAutoProxyCreator.setBeanFactory<br>2）AbstractAutoProxyCreator.postProcessBeforeInstantiation<br>3) AbstractAutoProxyCreator.postProcessAfterInitialization</p><p>4) AbstractAdvisorAutoProxyCreator.setBeanFactory(父类重写的方法也打上断点)<br>5）AbstractAdvisorAutoProxyCreator.initBeanFactory</p><p>6) AspectJAwareAdvisorAutoProxyCreator类没有相关的就不打上断点</p><p>7）AnnotationAwareAspectJAutoProxyCreator.initBeanFactory(父类重写的方法也打上断点)</p><p>8) MainConfigOfAOP配置类的中的两个Bean对象打上断点：<br>&nbsp;&nbsp;&nbsp;mathCalculator和logAspects</p><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>流程：<br>1）传入配置类，创建IoC容器<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAOP.class);<br></code></pre></td></tr></table></figure></p><p>2) 注册配置类，调用refresh（）, 刷新容器<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) &#123;<br>this();<br>register(annotatedClasses); //注入配置类<br>refresh();  //刷新容器<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3）registerBeanPostProcessors(beanFactory);注册bean的后置处理器，来拦截bean的初始化操作。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;1.先获取IoC容器已经定义了的需要创建对象的所有BeanPostProcessor<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);<br></code></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;2.给容器中加别的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;3.优先注册实现了PriorityOrdered接口的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;4.再注册实现了Ordered接口的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;5.注册没有实现优先级接口的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;6.注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象，保存到容器中</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 创建    internalAutoProxyCreator的BeanPostProcessor【AnnotationAwareAspectJAutoProxyCreator】 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.创建Bean对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.populateBean：给bean的属性赋值</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.initializeBean：初始化bean</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.invokeAwareMethods：处理Aware接口的回调：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">private void invokeAwareMethods(final String beanName, final Object bean) &#123;<br>if (bean instanceof Aware) &#123;<br>if (bean instanceof BeanNameAware) &#123;<br>((BeanNameAware) bean).setBeanName(beanName);<br>&#125;<br>if (bean instanceof BeanClassLoaderAware) &#123;<br>((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());<br>&#125;<br>if (bean instanceof BeanFactoryAware) &#123;<br>((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.applyBeanPostProcessorsBeforeInitialization:执行后置处理器的postProcessor：postProcessBeforeInitialization方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.invokeInitMethods：自定义的初始化方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.applyBeanPostProcessorsAfterInitialization：执行postProcessor：postProcessAfterInitialization方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;7.把BeanPostProcessor注册到BeanFactory中：beanFactory.addBeanPostProcessor（）</p><hr><p>以上是创建AnnotationAwareAspectJAutoProxyCreator的过程。</p><p>AnnotationAwareAspectJAutoProxyCreator =》InstantiationAwareBeanPostProcessor，而不是 BeanPostProcessor 后置处理器</p><p>InstantiationAwareBeanPostProcessor是 postProcessBeforeInstantiation（实例化）</p><p>BeanPostProcessor是postProcessBeforeInitialization（初始化）</p><p><strong>说明InstantiationAwareBeanPostProcessor后置处理器是 在Bean实例化前后执行</strong></p><p><strong>BeanPostProcessor后置处理器是 在Bean对象初始化前后执行</strong></p><p>4）finishBeanFactoryInitialization(beanFactory);完成BeanFactory初始化工作，创建剩下的没有创建的Bean组件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;1.遍历获取容器中所有的Bean，依次创建对象；getBean(beanName)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getBean()-&gt;doGetBean()-&gt;getSingleton()-&gt;createBean()</p><p>&nbsp;&nbsp;&nbsp;&nbsp;2.创建Bean：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.先从缓存中获取当前的Bean，如果能获取到，说明bean是之前被创建过，直接使用，否则再创建.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要创建了bean就会被缓存起来。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.createBean():创建Bean</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.resolveBeforeInstantiation():解析BeanPostProcessors<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>想让后置处理器在次能返回一个代理对象</strong>，如果能返回代理对象就使用，如果不能就继续。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.后置处理器先尝试返回代理对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bean=applyBeanPostProcessorsBeforeInstantiation();拿到所有的后置处理器，如果是 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InstantiationAwareBeanPostProcessor；就执行postProcessBeforeInstantiation方法<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined"> if (bean != null) &#123;<br>  bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.doCreateBean()：真正去创建一个bean实例；和3.6流程一样</p><hr><p>AnnotationAwareAspectJAutoProxyCreator[InstantiationAwareBeanPostProcessor]</p><p>1) 每一个bean创建之前，调用postProcessBeforeInstantiation()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关心<strong>mathCalculator</strong>和<strong>logAspects</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）判断当前bean是否是在advicedBean中（保存了所有需要增强bean）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）判断当前bean是否是基础类型的Advice、PointCut、Advisor、AopInfrastructureBean或者是否是切面(@Aspect)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）是否需要跳过</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）获取候选的增强器(切面里面的通知方法)【List<advisor> candidateAdvisors】<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个封装的通知方法的增强器是InstantiationModelAwarePointcutAdvisor<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判断每一个增强器是否是AspectJPointcutAdvisor类型的；返回true</advisor></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）永远返回false</p><p>2）创建对象<br>postProcessAfterInitialization：<br>return wrapIfNecessary(bean, beanName, cacheKey);//需要包装的情况下  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）获取当前bean的所有增强器(通知方法) Object[] specificInterceptors</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）找到候选的所有增强器(找哪些通知方法是需要切入当前bean方法的)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）获取到能在bean使用的增强器</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）给增强器排序</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）保存当前bean在advisedBeans中；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）如果当前bean需要增强，创建当前bean的代理对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）获取所有的增强器(通知方法)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）保存到proxyFactory</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）创建代理对象：Spring自动决定<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jdk代理<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cglib代理</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）给容器中返回当前组件使用cglib代理的对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5）以后容器中获取的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程</p><p>3）目标方法的执行流程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容器中保存了组件的代理对象(cglib增强后的对象)，这个对象里面保存了详细信息(比如增强器、目标对象，xxx)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）CglibAopProxy.intercept();拦截目标方法的执行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）根据ProxyFactory对象获取将要执行的目标方法拦截器</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List<object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</object></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）List<object> interceptorList保存所有拦截器：5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个默认的ExposeInvocationInterceptor和4个增强器</object></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）遍历所有的增强器，将其转为Interceptor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）将增强器转为List<methodinterceptor>,如果是MethodInterceptor，直接加入集合中，如果不是，使用AdvisorAdapter将增强器转为   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MethodInterceptor，转换完后返回MethodInterceptor数组</methodinterceptor></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）如果没有拦截器链，直接执行目标方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）如果有拦截器链，把需要执行的目标对象，目标方法，拦截器链等信息传入，创建一个CglibMethodInvocation对象，并调用<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object retVal = mi.proceed();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5) 拦截器链的触发过程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）如果没有拦截器执行，就直接执行目标方法，或者拦截器的索引和拦截器数组的个数-1一样大，执行目标方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）链式获取每一个拦截器，拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拦截器链的机制，保证通知方法与目标方法的执行顺序.<br><img src="/images/20181019201432.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1）@EnableAspectJAutoProxy注解 开启AOP功能</p><p>2）@EnableAspectJAutoProxy 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator</p><p>3）AnnotationAwareAspectJAutoProxyCreator是一个后置处理器</p><p>4）容器的创建流程：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）registerBeanPostProcessors()注册后置处理器，创建AnnotationAwareAspectJAutoProxyCreator对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）finishBeanFactoryInitialization()：初始化剩下的单实例bean<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）创建业务逻辑组件和切面组件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）组件创建完之后，判断组件是否需要增强。是：切面的通知方法，包装成增强器(Advisor);给业务逻辑组件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个代理对象 </p><p>5）执行目标方法：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）代理对象执行目标方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）CglibAopProxy.Intercept:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）得到目标方法的拦截器链(增强器包装成拦截器MethodIntercept)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）利用拦截器的链式机制，依次进入每一个拦截器进行执行；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）效果：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 正常执行：前置通知 -》目标方法 -》后置通知 -》返回通知<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 出现异常：前置通知 -》目标方法 -》后置通知 -》异常通知  </p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring和SpringMVC父子容器关系初窥</title>
      <link href="/2018/10/19/Spring%E5%92%8CSpringMVC%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8%E5%85%B3%E7%B3%BB%E5%88%9D%E7%AA%A5/"/>
      <url>/2018/10/19/Spring%E5%92%8CSpringMVC%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8%E5%85%B3%E7%B3%BB%E5%88%9D%E7%AA%A5/</url>
      
        <content type="html"><![CDATA[<p>Spring和SpringMVC父子容器关系初窥，探究父容器与子容器之间的关系<br><a id="more"></a></p><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>最近由于项目的包扫描出现了问题，在解决问题的过程中，偶然发现了Spring和SpringMVC是有父子容器关系的，而且正是因为这个才往往会出现包扫描的问题，我们在此来分析和理解Spring和SpringMVC的父子容器关系并且给出Spring和SpringMVC配置文件中包扫描的官方推荐方式。</p><h3 id="二、概念理解和知识铺垫"><a href="#二、概念理解和知识铺垫" class="headerlink" title="二、概念理解和知识铺垫"></a>二、概念理解和知识铺垫</h3><p>在Spring整体框架的核心概念中，容器是核心思想，就是用来管理Bean的整个生命周期的，而在一个项目中，容器不一定只有一个，Spring中可以包括多个容器，而且容器有上下层关系</p><p>目前最常见的一种场景就是在一个项目中引入Spring和SpringMVC这两个框架，那么它其实就是两个容器，Spring是父容器，SpringMVC是其子容器</p><p>并且在Spring父容器中注册的Bean对于SpringMVC容器中是可见的，而在SpringMVC容器中注册的Bean对于Spring父容器中是不可见的，也就是子容器可以看见父容器中的注册的Bean，反之就不行。</p><p>我们可以使用统一的如下注解配置来对Bean进行批量注册，而不需要再给每个Bean单独使用xml的方式进行配置。</p><p><code>&lt;context:component-scan base-package=&quot;com.liuzhuo.www&quot; /&gt;</code></p><p>从Spring提供的参考手册中我们得知该配置的功能是扫描配置的base-package包下的所有使用了@Component注解的类，并且将它们自动注册到容器中，同时也扫描@Controller，@Service，@Respository这三个注解，因为他们是继承自@Component</p><hr><p>在项目中我们经常见到还有如下这个配置，其实有了上面的配置，这个是可以省略掉的，因为上面的配置会默认打开以下配置。</p><p>以下配置会默认声明了@Required、@Autowired、 @PostConstruct、@PersistenceContext、@Resource、@PreDestroy等注解</p><p><code>&lt;context:annotation-config/&gt;</code></p><p><strong>另外，还有一个和SpringMVC相关如下配置，经过验证，这个是SpringMVC必须要配置的，因为它声明了@RequestMapping、@RequestBody、@ResponseBody等。并且，该配置默认加载很多的参数绑定方法，比如json转换解析器等。</strong></p><p><code>&lt;mvc:annotation-driven /&gt;</code></p><p>而上面这句,配置Spring3.1之前的版本和以下配置方式等价</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!--配置注解控制器映射器,它是SpringMVC中用来将Request请求URL到映射到具体Controller--&gt;<br>&lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping&quot;/&gt;<br>&lt;!--配置注解控制器适配器,它是SpringMVC中用来将具体请求映射到具体方法--&gt;<br>&lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;/&gt;<br></code></pre></td></tr></table></figure><p>Spring3.1之后的版本和以下配置方式等价：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!--配置注解控制器映射器,它是SpringMVC中用来将Request请求URL到映射到具体Controller--&gt;<br>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;<br>&lt;!--配置注解控制器适配器,它是SpringMVC中用来将具体请求映射到具体方法--&gt;<br>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;<br></code></pre></td></tr></table></figure></p><h3 id="三、具体场景分析"><a href="#三、具体场景分析" class="headerlink" title="三、具体场景分析"></a>三、具体场景分析</h3><p>下面让我们来详细扒一扒Spring与SpringMVC的容器冲突的原因到底在那里？</p><p>我们共有Spring和SpringMVC两个容器，它们的配置文件分别为applicationContext.xml和applicationContext-MVC.xml</p><p>1、在applicationContext.xml中配置了&lt;context:component-scan base-package=“com.hafiz.www” /&gt;，负责所有需要注册的Bean的扫描和注册工作</p><p>2、在applicationContext-MVC.xml中配置&lt;mvc:annotation-driven /&gt;，负责SpringMVC相关注解的使用</p><p>3、启动项目我们发现SpringMVC无法进行跳转，将log的日志打印级别设置为DEBUG进行调试，发现SpringMVC容器中的请求好像没有映射到具体controller中</p><p>4、在applicationContext-MVC.xml中配置&lt;context:component-scan base-package=“com.hafiz.www” /&gt;，重启后，验证成功，springMVC跳转有效</p><p>下面我们来查看具体原因，翻看源码，从SpringMVC的DispatcherServlet开始往下找，我们发现SpringMVC初始化时，会寻找SpringMVC容器中的所有使用了@Controller注解的Bean，来确定其是否是一个handler</p><p>1、2两步的配置使得当前SpringMVC容器中并没有注册带有@Controller注解的Bean，而是把所有带有@Controller注解的Bean都注册在Spring这个父容器中了，所以SpringMVC找不到处理器，不能进行跳转。核心源码如下:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">protected void initHandlerMethods() &#123;<br>　　if (logger.isDebugEnabled()) &#123;<br>　　　　logger.debug(&quot;Looking for request mappings in application context: &quot; + getApplicationContext());<br>　　&#125;<br>　　String[] beanNames = (this.detectHandlerMethodsInAncestorContexts ?<br>　　　　　　  BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) :<br>　　　　　　　getApplicationContext().getBeanNamesForType(Object.class));<br>　　for (String beanName : beanNames) &#123;<br>　　　　if (isHandler(getApplicationContext().getType(beanName)))&#123;<br>　　　　　　detectHandlerMethods(beanName);<br>　　　　&#125;<br>　　&#125;<br>　　handlerMethodsInitialized(getHandlerMethods());<br>&#125;<br></code></pre></td></tr></table></figure></p><p>在方法isHandler中会判断当前bean的注解是否是controller，源码如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">protected boolean isHandler(Class&lt;?&gt; beanType) &#123;<br>　　return AnnotationUtils.findAnnotation(beanType, Controller.class) != null;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>而在第4步配置中，SpringMVC容器中也注册了所有带有@Controller注解的Bean，故SpringMVC能找到处理器进行处理，从而正常跳转。</p><p>我们找到了出现不能正确跳转的原因，那么它的解决办法是什么呢？</p><p>我们注意到在initHandlerMethods()方法中，detectHandlerMethodsInAncestorContexts这个Switch，它主要控制获取哪些容器中的bean以及是否包括父容器，默认是不包括的。</p><p>所以解决办法就是在SpringMVC的配置文件中配置HandlerMapping的detectHandlerMethodsInAncestorContexts属性为true即可（这里需要根据具体项目看使用的是哪种HandlerMapping），让它检测父容器的bean。如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;&gt;<br>  &lt;property name=&quot;detectHandlerMethodsInAncestorContexts&quot;&gt;<br>      &lt;value&gt;true&lt;/value&gt;<br>  &lt;/property&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>但在实际工程中会包括很多配置，我们按照官方推荐根据不同的业务模块来划分不同容器中注册不同类型的Bean：</p><p>Spring父容器负责所有其他非@Controller注解的Bean的注册，而SpringMVC只负责@Controller注解的Bean的注册，使得他们各负其责、明确边界。配置方式如下</p><p>1、在applicationContext.xml中配置:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!-- Spring容器中注册非@controller注解的Bean --&gt;<br>&lt;context:component-scan base-package=&quot;com.hafiz.www&quot;&gt;<br>  &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;<br>&lt;/context:component-scan&gt;<br></code></pre></td></tr></table></figure></p><p>2、applicationContext-MVC.xml中配置<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!-- SpringMVC容器中只注册带有@controller注解的Bean --&gt;<br>&lt;context:component-scan base-package=&quot;com.hafiz.www&quot; use-default-filters=&quot;false&quot;&gt;<br>  &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;<br>&lt;/context:component-scan&gt;<br></code></pre></td></tr></table></figure></p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>这样我们在清楚了Spring和SpringMVC的父子容器关系、以及扫描注册的原理以后，根据官方建议我们就可以很好把不同类型的Bean分配到不同的容器中进行管理。再出现Bean找不到或者SpringMVC不能跳转以及事务的配置失效的问题，我们就可以很快的定位以及解决问题了。很开心，有木有~</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_12</title>
      <link href="/2018/10/18/spring-annotation-day-12/"/>
      <url>/2018/10/18/spring-annotation-day-12/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天学习AOP的开发与使用<br><a id="more"></a></p><h3 id="AOP介绍"><a href="#AOP介绍" class="headerlink" title="AOP介绍"></a>AOP介绍</h3><p>AOP是Spring 框架的一个关键组件，全称为Aspect-Oriented-Programming（面向切面编程），目前已是一种比较成熟的编程方式。</p><p>AOP采取横向抽取机制，将分散在各个方法中的重复代码提取出来，然后在编译或运行的时候，再将这些代码应用到需要执行的地方。</p><p><strong>注：提取出来的代码应用到需要执行的地方，并不会把源代码加到需要的地方执行，即源代码文件不会更改，但是它会影响最终的机器编译代码</strong></p><p>意思就是，有一些通用功能的代码可以提取出来，然后在使用的时候应用进去就可以了，比如表单验证和日志记录等等。</p><h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><p>Aspect（切面）</p><p>通常指封装起来用于插入到指定位置实现某项功能的类</p><p>Join point（连接点）</p><p>在SpringAOP中，连接点指方法的调用</p><p>Pointcut（切入点）</p><p>切面与程序流程的交叉点，即那些需要处理的连接点，通常在程序中，切入点指的是类或者方法名</p><p>Advice（通知/增强处理）</p><p>就是程序实际运行之前或之后执行的方法，也就是AOP加入的代码</p><p>Target Object（目标对象）</p><p>即需要加入AOP代码的对象</p><p>Proxy（代理）</p><p>AOP框架动态生成的一个对象，该对象可以作为目标对象使用</p><p>Weaving（织入）</p><p>把切面连接到其它的应用程序类型或者对象上，并创建一个需要Advice对象的过程</p><h3 id="AOP的例子（JDK代理）"><a href="#AOP的例子（JDK代理）" class="headerlink" title="AOP的例子（JDK代理）"></a>AOP的例子（JDK代理）</h3><p>1）首先建立一个java工程</p><p><img src="/images/20181018211302.png" style="width:50%"></p><p>UserDao接口:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package com.aop.jdk;<br><br>public interface UserDao &#123;<br> <br> public void addUser();<br> <br>&#125;<br></code></pre></td></tr></table></figure></p><p>UserDaoImpl:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package com.aop.jdk;<br><br>public class UserDaoImpl implements UserDao &#123;<br><br> @Override<br> public void addUser() &#123;<br>   <br>   System.out.println(&quot;新增用户&quot;);<br> &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure></p><p>JdkProxy:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package com.aop.jdk;<br><br>import java.lang.reflect.InvocationHandler;<br>import java.lang.reflect.Method;<br>import java.lang.reflect.Proxy;<br><br>import com.aop.aspect.MyAspect;<br><br>/**<br>* JDK代理类<br>*/<br>public class JdkProxy implements InvocationHandler&#123;<br> <br> // 声明目标类接口<br> private UserDao userDao;<br> <br> // 创建代理方法<br> public  Object createProxy(UserDao userDao) &#123;<br>   <br>   this.userDao = userDao;<br>   <br>   // 1.类加载器<br>   ClassLoader classLoader = JdkProxy.class.getClassLoader();<br>   <br>   // 2.被代理对象实现的所有接口<br>   @SuppressWarnings(&quot;rawtypes&quot;)<br>   Class[] clazz = userDao.getClass().getInterfaces();<br>   <br>   // 3.使用代理类，进行增强，返回的是代理后的对象<br>   return  Proxy.newProxyInstance(classLoader,clazz,this);<br>   <br> &#125;<br> <br> /*<br>  * 所有动态代理类的方法调用，都会交由invoke()方法去处理<br>  * proxy 被代理后的对象 <br>  * method 将要执行的方法<br>  * args 执行方法时需要的参数<br>  */<br> @Override<br> public Object invoke(Object proxy, Method method, Object[] args) <br>     throws Throwable &#123;<br>   <br>   // 声明切面<br>   MyAspect myAspect = new MyAspect();<br>   <br>   // 指定位置程序执行前执行这个方法<br>   myAspect.start();<br>   <br>   // 在目标类上调用方法<br>   Object obj = method.invoke(userDao, args);<br>   <br>   // 指定位置程序执行结束后执行<br>   myAspect.end();<br>   <br>   return obj;<br> &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure></p><p>MyAspect:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package com.aop.aspect;<br><br>/**<br>*  切面<br>*/<br>public class MyAspect &#123;<br> <br> public void start()&#123;<br>   System.out.println(&quot;模拟事务处理功能 ...&quot;);<br> &#125;<br> <br> public void end()&#123;<br>   System.out.println(&quot;程序结束后执行此处 ...&quot;);<br> &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure></p><p>JdkTest:</p><p>测试结果项目编写完之后运行该类</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package com.aop.test;<br><br>import com.aop.jdk.JdkProxy;<br>import com.aop.jdk.UserDao;<br>import com.aop.jdk.UserDaoImpl;<br><br>public class JdkTest &#123;<br> <br> public static void main(String[] args) &#123;<br>   <br>   // 创建代理对象<br>   JdkProxy jdkProxy = new JdkProxy();<br>        // 创建目标对象<br>   UserDao userDao= new UserDaoImpl();<br>   // 从代理对象中获取增强后的目标对象<br>   UserDao userDao1 = (UserDao) jdkProxy.createProxy(userDao);<br>   // 执行方法<br>   userDao1.addUser();<br> &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>运行之后，我们可以看到以下结果：<br><img src="/images/20181018211845.png" style="width:50%"></p><hr><p>我们可以看到，在我们执行新增用户的方法时，依据我们AOP编程，系统自动执行了start方法和end方法</p><p>在实际运用中，我们可以把一些通用的方法放到start和end的位置，在需要的方法处加入切面即可</p><p>此外，建议大家再了解下AspectJ</p><p>AspectJ实现AOP有两种方式：一种是基于XML的声明式，另一种是基于注解的声明式</p><p>基于XML的声明式AspectJ要便捷一些，但是存在配置信息多的缺点</p><p>基于注解的声明式AspectJ则通过注解的方式减少了很多配置信息</p><h3 id="Spring中的AOP使用"><a href="#Spring中的AOP使用" class="headerlink" title="Spring中的AOP使用"></a>Spring中的AOP使用</h3><p>1）创建新的配置类MainConfigOfAOP<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class MainConfigOfAOP &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 在com.liuzhuo.aop包下，创建MathCalculator类<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MathCalculator &#123;<br><br>    public int div(int a, int b) &#123;<br>        return a / b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 在com.liuzhuo.aop包下，创建切面类MathCalculator<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class LogAspects &#123;<br><br>    public void logStart()&#123;<br>        System.out.println(&quot;方法调用之前------&quot;);<br>    &#125;<br><br>    public void logEnd()&#123;<br>        System.out.println(&quot;方法调用之后-------&quot;);<br>    &#125;<br><br>    public void logReturn()&#123;<br>        System.out.println(&quot;方法成功返回之后------&quot;);<br>    &#125;<br><br>    public void logThrowing()&#123;<br>        System.out.println(&quot;方法出现异常之后------&quot;);<br>    &#125;<br><br>    public void logRound()&#123;<br>        //环绕方法<br>        System.out.println(&quot;环绕：方法调用之前----&quot;);<br>        System.out.println(&quot;环绕：方法调用之后----&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 添加AOP的依赖，在pom文件中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">      <br>&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;<br>    &lt;version&gt;5.1.1.RELEASE&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>4) 将切面与目标方法进行连接：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Aspect<br>public class LogAspects &#123;<br><br>    @Pointcut(&quot;execution(public int com.liuzhuo.aop.MathCalculator.div(int,int))&quot;)<br>    public void pointCut() &#123;<br>    &#125;<br><br>    //调用本类的切点<br>    @Before(&quot;pointCut()&quot;)<br>    public void logStart() &#123;<br>        System.out.println(&quot;方法调用之前------&quot;);<br>    &#125;<br><br>    //调用外面类的切点<br>    @After(&quot;com.liuzhuo.aop.LogAspects.pointCut()&quot;)<br>    public void logEnd() &#123;<br>        System.out.println(&quot;方法调用之后-------&quot;);<br>    &#125;<br><br>    @AfterReturning(value = &quot;pointCut()&quot;, returning = &quot;returns&quot;)<br>    public void logReturn(Object returns) &#123;<br>        System.out.println(&quot;方法成功返回之后------:&quot; + returns);<br>    &#125;<br><br>    @AfterThrowing(value = &quot;pointCut()&quot;, throwing = &quot;e&quot;)<br>    public void logThrowing(Exception e) &#123;<br>        System.out.println(&quot;方法出现异常之后------:&quot; + e);<br>    &#125;<br><br>    @Around(&quot;pointCut()&quot;)<br>    public Object logRound(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;<br>        //环绕方法<br>        System.out.println(&quot;环绕：方法调用之前----&quot;);<br>        Object proceed = proceedingJoinPoint.proceed();<br>        System.out.println(&quot;环绕：方法调用之后----&quot;);<br>        return proceed;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5) 将切面和目标类注入到容器中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class MainConfigOfAOP &#123;<br><br>    @Bean<br>    public MathCalculator mathCalculator() &#123;<br>        return new MathCalculator();<br>    &#125;<br><br>    @Bean<br>    public LogAspects logAspects() &#123;<br>        return new LogAspects();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>6) <strong>开启Aspect的注解驱动</strong>：@EnableAspectJAutoProxy<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@EnableAspectJAutoProxy //开启AOP注解驱动<br>public class MainConfigOfAOP &#123;<br><br>    @Bean<br>    public MathCalculator mathCalculator() &#123;<br>        return new MathCalculator();<br>    &#125;<br><br>    @Bean<br>    public LogAspects logAspects() &#123;<br>        return new LogAspects();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>7) 创建新的测试类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IoCTest_AOP &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAOP.class);<br><br>        //不要自己创建MathCalculator类<br>        //MathCalculator mathCalculator = new MathCalculator();<br>        //mathCalculator.div(1, 1);<br><br>        MathCalculator mathCalculator = applicationContext.getBean(MathCalculator.class);<br>        mathCalculator.div(1, 1);<br><br>        applicationContext.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>8) 运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">环绕：方法调用之前----<br>方法调用之前------<br>div:正在执行-----<br>环绕：方法调用之后----<br>方法调用之后-------<br>方法成功返回之后------:1<br>十月 18, 2018 10:03:03 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@3a4afd8d: startup date [Thu Oct 18 22:03:02 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>将业务逻辑组件和切面类都加入到容器中，告诉Spring哪个是切面类(Aspect)  </li><li>在切面类上的每一个通知方法上标注通知注解，告诉Spring何时何地运行（切入点表达式）</li><li>开启基于注解的AOP模式：@EnableAspectJAutoProxy</li></ol>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Bean的生命周期</title>
      <link href="/2018/10/18/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/10/18/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>Spring作为当前Java最流行、最强大的轻量级框架，受到了程序员的热烈欢迎。准确的了解Spring Bean的生命周期是非常必要的。<br><a id="more"></a></p><p>我们通常使用ApplicationContext作为Spring容器。这里，我们讲的也是 ApplicationContext中Bean的生命周期。而实际上BeanFactory也是差不多的，只不过处理器需要手动注册。</p><h3 id="一、生命周期流程图："><a href="#一、生命周期流程图：" class="headerlink" title="一、生命周期流程图："></a>一、生命周期流程图：</h3><p>Spring Bean的完整生命周期从创建Spring容器开始，直到最终Spring容器销毁Bean，这其中包含了一系列关键点。<br><img src="/images/20181018162309.png"><br><img src="/images/20181018162419.png"></p><p>若容器注册了以上各种接口，程序那么将会按照以上的流程进行。下面将仔细讲解各接口作用。</p><h3 id="二、各种接口方法分类"><a href="#二、各种接口方法分类" class="headerlink" title="二、各种接口方法分类"></a>二、各种接口方法分类</h3><p>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：</p><p>1、Bean自身的方法:这个包括了Bean本身调用的方法和通过配置文件中<bean>的init-method和destroy-method指定的方法</bean></p><p>2、Bean级生命周期接口方法:这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法</p><p>3、容器级生命周期接口方法:这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</p><p>4、工厂后处理器接口方法:这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</p><h3 id="三、演示"><a href="#三、演示" class="headerlink" title="三、演示"></a>三、演示</h3><p>我们用一个简单的Spring Bean来演示一下Spring Bean的生命周期。</p><p>1、首先是一个简单的Spring Bean，调用Bean自身的方法和Bean级生命周期接口方法，为了方便演示，它实现了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这4个接口，同时有2个方法，对应配置文件中<bean>的init-method和destroy-method。如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package springBeanTest;<br><br>import org.springframework.beans.BeansException;<br>import org.springframework.beans.factory.BeanFactory;<br>import org.springframework.beans.factory.BeanFactoryAware;<br>import org.springframework.beans.factory.BeanNameAware;<br>import org.springframework.beans.factory.DisposableBean;<br>import org.springframework.beans.factory.InitializingBean;<br><br>/**<br>* @author qsk<br>*/<br>public class Person implements BeanFactoryAware, BeanNameAware,<br>       InitializingBean, DisposableBean &#123;<br><br>   private String name;<br>   private String address;<br>   private int phone;<br><br>   private BeanFactory beanFactory;<br>   private String beanName;<br><br>   public Person() &#123;<br>       System.out.println(&quot;【构造器】调用Person的构造器实例化&quot;);<br>   &#125;<br><br>   public String getName() &#123;<br>       return name;<br>   &#125;<br><br>   public void setName(String name) &#123;<br>       System.out.println(&quot;【注入属性】注入属性name&quot;);<br>       this.name = name;<br>   &#125;<br><br>   public String getAddress() &#123;<br>       return address;<br>   &#125;<br><br>   public void setAddress(String address) &#123;<br>       System.out.println(&quot;【注入属性】注入属性address&quot;);<br>       this.address = address;<br>   &#125;<br><br>   public int getPhone() &#123;<br>       return phone;<br>   &#125;<br><br>   public void setPhone(int phone) &#123;<br>       System.out.println(&quot;【注入属性】注入属性phone&quot;);<br>       this.phone = phone;<br>   &#125;<br><br>   @Override<br>   public String toString() &#123;<br>       return &quot;Person [address=&quot; + address + &quot;, name=&quot; + name + &quot;, phone=&quot;<br>               + phone + &quot;]&quot;;<br>   &#125;<br><br>   // 这是BeanFactoryAware接口方法<br>   @Override<br>   public void setBeanFactory(BeanFactory arg0) throws BeansException &#123;<br>       System.out<br>               .println(&quot;【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()&quot;);<br>       this.beanFactory = arg0;<br>   &#125;<br><br>   // 这是BeanNameAware接口方法<br>   @Override<br>   public void setBeanName(String arg0) &#123;<br>       System.out.println(&quot;【BeanNameAware接口】调用BeanNameAware.setBeanName()&quot;);<br>       this.beanName = arg0;<br>   &#125;<br><br>   // 这是InitializingBean接口方法<br>   @Override<br>   public void afterPropertiesSet() throws Exception &#123;<br>       System.out<br>               .println(&quot;【InitializingBean接口】调用InitializingBean.afterPropertiesSet()&quot;);<br>   &#125;<br><br>   // 这是DiposibleBean接口方法<br>   @Override<br>   public void destroy() throws Exception &#123;<br>       System.out.println(&quot;【DiposibleBean接口】调用DiposibleBean.destory()&quot;);<br>   &#125;<br><br>   // 通过&lt;bean&gt;的init-method属性指定的初始化方法<br>   public void myInit() &#123;<br>       System.out.println(&quot;【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法&quot;);<br>   &#125;<br><br>   // 通过&lt;bean&gt;的destroy-method属性指定的初始化方法<br>   public void myDestory() &#123;<br>       System.out.println(&quot;【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法&quot;);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></bean></p><p>2、接下来是演示BeanPostProcessor接口的方法，如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package springBeanTest;<br><br>import org.springframework.beans.BeansException;<br>import org.springframework.beans.factory.config.BeanPostProcessor;<br><br>public class MyBeanPostProcessor implements BeanPostProcessor &#123;<br><br>   public MyBeanPostProcessor() &#123;<br>       super();<br>       System.out.println(&quot;这是BeanPostProcessor实现类构造器！！&quot;);<br>       // TODO Auto-generated constructor stub<br>   &#125;<br><br>   @Override<br>   public Object postProcessAfterInitialization(Object arg0, String arg1)<br>           throws BeansException &#123;<br>       System.out<br>       .println(&quot;BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！&quot;);<br>       return arg0;<br>   &#125;<br><br>   @Override<br>   public Object postProcessBeforeInitialization(Object arg0, String arg1)<br>           throws BeansException &#123;<br>       System.out<br>       .println(&quot;BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！&quot;);<br>       return arg0;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如上，BeanPostProcessor接口包括2个方法: postProcessAfterInitialization和postProcessBeforeInitialization，这两个方法的第一个参数都是要处理的Bean对象，第二个参数都是Bean的name。返回值也都是要处理的Bean对象。这里要注意。</strong></p><p>3、InstantiationAwareBeanPostProcessor 接口本质是BeanPostProcessor的子接口，一般我们继承Spring为其提供的适配器类InstantiationAwareBeanPostProcessor Adapter来使用它，如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package springBeanTest;<br><br>import java.beans.PropertyDescriptor;<br><br>import org.springframework.beans.BeansException;<br>import org.springframework.beans.PropertyValues;<br>import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;<br><br>public class MyInstantiationAwareBeanPostProcessor extends<br>       InstantiationAwareBeanPostProcessorAdapter &#123;<br><br>   public MyInstantiationAwareBeanPostProcessor() &#123;<br>       super();<br>       System.out<br>               .println(&quot;这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！&quot;);<br>   &#125;<br><br>   // 接口方法、实例化Bean之前调用<br>   @Override<br>   public Object postProcessBeforeInstantiation(Class beanClass,<br>           String beanName) throws BeansException &#123;<br>       System.out<br>               .println(&quot;InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法&quot;);<br>       return null;<br>   &#125;<br><br>   // 接口方法、实例化Bean之后调用<br>   @Override<br>   public Object postProcessAfterInitialization(Object bean, String beanName)<br>           throws BeansException &#123;<br>       System.out<br>               .println(&quot;InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法&quot;);<br>       return bean;<br>   &#125;<br><br>   // 接口方法、设置某个属性时调用<br>   @Override<br>   public PropertyValues postProcessPropertyValues(PropertyValues pvs,<br>           PropertyDescriptor[] pds, Object bean, String beanName)<br>           throws BeansException &#123;<br>       System.out<br>               .println(&quot;InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法&quot;);<br>       return pvs;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>这个有3个方法，其中第二个方法postProcessAfterInitialization就是重写了BeanPostProcessor的方法。第三个方法postProcessPropertyValues用来操作属性，返回值也应该是PropertyValues对象。</strong></p><p>4、演示工厂后处理器接口方法，如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package springBeanTest;<br><br>import org.springframework.beans.BeansException;<br>import org.springframework.beans.factory.config.BeanDefinition;<br>import org.springframework.beans.factory.config.BeanFactoryPostProcessor;<br>import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;<br><br>public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;<br><br>   public MyBeanFactoryPostProcessor() &#123;<br>       super();<br>       System.out.println(&quot;这是BeanFactoryPostProcessor实现类构造器！！&quot;);<br>   &#125;<br><br>   @Override<br>   public void postProcessBeanFactory(ConfigurableListableBeanFactory arg0)<br>           throws BeansException &#123;<br>       System.out.println(&quot;BeanFactoryPostProcessor调用postProcessBeanFactory方法&quot;);<br>       BeanDefinition bd = arg0.getBeanDefinition(&quot;person&quot;);<br>       bd.getPropertyValues().addPropertyValue(&quot;phone&quot;, &quot;110&quot;);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>5、配置文件如下beans.xml，很简单，使用ApplicationContext处理器不用手动注册：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br><br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;<br>   xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;<br>   xsi:schemaLocation=&quot;<br>           http://www.springframework.org/schema/beans <br>           http://www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;&gt;<br><br>   &lt;bean id=&quot;beanPostProcessor&quot; class=&quot;springBeanTest.MyBeanPostProcessor&quot;&gt;<br>   &lt;/bean&gt;<br><br>   &lt;bean id=&quot;instantiationAwareBeanPostProcessor&quot; class=&quot;springBeanTest.MyInstantiationAwareBeanPostProcessor&quot;&gt;<br>   &lt;/bean&gt;<br><br>   &lt;bean id=&quot;beanFactoryPostProcessor&quot; class=&quot;springBeanTest.MyBeanFactoryPostProcessor&quot;&gt;<br>   &lt;/bean&gt;<br>   <br>   &lt;bean id=&quot;person&quot; class=&quot;springBeanTest.Person&quot; init-method=&quot;myInit&quot;<br>       destroy-method=&quot;myDestory&quot; scope=&quot;singleton&quot; p:name=&quot;张三&quot; p:address=&quot;广州&quot;<br>       p:phone=&quot;15900000000&quot; /&gt;<br><br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure></p><p>6、下面测试一下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package springBeanTest;<br><br>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;<br><br>public class BeanLifeCycle &#123;<br><br>   public static void main(String[] args) &#123;<br><br>       System.out.println(&quot;现在开始初始化容器&quot;);<br>       <br>       ApplicationContext factory = new ClassPathXmlApplicationContext(&quot;springBeanTest/beans.xml&quot;);<br>       System.out.println(&quot;容器初始化成功&quot;);    <br>       //得到Preson，并使用<br>       Person person = factory.getBean(&quot;person&quot;,Person.class);<br>       System.out.println(person);<br>       <br>       System.out.println(&quot;现在开始关闭容器！&quot;);<br>       ((ClassPathXmlApplicationContext)factory).registerShutdownHook();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关闭容器使用的是实际是AbstractApplicationContext的钩子方法。</p><p>我们来看一下结果：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs undefined">现在开始初始化容器<br>2014-5-18 15:46:20 org.springframework.context.support.AbstractApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@19a0c7c: startup date [Sun May 18 15:46:20 CST 2014]; root of context hierarchy<br>2014-5-18 15:46:20 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions<br>信息: Loading XML bean definitions from class path resource [springBeanTest/beans.xml]<br>这是BeanFactoryPostProcessor实现类构造器！！<br>BeanFactoryPostProcessor调用postProcessBeanFactory方法<br>这是BeanPostProcessor实现类构造器！！<br>这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！<br>2014-5-18 15:46:20 org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletons<br>信息: Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@9934d4: defining beans [beanPostProcessor,instantiationAwareBeanPostProcessor,beanFactoryPostProcessor,person]; root of factory hierarchy<br>InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法<br>【构造器】调用Person的构造器实例化<br>InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法<br>【注入属性】注入属性address<br>【注入属性】注入属性name<br>【注入属性】注入属性phone<br>【BeanNameAware接口】调用BeanNameAware.setBeanName()<br>【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()<br>BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！<br>【InitializingBean接口】调用InitializingBean.afterPropertiesSet()<br>【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法<br>BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！<br>InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法<br>容器初始化成功<br>Person [address=广州, name=张三, phone=110]<br>现在开始关闭容器！<br>【DiposibleBean接口】调用DiposibleBean.destory()<br>【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IntelliJ Idea 常用快捷键 列表(实战终极总结！！！！)</title>
      <link href="/2018/10/18/idea/"/>
      <url>/2018/10/18/idea/</url>
      
        <content type="html"><![CDATA[<p>IntelliJ Idea 常用快捷键 列表 总结<br><a id="more"></a></p><h3 id="自动代码"><a href="#自动代码" class="headerlink" title="自动代码"></a>自动代码</h3><p>常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码 。</p><p>例如要输入for(User user : users) 只需输入user.for+Tab ;</p><p><strong>再比如，要输入Date birthday = user.getBirthday() 只需输入user.getBirthday().var+Tab即可。<br>代码标签输入完成后，按Tab，生成代码。</strong></p><p>Ctrl+Alt+O 优化导入的类和包 </p><p>Alt+Insert 生成代码(如get,set方法,构造函数等)   或者右键（Generate） </p><p>fori/sout/psvm + Tab  </p><p>Ctrl+Alt+T  生成try catch  或者 Alt+enter </p><p>CTRL+ALT+T  把选中的代码放在 TRY{} IF{} ELSE{} 里 </p><p>Ctrl + O 重写方法  </p><p>Ctrl + I 实现方法 </p><p>Ctrl+shift+U 大小写转化  </p><p>ALT+回车    导入包,自动修正  </p><p>ALT+/       代码提示 </p><p>CTRL+J      自动代码  </p><p>Ctrl+Shift+J，整合两行为一行 </p><p>CTRL+空格   代码提示  </p><p>CTRL+SHIFT+SPACE 自动补全代码  </p><p>CTRL+ALT+L  格式化代码  </p><p>CTRL+ALT+I  自动缩进  </p><p>CTRL+ALT+O  优化导入的类和包  </p><p>ALT+INSERT  生成代码(如GET,SET方法,构造函数等)  </p><p>CTRL+E      最近更改的代码  </p><p>CTRL+ALT+SPACE  类名或接口名提示  </p><p>CTRL+P   方法参数提示  </p><p>CTRL+Q，可以看到当前方法的声明 </p><p>Shift+F6  重构-重命名 (包、类、方法、变量、甚至注释等) </p><p>Ctrl+Alt+V 提取变量 </p><h3 id="查询快捷键"><a href="#查询快捷键" class="headerlink" title="查询快捷键"></a>查询快捷键</h3><p>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 </p><p>CTRL+ALT+ left/right 前后导航编辑过的地方 </p><p>ALT+7  靠左窗口显示当前文件的结构 </p><p>Ctrl+F12 浮动显示当前文件的结构 </p><p>ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 </p><p>CTRL+ALT+F7  找到你的函数或者变量或者类的所有引用到的地方 </p><p>Ctrl+Shift+Alt+N 查找类中的方法或变量 </p><p>双击SHIFT 在项目的所有目录查找文件 </p><p>Ctrl+N   查找类 </p><p>Ctrl+Shift+N 查找文件 </p><p>CTRL+G   定位行  </p><p>CTRL+F   在当前窗口查找文本  </p><p>CTRL+SHIFT+F  在指定窗口查找文本  </p><p>CTRL+R   在 当前窗口替换文本  </p><p>CTRL+SHIFT+R  在指定窗口替换文本  </p><p>ALT+SHIFT+C  查找修改的文件  </p><p>CTRL+E   最近打开的文件  </p><p>F3   向下查找关键字出现位置  </p><p>SHIFT+F3  向上一个关键字出现位置  </p><p>选中文本，按Alt+F3 ，高亮相同文本，F3逐个往下查找相同文本 </p><p>F4   查找变量来源  </p><p>CTRL+SHIFT+O  弹出显示查找内容 </p><p>Ctrl+W 选中代码，连续按会有其他效果 </p><p>F2 或Shift+F2 高亮错误或警告快速定位 </p><p>Ctrl+Up/Down 光标跳转到第一行或最后一行下 </p><p>Ctrl+B 快速打开光标处的类或方法  </p><p>CTRL+ALT+B  找所有的子类  </p><p>CTRL+SHIFT+B  找变量的类  </p><p>Ctrl+Shift+上下键  上下移动代码 </p><p>Ctrl+Alt+ left/right 返回至上次浏览的位置 </p><p>Ctrl+X 删除行 </p><p>Ctrl+D 复制行 </p><p>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>…</em>/ ） </p><p>Ctrl+H 显示类结构图 </p><p>Ctrl+Q 显示注释文档 </p><p>Alt+F1 查找代码所在位置 </p><p>Alt+1 快速打开或隐藏工程面板 </p><p>Alt+ left/right 切换代码视图 </p><p>ALT+ ↑/↓  在方法间快速移动定位  </p><p>CTRL+ALT+ left/right 前后导航编辑过的地方 </p><p>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 </p><p>Alt+6    查找TODO </p><h3 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h3><p>SHIFT+ENTER 另起一行 </p><p>CTRL+Z   倒退(撤销) </p><p>CTRL+SHIFT+Z  向前(取消撤销) </p><p>CTRL+ALT+F12  资源管理器打开文件夹  </p><p>ALT+F1   查找文件所在目录位置  </p><p>SHIFT+ALT+INSERT 竖编辑模式  </p><p>CTRL+F4  关闭当前窗口 </p><p>Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 </p><p>Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） </p><h3 id="svn快捷键"><a href="#svn快捷键" class="headerlink" title="svn快捷键"></a>svn快捷键</h3><p>ctrl+k 提交代码到SVN </p><p>ctrl+t 更新代码 </p><h3 id="调试快捷键"><a href="#调试快捷键" class="headerlink" title="调试快捷键"></a>调试快捷键</h3><p>其实常用的 就是F8 F7 F9 最值得一提的就是Drop Frame 可以让运行过的代码从头再来。</p><p>alt+F8    debug时选中查看值 </p><p>Alt+Shift+F9，选择 Debug </p><p>Alt+Shift+F10，选择 Run </p><p>Ctrl+Shift+F9，编译 </p><p>Ctrl+Shift+F8，查看断点 </p><p>F7，步入 </p><p>Shift+F7，智能步入 </p><p>Alt+Shift+F7，强制步入 </p><p>F8，步过 </p><p>Shift+F8，步出 </p><p>Alt+Shift+F8，强制步过 </p><p>Alt+F9，运行至光标处 </p><p>Ctrl+Alt+F9，强制运行至光标处 </p><p>F9，恢复程序 </p><p>Alt+F10，定位到断点 </p><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>Ctrl+Alt+Shift+T，弹出重构菜单 </p><p>Shift+F6，重命名 </p><p>F6，移动 </p><p>F5，复制 </p><p>Alt+Delete，安全删除 </p><p>Ctrl+Alt+N，内联 </p><h3 id="十大Intellij-IDEA快捷键"><a href="#十大Intellij-IDEA快捷键" class="headerlink" title="十大Intellij IDEA快捷键"></a>十大Intellij IDEA快捷键</h3><p>Intellij IDEA中有很多快捷键让人爱不释手，stackoverflow上也有一些有趣的讨论。每个人都有自己的最爱，想排出个理想的榜单还真是困难。 </p><p>以前也整理过Intellij的快捷键，这次就按照我日常开发时的使用频率，简单分类列一下我最喜欢的十大快捷-神-键吧。 </p><p>1 <strong>智能提示:</strong><br>Intellij首当其冲的当然就是Intelligence智能！基本的代码提示用Ctrl+Space，还有更智能地按类型信息提示Ctrl+Shift+Space，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。</p><p>用F2/ Shift+F2移动到有错误的代码，Alt+Enter快速修复(即Eclipse中的Quick Fix功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲Ctrl+Shift+Enter就能自动补全末尾的字符。而且不只是括号，例如敲完if/for时也可以自动补上{}花括号。 </p><p>最后要说一点，Intellij能够智能感知Spring、Hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。 </p><p>2 <strong>重构:</strong><br>Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。 </p><p>切入正题，先说一个无敌的重构功能大汇总快捷键Ctrl+Shift+Alt+T，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如Shift+F6直接就是改名，Ctrl+Alt+V则是提取变量。 </p><p>3 <strong>代码生成：</strong><br>这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码，用Ctrl+J可以查看所有模板。后面“辅助”一节中将会讲到Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter/setter。 </p><p>另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入user.for+Tab。再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。 </p><p>4 <strong>编辑：</strong><br>编辑中不得不说的一大神键就是能够自动按语法选中代码的Ctrl+W以及反向的Ctrl+Shift+W了。此外，Ctrl+Left/Right移动光标到前/后单词，Ctrl+[/]移动到前/后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left/Right/[]加上Shift的话就能选中跳跃范围内的代码。Alt+Forward/Backward移动到前/后方法。还有些非常普通的像Ctrl+Y删除行、Ctrl+D复制行、Ctrl+折叠代码就不多说了。 </p><p>关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。另外，Intellij的书签功能也是不错的，用Ctrl+Shift+Num定义1-10书签(再次按这组快捷键则是删除书签)，然后通过Ctrl+Num跳转。这避免了多次使用前/下一编辑位置Ctrl+Left/Right来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。</p><p>5 <strong>查找打开：</strong><br>类似Eclipse，Intellij的Ctrl+N/Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按Shift+Shift即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。 </p><p>类的继承关系则可用Ctrl+H打开类层次窗口，在继承层次上跳转则用Ctrl+B/Ctrl+Alt+B分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用Ctrl+F12。 </p><p>要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用Ctrl+F/Ctrl+Shift+F在当前窗口或全工程中查找，再配合F3/Shift+F3前后移动到下一匹配处。 </p><p>Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。 </p><p>6 <strong>其他辅助：</strong><br>以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有：</p><p>Ø  命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。 </p><p>Ø  新建：Alt+Insert可以新建类、方法等任何东西。 </p><p>Ø  格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。 </p><p>Ø  切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。 </p><p>Ø  单元测试：Ctrl+Alt+T创建单元测试用例。 </p><p>Ø  运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。 </p><p>Ø  调试：F7/F8/F9分别对应Step into，Step over，Continue。<br><i><strong>此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。</strong> </i></p><p>Ø  Top #10切来切去：Ctrl+Tab </p><p>Ø  Top #9选你所想：Ctrl+W </p><p>Ø  Top #8代码生成：Template/Postfix +Tab </p><p>Ø  Top #7发号施令：Ctrl+Shift+A </p><p>Ø  Top #6无处藏身：Shift+Shift </p><p>Ø  Top #5自动完成：Ctrl+Shift+Enter </p><p>Ø  Top #4创造万物：Alt+Insert </p><p><strong>太难割舍，前三名并列吧！</strong></p><p>Ø  Top #1智能补全：Ctrl+Shift+Space </p><p>Ø  Top #1自我修复：Alt+Enter </p><p>Ø  Top #1重构一切：Ctrl+Shift+Alt+T </p><p>CTRL+ALT+ left/right 前后导航编辑过的地方<br>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方</p>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring_Ioc</title>
      <link href="/2018/10/18/Spring-Ioc/"/>
      <url>/2018/10/18/Spring-Ioc/</url>
      
        <content type="html"><![CDATA[<p>面试被问烂的 Spring IOC(求求你别再问了)<br><a id="more"></a></p><h3 id="广义的Ioc"><a href="#广义的Ioc" class="headerlink" title="广义的Ioc"></a>广义的Ioc</h3><p>1）IoC(Inversion of Control) 控制反转，即“不用打电话过来，我们会打给你”。</p><p>两种实现： 依赖查找（DL）和 依赖注入（DI）。</p><p>IoC 和 DI 、DL 的关系（这个 DL，Avalon 和 EJB 就是使用的这种方式实现的 IoC）：</p><p><img src="/images/20181018125125.png"></p><p>2) DL 已经被抛弃，因为他需要用户自己去是使用 API 进行查找资源和组装对象。即有侵入性。  </p><p>3) DI 是 Spring 使用的方式，容器负责组件的装配。</p><p><strong>注意：</strong><br>Java 使用 DI 方式实现 IoC 的不止 Spring，包括 Google 的 Guice，还有一个冷门的 PicoContainer（极度轻量，但只提供 IoC）。</p><h3 id="Spring的IoC"><a href="#Spring的IoC" class="headerlink" title="Spring的IoC"></a>Spring的IoC</h3><ol><li>依赖注入</li><li>依赖检查</li><li>自动装配</li><li>支持集合</li><li>指定初始化方法和销毁方法</li><li>支持回调某些方法(但是需要实现Spring接口，略有侵入)</li></ol><p>其中，最重要的就是依赖注入，从 XML 的配置上说， 即 ref 标签。对应 Spring RuntimeBeanReference 对象。</p><p><strong>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</strong>  </p><p>那么， Spring 如何设计容器的呢？  </p><p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。  </p><ol><li>BeanFactory</li><li>ApplicationContext</li></ol><p>BeanFactory 粗暴简单，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。</p><p>ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。</p><p>例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。  </p><p>该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p><p>当然，除了这两个大接口，还有其他的辅助接口，但我今天不会花太多篇幅介绍他们。</p><p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，我这里通过常用的 ClassPathXmlApplicationContext 类，来展示整个容器的层级 UML 关系。</p><p><img src="/images/20181018130402.png"></p><p>有点复杂？ 先不要慌，我来解释一下。</p><p>最上面的 BeanFactory 知道吧？我就不讲了。</p><p>下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p><p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p><p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p><p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置。生命周期事件回调等。</p><font color="#00ffff" size="4">好，解释了低级容器和高级容器，我们可以看看一个 IoC 启动过程是什么样子的。说白了，就是 ClassPathXmlApplicationContext 这个类，在启动时，都做了啥。</font><p>下图是 ClassPathXmlApplicationContext 的构造过程，实际就是 Spring IoC 的初始化过程。<br><img src="/images/20181018131026.png"></p><p>注意，这里为了理解方便，有所简化。</p><p>这里再用文字来描述这个过程：</p><ol><li>用户构造 ClassPathXmlApplicationContext（简称 CPAC）</li><li>CPAC 首先访问了 “抽象高级容器” 的 final 的 refresh 方法，这个方法是模板方法。所以要回调子类（低级容器）的 refreshBeanFactory 方法，这个方法的作用是使用低级容器加载所有 BeanDefinition 和 Properties 到容器中。</li><li>低级容器加载成功后，高级容器开始处理一些回调，例如 Bean 后置处理器。回调 setBeanFactory 方法。或者注册监听器等，发布事件，实例化单例 Bean 等等功能，这些功能，随着 Spring 的不断升级，功能越来越多，很多人在这里迷失了方向）。</li></ol><p>简单说就是：</p><ol><li>低级容器 加载配置文件（从 XML，数据库，Applet），并解析成 BeanDefinition 到低级容器中。</li><li>加载成功后，高级容器启动高级功能，例如接口回调，监听器，自动实例化单例，发布事件等等功能。</li></ol><p><strong>所以，一定要把 “低级容器” 和“高级容器” 的区别弄清楚。不能一叶障目不见泰山。</strong></p><p>好，当我们创建好容器，就会使用 getBean 方法，获取 Bean，而 getBean 的流程如下：<br><img src="/images/20181018131432.png" heigth="50%"></p><p>从图可以看出，getBean 的操作都是在低级容器里操作的。其中有个递归操作，这个是什么意思呢？</p><font color="#00ffff" size="4"><br>假设：当 Bean_A 依赖着 Bean_B，而这个 Bean_A 在加载的时候，其配置的 ref = “Bean_B” 在解析的时候只是一个占位符，被放入了 Bean_A 的属性集合中，当调用 getBean 时，需要真正 Bean_B 注入到 Bean_A 内部时，就需要从容器中获取这个 Bean_B，因此产生了递归。<br></font><p>为什么不是在加载的时候，就直接注入呢？因为加载的顺序不同，很可能 Bean_A 依赖的 Bean_B 还没有加载好，也就无法从容器中获取，你不能要求用户把 Bean 的加载顺序排列好，这是不人道的。</p><p>所以，Spring 将其分为了 2 个步骤：</p><ol><li><p>加载所有的 Bean 配置成 BeanDefinition 到容器中，如果 Bean 有依赖关系，则使用占位符暂时代替。</p></li><li><p>然后，在调用 getBean 的时候，进行真正的依赖注入，即如果碰到了属性是 ref 的（占位符），那么就从容器里获取这个 Bean，然后注入到实例中 —— 称之为依赖注入。<br>可以看到，依赖注入实际上，只需要 “低级容器” 就可以实现。  </p></li></ol><p>这就是 IoC。</p><p>所以 ApplicationContext refresh 方法里面的操作不只是 IoC，是高级容器的所有功能（包括 IoC），IoC 的功能在低级容器里就可以实现。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p><ol><li><p>加载配置文件，解析成 BeanDefinition 放在 Map 里。</p></li><li><p>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</p></li></ol><p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p><p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p><p>可以预见，随着 Spring 的不断发展，高级容器的功能会越来越多。</p><font color="#00ffff" size="4"><br>诚然，了解 IoC 的过程，实际上为了了解 Spring 初始化时，各个接口的回调时机。例如 InitializingBean，BeanFactoryAware，ApplicationListener 等等接口，这些接口的作用，笔者之前写过一篇文章进行介绍，有兴趣可以看一下，关键字：Spring 必知必会 扩展接口。<br></font><p>但是请注意，实现 Spring 接口代表着你这个应用就绑定死 Spring 了！代表 Spring 具有侵入性！要知道，Spring 发布时，无侵入性就是他最大的宣传点之一 —— 即 IoC 容器可以随便更换，代码无需变动。而现如今，Spring 已然成为 J2EE 社区准官方解决方案，也没有了所谓的侵入性这个说法。因为他就是标准，和 Servlet 一样，你能不实现 Servlet 的接口吗？: -)</p><p>好了，下次如果再有面试官问 Spring IoC 初始化过程，就再也不会含糊其词、支支吾吾了！！！</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_11</title>
      <link href="/2018/10/17/spring-annotation-day-11/"/>
      <url>/2018/10/17/spring-annotation-day-11/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天学习，@Profile注解的使用。<br><a id="more"></a></p><h3 id="Profile注解"><a href="#Profile注解" class="headerlink" title="@Profile注解"></a>@Profile注解</h3><p>Profile：Spring为我们提供的可以根据当前环境，动态的激活和切换一系列组件的功能。</p><p>比如：开发环境、测试环境、生产环境；</p><p>根据不同是环境，我们自动切换我们的数据源。</p><p>1）添加c3p0的数据源和mysql的驱动依赖：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt;<br> &lt;dependency&gt;<br>     &lt;groupId&gt;com.mchange&lt;/groupId&gt;<br>     &lt;artifactId&gt;c3p0&lt;/artifactId&gt;<br>     &lt;version&gt;0.9.5.2&lt;/version&gt;<br> &lt;/dependency&gt;<br> &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;<br> &lt;dependency&gt;<br>     &lt;groupId&gt;mysql&lt;/groupId&gt;<br>     &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br>     &lt;version&gt;8.0.12&lt;/version&gt;<br> &lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>2) 创建数据源的配置dbconfig.properties：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">db.user=root<br>db.password=123456<br>db.driverClass=com.mysql.jdbc.Driver<br></code></pre></td></tr></table></figure></p><p>3) 创建新的配置类MainConfigOfProfile：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@PropertySource(value = &quot;classpath:/dbconfig.properties&quot;)<br>public class MainConfigOfProfile implements EmbeddedValueResolverAware &#123;<br><br>    @Value(&quot;$&#123;db.user&#125;&quot;)<br>    private String user;<br><br>    private StringValueResolver valueResolver;<br>    private String driverClass;<br><br>    @Override<br>    public void setEmbeddedValueResolver(StringValueResolver resolver) &#123;<br>        this.valueResolver = resolver;<br>        String driverClass = valueResolver.resolveStringValue(&quot;$&#123;db.driverClass&#125;&quot;);<br>        this.driverClass = driverClass;<br>    &#125;<br><br><br>    @Bean(&quot;testDataSource&quot;)<br>    public DataSource dataSourceTest(@Value(&quot;$&#123;db.password&#125;&quot;) String pwd) throws PropertyVetoException &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(user);<br>        dataSource.setPassword(pwd);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);<br>        dataSource.setDriverClass(driverClass);<br>        return dataSource;<br>    &#125;<br><br>    @Bean(&quot;devDataSource&quot;)<br>    public DataSource dataSourceDev() throws PropertyVetoException &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(user);<br>        dataSource.setPassword(&quot;123456&quot;);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/school&quot;);<br>        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);<br>        return dataSource;<br>    &#125;<br><br>    @Bean(&quot;proDataSource&quot;)<br>    public DataSource dataSourcePro() throws PropertyVetoException &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(&quot;root&quot;);<br>        dataSource.setPassword(&quot;123456&quot;);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/sell&quot;);<br>        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);<br>        return dataSource;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>上述，有三个不同环境的数据源，test，dev，pro数据源，使用了不同的方式来给数据源进行赋值。</p><p>4）创建新的测试类IoCTest_Profile:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IoCTest_Profile &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfProfile.class);<br>        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();<br>        for (String name : beanDefinitionNames) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5) 运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfigOfProfile<br>testDataSource<br>devDataSource<br>proDataSource<br></code></pre></td></tr></table></figure></p><p>说明数据源都已经注入到容器中了。</p><hr><p>现在我们需要根据不同的环境，来指定加载需要的配置。</p><p>1)使用@Profile注解，是个属性、类加上一个标记的，标记这个属性或者类是属于这个环境的，只有激活了这个环境，才能被注册到容器中，默认激活default的环境，即@Profile(“default”）.</p><p>2)写在配置类上的@Profile，只能在该环境激活的情况下，整个配置类才能起作用，不管配置类里面的Bean是否是符合当前环境。</p><p>3）没有标记环境的bean，在任何环境下都是加载的</p><p><strong>验证：</strong></p><p>1) 在配置类MainConfigOfProfile中，给三个数据源加上标记：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@PropertySource(value = &quot;classpath:/dbconfig.properties&quot;)<br>public class MainConfigOfProfile implements EmbeddedValueResolverAware &#123;<br><br>    @Value(&quot;$&#123;db.user&#125;&quot;)<br>    private String user;<br><br>    private StringValueResolver valueResolver;<br>    private String driverClass;<br><br>    @Override<br>    public void setEmbeddedValueResolver(StringValueResolver resolver) &#123;<br>        this.valueResolver = resolver;<br>        String driverClass = valueResolver.resolveStringValue(&quot;$&#123;db.driverClass&#125;&quot;);<br>        this.driverClass = driverClass;<br>    &#125;<br><br><br>    @Profile(&quot;test&quot;)<br>    @Bean(&quot;testDataSource&quot;)<br>    public DataSource dataSourceTest(@Value(&quot;$&#123;db.password&#125;&quot;) String pwd) throws PropertyVetoException &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(user);<br>        dataSource.setPassword(pwd);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);<br>        dataSource.setDriverClass(driverClass);<br>        return dataSource;<br>    &#125;<br><br>    @Profile(&quot;dev&quot;)<br>    @Bean(&quot;devDataSource&quot;)<br>    public DataSource dataSourceDev() throws PropertyVetoException &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(user);<br>        dataSource.setPassword(&quot;123456&quot;);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/school&quot;);<br>        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);<br>        return dataSource;<br>    &#125;<br><br>    @Profile(&quot;pro&quot;)<br>    @Bean(&quot;proDataSource&quot;)<br>    public DataSource dataSourcePro() throws PropertyVetoException &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(&quot;root&quot;);<br>        dataSource.setPassword(&quot;123456&quot;);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/sell&quot;);<br>        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);<br>        return dataSource;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 设置当前的环境：</p><p><strong>方法一：</strong>  </p><p> 配置虚拟机的运行参数。</p><p>-Dspring.profiles.active=test</p><p>运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfigOfProfile<br>testDataSource<br></code></pre></td></tr></table></figure></p><p>此时，容器中只有testDataSource数据源了。</p><hr><p>-Dspring.profiles.active=dev</p><p>运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfigOfProfile<br>devDataSource<br></code></pre></td></tr></table></figure></p><p>此时，容器中只有devDataSource数据源了。</p><p><strong>方法二：</strong>  </p><p>使用无参数的AnnotationConfigApplicationContext容器。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IoCTest_Profile &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        //1.无参数<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();<br>        //2.设置环境,这里激活了test和dev<br>        applicationContext.getEnvironment().setActiveProfiles(&quot;test&quot;,&quot;dev&quot;);<br>        //3.设置配置类<br>        applicationContext.register(MainConfigOfProfile.class);<br>        //4.刷新容器<br>        applicationContext.refresh();<br><br><br>        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();<br>        for (String name : beanDefinitionNames) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfigOfProfile<br>testDataSource<br>devDataSource<br></code></pre></td></tr></table></figure></p><p>这里，test和dev数据源被激活了。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_10</title>
      <link href="/2018/10/17/spring-annotation-day-10/"/>
      <url>/2018/10/17/spring-annotation-day-10/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>自定义组件想要使用Spring容器底层的一些组件的开发(ApplicationContext,BeanFactory,xxx)<br><a id="more"></a></p><p>自定义组件实现xxxAware，在创建对象的时候，会调用接口规定的方法注入相关组件，Aware会把Spring底层的一些组件注入到自定义的Bean中。</p><p>xxxAware:功能使用xxxAwareProcessor现实的，比如：ApplicationContextAware是用ApplicationContextAwareProcessor注入的。</p><h3 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h3><p>1）在com.liuzhuo.bean包，随便找个Bean来实验：</p><p>这里使用Red类来实验：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Red implements ApplicationContextAware &#123;<br><br>    private ApplicationContext applicationContext;<br><br>    @Override<br>    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;<br>        this.applicationContext = applicationContext;<br>        System.out.println(&quot;容器:&quot; + applicationContext.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2）将Red类注入到容器中，使用包扫描，修改MainConfigOfAutowired配置类：<br><strong>加入了com.liuzhuo.bean包的扫描</strong><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(value = &#123;&quot;com.liuzhuo.controller&quot;, &quot;com.liuzhuo.service&quot;, &quot;com.liuzhuo.dao&quot;,&quot;com.liuzhuo.bean&quot;&#125;)<br>public class MainConfigOfAutowired<br></code></pre></td></tr></table></figure></p><p>3) 运行测试类IocTest_Autowired：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocTest_Autowired &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAutowired.class);<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs undefined">org.springframework.context.event.internalEventListenerProcessor------postProcessBeforeInitialization<br>org.springframework.context.event.internalEventListenerProcessor------postProcessAfterInitialization<br>org.springframework.context.event.internalEventListenerFactory------postProcessBeforeInitialization<br>org.springframework.context.event.internalEventListenerFactory------postProcessAfterInitialization<br>mainConfigOfAutowired------postProcessBeforeInitialization<br>mainConfigOfAutowired------postProcessAfterInitialization<br>bookController------postProcessBeforeInitialization<br>bookController------postProcessAfterInitialization<br>bookDao2------postProcessBeforeInitialization<br>bookDao2------postProcessAfterInitialization<br>bookService------postProcessBeforeInitialization<br>bookService------postProcessAfterInitialization<br>bookDao------postProcessBeforeInitialization<br>bookDao------postProcessAfterInitialization<br>Cat constructer ···<br>cat------postProcessBeforeInitialization<br>Cat afterPropertiesSet ····<br>cat------postProcessAfterInitialization<br>Dog construct ····<br>dog------postProcessBeforeInitialization<br>Dog @PostConstruct ····<br>dog------postProcessAfterInitialization<br>容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:08:27 CST 2018]; root of context hierarchy<br>red------postProcessBeforeInitialization<br>red------postProcessAfterInitialization<br>Dog @PreDestroy ····<br>Cat destroy ····<br>十月 17, 2018 2:08:28 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:08:27 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>能观察到：</p><p><code>容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:08:27 CST 2018]; root of context hierarchy</code></p><p>说明在Red类中，注入了容器类。</p><p>5）验证是否是同一个容器，修改测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocTest_Autowired &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAutowired.class);<br>        System.out.println(applicationContext);<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>6) 运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs undefined">org.springframework.context.event.internalEventListenerProcessor------postProcessBeforeInitialization<br>org.springframework.context.event.internalEventListenerProcessor------postProcessAfterInitialization<br>org.springframework.context.event.internalEventListenerFactory------postProcessBeforeInitialization<br>org.springframework.context.event.internalEventListenerFactory------postProcessAfterInitialization<br>mainConfigOfAutowired------postProcessBeforeInitialization<br>mainConfigOfAutowired------postProcessAfterInitialization<br>bookController------postProcessBeforeInitialization<br>bookController------postProcessAfterInitialization<br>bookDao2------postProcessBeforeInitialization<br>bookDao2------postProcessAfterInitialization<br>bookService------postProcessBeforeInitialization<br>bookService------postProcessAfterInitialization<br>bookDao------postProcessBeforeInitialization<br>bookDao------postProcessAfterInitialization<br>Cat constructer ···<br>cat------postProcessBeforeInitialization<br>Cat afterPropertiesSet ····<br>cat------postProcessAfterInitialization<br>Dog construct ····<br>dog------postProcessBeforeInitialization<br>Dog @PostConstruct ····<br>dog------postProcessAfterInitialization<br>容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:14:10 CST 2018]; root of context hierarchy<br>red------postProcessBeforeInitialization<br>red------postProcessAfterInitialization<br>十月 17, 2018 2:14:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:14:10 CST 2018]; root of context hierarchy<br>org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:14:10 CST 2018]; root of context hierarchy<br>Dog @PreDestroy ····<br>Cat destroy ····<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>观察到：<br>容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: </p><p>org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf:</p><p>一样，都是@2f410acf，说明是一个容器。</p><hr><h3 id="BeanNameAware"><a href="#BeanNameAware" class="headerlink" title="BeanNameAware"></a>BeanNameAware</h3><p>给自定义组件，注入自己在容器的id名。</p><p>1）修改Red类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Red implements ApplicationContextAware,BeanNameAware &#123;<br><br>    private ApplicationContext applicationContext;<br><br>    @Override<br>    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;<br>        this.applicationContext = applicationContext;<br>        System.out.println(&quot;容器:&quot; + applicationContext.toString());<br>    &#125;<br><br>    @Override<br>    public void setBeanName(String name) &#123;<br>        System.out.println(&quot;自定义组件的id名字：&quot;+name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">自定义组件的id名字：red<br>容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:21:56 CST 2018]; root of context hierarchy<br>red------postProcessBeforeInitialization<br>red------postProcessAfterInitialization<br></code></pre></td></tr></table></figure></p><p><strong>总结：</strong></p><p>想让自定义组件使用Spring底层的组件，就实现xxxAware接口就行。</p><p>ApplicationContextAware<br>ApplicationEventPublisherAware<br>BeanClassLoaderAware<br>BeanFactoryAware<br>BeanNameAware<br>BootstrapContextAware<br>EmbeddedValueResolverAware<br>EnvironmentAware<br>ImportAware<br>LoadTimeWeaverAware<br>MessageSourceAware<br>NotificationPublisherAware<br>PortletConfigAware<br>PortletContextAware<br>ResourceLoaderAware<br>SchedulerContextAware<br>ServletConfigAware<br>ServletContextAware</p><hr><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>1）在Red类下的setApplicationContext方法上面打上断点</p><p>2) 运行测试方法：</p><p>发现ApplicationContextAware是由ApplicationContextAwareProcessor处理的：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException &#123;<br>AccessControlContext acc = null;<br><br>if (System.getSecurityManager() != null &amp;&amp;<br>(bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||<br>bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||<br>bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) &#123;<br>acc = this.applicationContext.getBeanFactory().getAccessControlContext();<br>&#125;<br><br>if (acc != null) &#123;<br>AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;<br>@Override<br>public Object run() &#123;<br>invokeAwareInterfaces(bean);<br>return null;<br>&#125;<br>&#125;, acc);<br>&#125;<br>else &#123;<br>invokeAwareInterfaces(bean);<br>&#125;<br><br>return bean;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>内部执行postProcessBeforeInitialization方法来判断自定义的组件是否实现类xxxAware接口。</p><p>最后调用invokeAwareInterfaces(bean)方法</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">private void invokeAwareInterfaces(Object bean) &#123;<br>if (bean instanceof Aware) &#123;<br>if (bean instanceof EnvironmentAware) &#123;<br>((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());<br>&#125;<br>if (bean instanceof EmbeddedValueResolverAware) &#123;<br>((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);<br>&#125;<br>if (bean instanceof ResourceLoaderAware) &#123;<br>((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);<br>&#125;<br>if (bean instanceof ApplicationEventPublisherAware) &#123;<br>((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);<br>&#125;<br>if (bean instanceof MessageSourceAware) &#123;<br>((MessageSourceAware) bean).setMessageSource(this.applicationContext);<br>&#125;<br>if (bean instanceof ApplicationContextAware) &#123;<br>((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用相应的方法来实现注入。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_09</title>
      <link href="/2018/10/16/spring-annotation-day-09/"/>
      <url>/2018/10/16/spring-annotation-day-09/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>Spring的自动装配：  </p><p>Spring利用依赖注入(DI)，完成对IoC容器中各个组件的依赖关系赋值。<br><a id="more"></a></p><h3 id="Autowired注解"><a href="#Autowired注解" class="headerlink" title="@Autowired注解"></a>@Autowired注解</h3><p>1）在com.liuzhuo.config包下，创建新的类MainConfigOfAutowired：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并扫描三个包.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(value = &#123;&quot;com.liuzhuo.controller&quot;, &quot;com.liuzhuo.service&quot;, &quot;com.liuzhuo.dao&quot;&#125;)<br>public class MainConfigOfAutowired &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 修改BookService类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    @Autowired<br>    private BookDao bookDao;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 修改BookDao类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Repository<br>public class BookDao &#123;<br><br>    private Integer laber = 1;<br><br>    public BookDao() &#123;<br>    &#125;<br><br>    public BookDao(Integer laber) &#123;<br>        this.laber = laber;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookDao&#123;&quot; +<br>                &quot;laber=&quot; + laber +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 创建新的测试类IocTest_Autowired：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocTest_Autowired &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAutowired.class);<br>        BookService bookService = applicationContext.getBean(BookService.class);<br>        System.out.println(bookService);<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5) 运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:20:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:20:48 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=BookDao&#123;laber=1&#125;&#125;<br>十月 16, 2018 9:20:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:20:48 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>看到，BookService对象中的BookDao对象也注入进来了。</p><hr><p>当我们有多个相同类型的对象时，会注入哪个对象呢？</p><p>1）我们在配置文件MainConfigOfAutowired中添加先的BookDao对象：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(value = &#123;&quot;com.liuzhuo.controller&quot;, &quot;com.liuzhuo.service&quot;, &quot;com.liuzhuo.dao&quot;&#125;)<br>public class MainConfigOfAutowired &#123;<br><br>    @Bean<br>    public BookDao bookDao() &#123;<br>        return new BookDao(2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2）运行测试：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:27:35 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:27:35 CST 2018]; root of context hierarchy<br>十月 16, 2018 9:27:36 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>BookService&#123;bookDao=BookDao&#123;laber=1&#125;&#125;<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:27:35 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p><strong>结果不变，说明有多个相同类型时，注入到容器中的对象是与@AutoWired下面属性的名字相同的id的Bean对象。</strong></p><p>3）验证我们的结论，修改BookService类下的属性BookDao的属性名字：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    @Autowired<br>    private BookDao bookDao2;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao2 +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 运行测试：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:30:54 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:30:54 CST 2018]; root of context hierarchy<br>十月 16, 2018 9:30:54 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>BookService&#123;bookDao=BookDao&#123;laber=2&#125;&#125;<br><br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:30:54 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>验证正确，说明注入的Bean是与属性的名字相同的对象。</p><hr><p>除了，上述的方法来处理多个相同类型的对象。我们还可以使用 @Qualifier来指定注入容器中的Bean的id名。</p><p>1）修改BookService类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    @Qualifier(&quot;bookDao&quot;)<br>    @Autowired<br>    private BookDao bookDao2;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao2 +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 测试：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:34:12 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:34:12 CST 2018]; root of context hierarchy<br>十月 16, 2018 9:34:12 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:34:12 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=BookDao&#123;laber=1&#125;&#125;<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>此时注入容器中的BookDao对象就是@Qualifier(“bookDao”)注解的对象，而不是bookDao2了。</p><hr><p>默认情况下，@Autowired注解的属性，必须要在容器中已经注入了，否则会报错。</p><p>1）将刚刚的两个BookDao对象都注释掉。</p><p>2）运行测试：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:38:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:38:48 CST 2018]; root of context hierarchy<br>十月 16, 2018 9:38:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext refresh<br>警告: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;bookService&apos;: Unsatisfied dependency expressed through field &apos;bookDao2&apos;; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &apos;com.liuzhuo.dao.BookDao&apos; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125;<br><br>org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;bookService&apos;: Unsatisfied dependency expressed through field &apos;bookDao2&apos;; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &apos;com.liuzhuo.dao.BookDao&apos; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125;<br><br>at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:588)<br>at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:88)<br>at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:366)<br>at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1264)<br>at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553)<br>at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)<br>at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)<br>at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)<br>at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)<br>at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)<br>at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761)<br>at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:867)<br>at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:543)<br>at org.springframework.context.annotation.AnnotationConfigApplicationContext.&lt;init&gt;(AnnotationConfigApplicationContext.java:84)<br>at com.liuzhuo.test.IocTest_Autowired.test01(IocTest_Autowired.java:18)<br>at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>at java.lang.reflect.Method.invoke(Method.java:498)<br>at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)<br>at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)<br>at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)<br>at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)<br>at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)<br>at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)<br>at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)<br>at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)<br>at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)<br>at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)<br>at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)<br>at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)<br>at org.junit.runners.ParentRunner.run(ParentRunner.java:363)<br>at org.junit.runner.JUnitCore.run(JUnitCore.java:137)<br>at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)<br>at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)<br>at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)<br>at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)<br>Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &apos;com.liuzhuo.dao.BookDao&apos; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125;<br>at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoMatchingBeanFound(DefaultListableBeanFactory.java:1493)<br>at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1104)<br>at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1066)<br>at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:585)<br>... 36 more<br><br><br>Process finished with exit code -1<br></code></pre></td></tr></table></figure></p><p>我们也可以使@Autowired注解的属性，不是必须的。<br>因为@Autowired注解里面有一个属性 boolean required() default true;<br>将required设置为：false</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    //@Qualifier(&quot;bookDao&quot;)<br>    @Autowired(required = false)<br>    private BookDao bookDao2;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao2 +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:43:23 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:43:23 CST 2018]; root of context hierarchy<br>十月 16, 2018 9:43:24 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:43:23 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=null&#125;<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>此时不报错了。修改了默认情况下，必须给@Autowired注解的属性，注入到容器中。</p><hr><p>@primary注解：使用这个注解，就是当有多个类型的情况下，优先注入的bean对象：</p><p>1) 修改配置文件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(value = &#123;&quot;com.liuzhuo.controller&quot;, &quot;com.liuzhuo.service&quot;, &quot;com.liuzhuo.dao&quot;&#125;)<br>public class MainConfigOfAutowired &#123;<br><br>    @Primary<br>    @Bean(value = &quot;bookDao2&quot;)<br>    public BookDao bookDao() &#123;<br>        return new BookDao(2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 修改BookService：注释掉@Qualifier(“bookDao”)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    //@Qualifier(&quot;bookDao&quot;)<br>    @Autowired(required = false)<br>    private BookDao bookDao;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 运行测试：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:47:44 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:47:44 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=BookDao&#123;laber=2&#125;&#125;<br>十月 16, 2018 9:47:44 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:47:44 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>此时，输出的是laber=2的BookDao对象了，不再根据@Autowired注解下的属性名来注入到容器中了。</p><p>4）将BookService中的@Qualifier(“bookDao”)的注释去掉：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    @Qualifier(&quot;bookDao&quot;)<br>    @Autowired(required = false)<br>    private BookDao bookDao;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5) 运行测试：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:51:00 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:51:00 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=BookDao&#123;laber=1&#125;&#125;<br>十月 16, 2018 9:51:00 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:51:00 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p><strong>说明：当@Primary和@Qualifier同时存在时，是以@Qualifier为标准的！</strong></p><hr><h3 id="Resource注解"><a href="#Resource注解" class="headerlink" title="@Resource注解"></a>@Resource注解</h3><p>1）修改BookService类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    //@Qualifier(&quot;bookDao&quot;)<br>    //@Autowired(required = false)<br>    @Resource<br>    private BookDao bookDao;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 10:09:41 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:09:41 CST 2018]; root of context hierarchy<br>十月 16, 2018 10:09:41 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:09:41 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=BookDao&#123;laber=1&#125;&#125;<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>此时，输出的是laber=1的bookService对象，说明@primary注解没有起作用。<br>@Resource注解，默认是注入属性的名。也可以通过@Resource的name属性来修改需要注入到容器中的Bean对象。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    //@Qualifier(&quot;bookDao&quot;)<br>    //@Autowired(required = false)<br>    @Resource(name = &quot;bookDao2&quot;)<br>    private BookDao bookDao;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 10:13:02 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:13:02 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=BookDao&#123;laber=2&#125;&#125;<br>十月 16, 2018 10:13:02 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:13:02 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><hr><h3 id="Inject注解"><a href="#Inject注解" class="headerlink" title="@Inject注解"></a>@Inject注解</h3><p>@Inject注解：需要导入javax.inject包。</p><p>1）在pom文件中添加依赖：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependency&gt;<br>    &lt;groupId&gt;javax.inject&lt;/groupId&gt;<br>    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;<br>    &lt;version&gt;1&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>2) 修改BookService类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    //@Qualifier(&quot;bookDao&quot;)<br>    //@Autowired(required = false)<br>    //@Resource(name = &quot;bookDao2&quot;)<br>    @Inject<br>    private BookDao bookDao;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 10:16:52 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:16:52 CST 2018]; root of context hierarchy<br>十月 16, 2018 10:16:52 下午 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &lt;init&gt;<br>信息: JSR-330 &apos;javax.inject.Inject&apos; annotation found and supported for autowiring<br>BookService&#123;bookDao=BookDao&#123;laber=2&#125;&#125;<br>十月 16, 2018 10:16:52 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:16:52 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>输出的是laber=2的BookService对象，说明支持@primary注解。</p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1）@Autowired：自动注入<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1）、默认优先按照类型去容器中找对应的组件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2）、如果找到多个相同类型的组件，再将属性的名称作为组件的id去容器中查找<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.3）、@Qualifier：使用@Qualifier指定需要装配的组件的id，而不使用属性名<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.4）、自动装配默认是一定将属性赋值好，没有就报错。可以使用@Autowired(required=false)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.5）、@Primary:当存在多个同类型的Bean时，优先装配的Bean，优先级没有@Qualifier高。  </p><p>2）Spring还支持使用@Resource(JSR250)和@Inject(JSR330)[java规范的注解]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Resource：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以和@Autowired一样实现自动装配功能，默认是按照组件名称进行装配的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不支持@primary功能和@Autowired(required=false)功能，但是有@Resource(name = “bookDao2”)修改注入容器Bean的id的功能。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Inject：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要导入javax.inject包，和@Autowired的功能一样，但是没有required=false的功能。</p><p>3）@Autowired是Spring定义的，只能在有Spring的环境时才有作用，@Resource和@Inject注解是java规范，只有是满足java规范的都可以使用，意思就是跨框架性更好。</p><p>4）上述自动注入都是通过AutowiredAnnotationBeanPostProcessor这个后置处理器完成。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_08</title>
      <link href="/2018/10/16/spring-annotation-day-08/"/>
      <url>/2018/10/16/spring-annotation-day-08/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天，学习Spring的自动注入<br><a id="more"></a></p><h3 id="Value注解"><a href="#Value注解" class="headerlink" title="@Value注解"></a>@Value注解</h3><p>使用@Value注解来注入值</p><p>1）在com.liuzhuo.config包下，创建新的配置类MainConfigOfProperty：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class MainConfigOfProperty &#123;<br><br>    @Bean<br>    public Person person() &#123;<br>        return new Person();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2）在com.liuzhuo.test包下，创建新的测试类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class PropertyTest &#123;<br><br>    private AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfProperty.class);<br><br>    @Test<br>    public void test01() &#123;<br>        printBeanName(applicationContext);<br>        Person person = (Person) applicationContext.getBean(&quot;person&quot;);<br>        System.out.println(person);<br>        applicationContext.close();<br>    &#125;<br><br>    private void printBeanName(AnnotationConfigApplicationContext applicationContext) &#123;<br>        String[] names = applicationContext.getBeanDefinitionNames();<br>        for (String name : names) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 运行测试方法：test01<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">org.springframework.context.annotation.internalConfigurationAnnotationProcessor<br>org.springframework.context.annotation.internalAutowiredAnnotationProcessor<br>org.springframework.context.annotation.internalRequiredAnnotationProcessor<br>org.springframework.context.annotation.internalCommonAnnotationProcessor<br>org.springframework.context.event.internalEventListenerProcessor<br>org.springframework.context.event.internalEventListenerFactory<br>mainConfigOfProperty<br>person<br>Person&#123;name=&apos;null&apos;, age=null&#125;<br>十月 16, 2018 5:34:32 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2ff5659e: startup date [Tue Oct 16 17:34:31 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>我们能看到，打印出来的Person对象的属性都是null。</p><p>4）修改Person类<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Person &#123;<br><br>    /*<br>    * value:<br>    *     1.使用直接值，比如字符串，数值等<br>    *     2.使用SpEL表达式，#&#123;&#125;<br>    *     3.使用$&#123;&#125;,获取资源文件中的数据<br>    * */<br>    @Value(&quot;张三&quot;)<br>    private String name;<br>    @Value(&quot;#&#123;20-2&#125;&quot;)<br>    private Integer age;<br>    <br>    ·····<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5）再次运行test01：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">org.springframework.context.annotation.internalConfigurationAnnotationProcessor<br>org.springframework.context.annotation.internalAutowiredAnnotationProcessor<br>org.springframework.context.annotation.internalRequiredAnnotationProcessor<br>org.springframework.context.annotation.internalCommonAnnotationProcessor<br>org.springframework.context.event.internalEventListenerProcessor<br>org.springframework.context.event.internalEventListenerFactory<br>mainConfigOfProperty<br>person<br>Person&#123;name=&apos;张三&apos;, age=18&#125;<br>十月 16, 2018 5:37:41 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2ff5659e: startup date [Tue Oct 16 17:37:41 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><hr><h3 id="PropertySource注解"><a href="#PropertySource注解" class="headerlink" title="@PropertySource注解"></a>@PropertySource注解</h3><p>使用@PropertySource注解来获取资源配置文件中的数据。</p><p>1）在resource包下，创建person.properties文件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">person.nickName=小张三<br></code></pre></td></tr></table></figure></p><p>2) 修改Person类：<br>添加nickName属性和对应的get、set方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Person &#123;<br><br>    /*<br>     * value:<br>     *     1.使用直接值，比如字符串，数值等<br>     *     2.使用SpEL表达式，#&#123;&#125;<br>     *     3.使用$&#123;&#125;,获取资源文件中的数据<br>     * */<br>    @Value(&quot;张三&quot;)<br>    private String name;<br>    @Value(&quot;#&#123;20-2&#125;&quot;)<br>    private Integer age;<br>    @Value(&quot;$&#123;person.nickName&#125;&quot;)<br>    private String nickName;<br>    <br>    ·····<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3）在配置文件中，加入资源文件的扫描：<br>&nbsp;&nbsp;&nbsp;@PropertySource(value = “classpath:person.properties”)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@PropertySource(value = &quot;classpath:person.properties&quot;)<br>public class MainConfigOfProperty<br></code></pre></td></tr></table></figure></p><p>这里的@PropertySource(value = “classpath:person.properties”)，相当于以前在xml中的配置的<br>&lt;context:property-placeholder location=”person.properties”/&gt;，如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>       xsi:schemaLocation=&quot;<br>        http://www.springframework.org/schema/beans<br>        http://www.springframework.org/schema/beans/spring-beans.xsd<br>        http://www.springframework.org/schema/context<br>        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;<br><br>    &lt;!--包扫描、只要标注了@Controller、@Service、@Repository、@Component都会自动注入到容器中--&gt;<br>    &lt;!--&lt;context:component-scan base-package=&quot;com.liuzhuo&quot;/&gt;--&gt;<br><br>    &lt;!--扫描资源文件--&gt;<br>    &lt;context:property-placeholder location=&quot;person.properties&quot;/&gt;<br><br>    &lt;!--以前的开发模式，使用配置文件--&gt;<br>    &lt;bean id=&quot;person&quot; class=&quot;com.liuzhuo.bean.Person&quot; init-method=&quot;&quot; destroy-method=&quot;&quot;&gt;<br>        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;<br>        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;<br>    &lt;/bean&gt;<br><br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure></p><p>4) 运行test01：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfigOfProperty<br>person<br>Person&#123;name=&apos;张三&apos;, age=18, nickName=&apos;小张三&apos;&#125;<br></code></pre></td></tr></table></figure></p><p>这里的昵称，小张三也打印出来了。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_07</title>
      <link href="/2018/10/16/spring-annotation-day-07/"/>
      <url>/2018/10/16/spring-annotation-day-07/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天学习BeanPostProcessor的生命周期流程<br><a id="more"></a></p><h3 id="BeanPostProcessor的生命周期流程"><a href="#BeanPostProcessor的生命周期流程" class="headerlink" title="BeanPostProcessor的生命周期流程"></a>BeanPostProcessor的生命周期流程</h3><p>我们知道BeanPostProcessor是后置处理器，是在Bean初始化前后执行一些列操作的，底层到底是怎么执行的呢？现在debug一下。</p><p>1）设置断点，在com.liuzhuo.bean包下的MyBeanPostProcessor类中，给postProcessBeforeInitialization方法设置断点。</p><p><img src="/images/20181016100600.png"></p><p>2) debug一下。发现调用栈如下：</p><p><img src="/images/20181016101036.png" style="width:50%"></p><p>程序是从test01开始：</p><p>1）创建AnnotationConfigApplicationContext对象  </p><p>2）执行AnnotationConfigApplicationContext的构造方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) &#123;<br>this();<br>register(annotatedClasses);<br>refresh();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 调用refresh()方法：完成一系列资源配置操作。最后调用finishBeanFactoryInitialization()方法，初始化容器。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public void refresh() throws BeansException, IllegalStateException &#123;<br>synchronized (this.startupShutdownMonitor) &#123;<br>// Prepare this context for refreshing.<br>prepareRefresh();<br><br>// Tell the subclass to refresh the internal bean factory.<br>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<br><br>// Prepare the bean factory for use in this context.<br>prepareBeanFactory(beanFactory);<br><br>try &#123;<br>// Allows post-processing of the bean factory in context subclasses.<br>postProcessBeanFactory(beanFactory);<br><br>// Invoke factory processors registered as beans in the context.<br>invokeBeanFactoryPostProcessors(beanFactory);<br><br>// Register bean processors that intercept bean creation.<br>registerBeanPostProcessors(beanFactory);<br><br>// Initialize message source for this context.<br>initMessageSource();<br><br>// Initialize event multicaster for this context.<br>initApplicationEventMulticaster();<br><br>// Initialize other special beans in specific context subclasses.<br>onRefresh();<br><br>// Check for listener beans and register them.<br>registerListeners();<br><br>// Instantiate all remaining (non-lazy-init) singletons.<br>finishBeanFactoryInitialization(beanFactory);<br><br>// Last step: publish corresponding event.<br>finishRefresh();<br>&#125;<br><br>catch (BeansException ex) &#123;<br>if (logger.isWarnEnabled()) &#123;<br>logger.warn(&quot;Exception encountered during context initialization - &quot; +<br>&quot;cancelling refresh attempt: &quot; + ex);<br>&#125;<br><br>// Destroy already created singletons to avoid dangling resources.<br>destroyBeans();<br><br>// Reset &apos;active&apos; flag.<br>cancelRefresh(ex);<br><br>// Propagate exception to caller.<br>throw ex;<br>&#125;<br><br>finally &#123;<br>// Reset common introspection caches in Spring&apos;s core, since we<br>// might not ever need metadata for singleton beans anymore...<br>resetCommonCaches();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4）进入finishBeanFactoryInitialization：<br>调用<br><code>beanFactory.preInstantiateSingletons();</code></p><p>5) 最终调用doCreateBean()方法：<br>我们主要看其中的：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">      // Initialize the bean instance.<br>Object exposedObject = bean;<br>try &#123;<br>populateBean(beanName, mbd, instanceWrapper);<br>if (exposedObject != null) &#123;<br>exposedObject = initializeBean(beanName, exposedObject, mbd);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>populateBean:给Bean的属性赋值等操作<br>initializeBean:Bean初始化操作。</p><p>6）点击initializeBean方法:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Object wrappedBean = bean;<br>if (mbd == null || !mbd.isSynthetic()) &#123;<br>wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>&#125;<br><br>try &#123;<br>invokeInitMethods(beanName, wrappedBean, mbd);<br>&#125;<br>catch (Throwable ex) &#123;<br>throw new BeanCreationException(<br>(mbd != null ? mbd.getResourceDescription() : null),<br>beanName, &quot;Invocation of init method failed&quot;, ex);<br>&#125;<br><br>if (mbd == null || !mbd.isSynthetic()) &#123;<br>wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>&#125;<br>return wrappedBean;<br></code></pre></td></tr></table></figure></p><p>其中：<br>applyBeanPostProcessorsBeforeInitialization：完成初始化之前的操作。</p><p>invokeInitMethods：初始化是操作(@PostConstruc、init-method等)</p><p>applyBeanPostProcessorsAfterInitialization：完成初始化之后的操作。</p><p>7）点击applyBeanPostProcessorsBeforeInitialization：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)<br>throws BeansException &#123;<br><br>Object result = existingBean;<br>for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;<br>result = beanProcessor.postProcessBeforeInitialization(result, beanName);<br>if (result == null) &#123;<br>return result;<br>&#125;<br>&#125;<br>return result;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>发现：就是使用for循环来调用一系列BeanPostProcessor接口的实现类，包括Spring容器自身的和我们自定义的实现类。</p><p><strong>注意:如果其中的某一个BeanPostProcessor实现类返回了null，那么后面的BeanPostProcessor实现类就不执行了！！！</strong></p><p>大概的流程就走完了~~~</p><hr><h3 id="Spring底层对BeanPostProcessor的使用"><a href="#Spring底层对BeanPostProcessor的使用" class="headerlink" title="Spring底层对BeanPostProcessor的使用"></a>Spring底层对BeanPostProcessor的使用</h3><p>ps：在idea中：类名查找类:Ctrl+Shift+Alt+N; </p><p><img src="/images/20181016104349.png"></p><p>1) 找到BeanPostProcessor接口：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public interface BeanPostProcessor &#123;<br><br><br>Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;<br><br><br>Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 在BeanPostProcessor上Ctrl+T：找到所有的实现类：</p><p><img src="/images/20181016105219.png"></p><p>我们能看到各种BeanPostProcessor的实现类</p><p>3）ApplicationContextAwareProcessor</p><p>我们使用一下ApplicationContextAwareProcessor这个处理器。这个处理器是给我们的自定义Bean注入容器的。</p><p>4）在com.liuzhuo.bean包下，随便找个一个Bean，并实现ApplicationContextAware接口：<br>ps:这里使用的Dog类<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Dog implements ApplicationContextAware<br></code></pre></td></tr></table></figure></p><p>5）需要实现：setApplicationContext方法<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;<br>    this.applicationContext = applicationContext;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这样我们就将容器注入到Dog类中。</p><hr><p>还有：<br>InitDestroyAnnotationBeanPostProcessor处理我们的@PostConstruct、@PreDestory注解。<br>AutowiredAnnotationBeanPostProcessor处理我们的@Autowired注解等。</p><p><strong>总结：<br>&nbsp;&nbsp;&nbsp;&nbsp;Spring对底层BeanPostProcessor的使用：bean的赋值、注入其他组件、@Autowired、生命周期注解功能、@Async、xxxBeanPostProcessor等等。</strong></p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_06</title>
      <link href="/2018/10/15/spring-annotation-day-06/"/>
      <url>/2018/10/15/spring-annotation-day-06/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天，学习Bean的生命周期<br><a id="more"></a></p><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p>在Spring中Bean的生命周期：<br>Bean的创建—-初始化—–调用—–销毁。</p><p>构造(对象的创建)：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单实例：在容器启动的时候创建对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多实例：在每次获取的时候创建对象 </p><p>初始化：<br>对象创建完成，并赋值好，调用初始化方法</p><p>销毁：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单实例：容器关闭的时候<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多实例：容器不会管理这个Bean，容器不会调用销毁方法</p><p>以前，我们定义初始化和销毁方法是在xml文件中配置的：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!--以前的开发模式，使用配置文件--&gt;<br>    &lt;bean id=&quot;person&quot; class=&quot;com.liuzhuo.bean.Person&quot; init-method=&quot;&quot; destroy-method=&quot;&quot;&gt;<br>        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;<br>        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;<br>    &lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>init-method=””    : 定义初始化方法<br>destroy-method=”” : 定义销毁方法  </p><hr><p>现在，我们可以使用其他方式来完成生命周期。</p><h4 id="通过-Bean指定init-method和destroy-method"><a href="#通过-Bean指定init-method和destroy-method" class="headerlink" title="通过@Bean指定init-method和destroy-method"></a>通过@Bean指定init-method和destroy-method</h4><p>1）在com.liuzhuo.config包下，创建MainConfigOfLife配置类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class MainConfigOfLife &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 在com.liuzhuo.bean包下，创建Car类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Car &#123;<br><br>    public Car() &#123;<br>        System.out.println(&quot;Car construct ····&quot;);<br>    &#125;<br><br>    //定义初始化方法<br>    public void init()&#123;<br>        System.out.println(&quot;Car init ·····&quot;);<br>    &#125;<br><br>    //定义销毁方法<br>    public void destory()&#123;<br>        System.out.println(&quot;Car destory ·····&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 将Car注册到容器中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class MainConfigOfLife &#123;<br><br>    @Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;destory&quot;)<br>    public Car car() &#123;<br>        return new Car();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 在com.liuzhuo.test包下，创建新的测试类(IocOfLifeTest):<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocOfLifeTest &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext =<br>                new AnnotationConfigApplicationContext(MainConfigOfLife.class);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5)运行测试test01方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Car construct ····<br>Car init ·····<br></code></pre></td></tr></table></figure></p><p>说明：单例模式下，容器启动就会将Bean对象注入到容器中，并执行了初始化方法。</p><p>想要调用销毁方法，关闭容器就好。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocOfLifeTest &#123;<br><br>    @Test<br>    public void test01() &#123;<br><br>        //启动容器<br>        AnnotationConfigApplicationContext applicationContext =<br>                new AnnotationConfigApplicationContext(MainConfigOfLife.class);<br>        //关闭容器<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">D:\Java1.8\bin\java<br>十月 15, 2018 9:08:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:08:11 CST 2018]; root of context hierarchy<br>Car construct ····<br>Car init ·····<br>十月 15, 2018 9:08:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:08:11 CST 2018]; root of context hierarchy<br>Car destory ·····<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><hr><h4 id="InitializingBean和DisposableBean"><a href="#InitializingBean和DisposableBean" class="headerlink" title="InitializingBean和DisposableBean"></a>InitializingBean和DisposableBean</h4><p>通过让Bean实现InitializingBean和DisposableBean两个接口来定义初始化和销毁。</p><p>1）在com.liuzhuo.bean包下，创建Cat类，并实现上述两个接口：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Cat implements InitializingBean, DisposableBean &#123;<br><br>    public Cat() &#123;<br>        System.out.println(&quot;Cat constructer ···&quot;);<br>    &#125;<br><br>    @Override<br>    public void destroy() throws Exception &#123;<br>        System.out.println(&quot;Cat destroy ····&quot;);<br>    &#125;<br><br>    @Override<br>    public void afterPropertiesSet() throws Exception &#123;<br>        System.out.println(&quot;Cat afterPropertiesSet ····&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 将Cat类注入到容器中，这里我使用了包扫描:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(value = &quot;com.liuzhuo&quot;)<br>public class MainConfigOfLife<br></code></pre></td></tr></table></figure></p><p>3) 运行测试方法test01:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocOfLifeTest &#123;<br><br>    @Test<br>    public void test01() &#123;<br><br>        //启动容器<br>        AnnotationConfigApplicationContext applicationContext =<br>                new AnnotationConfigApplicationContext(MainConfigOfLife.class);<br><br>        Object cat = applicationContext.getBean(&quot;cat&quot;);<br>        //关闭容器<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 15, 2018 9:21:42 下午 org.springframework.beans.factory.support.DefaultListableBeanFactory registerBeanDefinition<br>信息: Overriding bean definition for bean &apos;person&apos; with a different definition: replacing [Generic bean: class [com.liuzhuo.bean.Person]; scope=singleton; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [E:\ideaProject\springannotation\target\classes\com\liuzhuo\bean\Person.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=true; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=mainConfig2; factoryMethodName=person; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/liuzhuo/config/MainConfig2.class]]<br>Cat constructer ···<br>Cat afterPropertiesSet ····<br>Car construct ····<br>Car init ·····<br>十月 15, 2018 9:21:43 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:21:42 CST 2018]; root of context hierarchy<br>Car destory ·····<br>Cat destroy ····<br></code></pre></td></tr></table></figure></p><hr><h4 id="JSR250-PostConstruct和-PreDestory"><a href="#JSR250-PostConstruct和-PreDestory" class="headerlink" title="JSR250:@PostConstruct和@PreDestory"></a>JSR250:@PostConstruct和@PreDestory</h4><p>@PostConstruct: 在bean创建完成并且属性赋值完成，来执行初始化方法<br>@PreDestory：&nbsp;&nbsp;在容器销毁bean之前通知我们进行清理工作</p><p>1) 在com.liuzhuo.bean包下，创建Dog类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Dog &#123;<br><br>    public Dog() &#123;<br>        System.out.println(&quot;Dog construct ····&quot;);<br>    &#125;<br><br>    //在构造函数之后<br>    @PostConstruct<br>    public void init() &#123;<br>        System.out.println(&quot;Dog @PostConstruct ····&quot;);<br>    &#125;<br><br>    //在销毁之前<br>    @PreDestroy<br>    public void destory() &#123;<br>        System.out.println(&quot;Dog @PreDestroy ····&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 运行测试类test01:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocOfLifeTest &#123;<br><br>    @Test<br>    public void test01() &#123;<br><br>        //启动容器<br>        AnnotationConfigApplicationContext applicationContext =<br>                new AnnotationConfigApplicationContext(MainConfigOfLife.class);<br><br>        applicationContext.getBean(&quot;dog&quot;);<br>        <br>        //关闭容器<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 15, 2018 9:35:11 下午 org.springframework.beans.factory.support.DefaultListableBeanFactory registerBeanDefinition<br>信息: Overriding bean definition for bean &apos;person&apos; with a different definition: replacing [Generic bean: class [com.liuzhuo.bean.Person]; scope=singleton; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [E:\ideaProject\springannotation\target\classes\com\liuzhuo\bean\Person.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=true; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=mainConfig2; factoryMethodName=person; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/liuzhuo/config/MainConfig2.class]]<br>Cat constructer ···<br>Cat afterPropertiesSet ····<br>Dog construct ····<br>Dog @PostConstruct ····<br>Car construct ····<br>Car init ·····<br>十月 15, 2018 9:35:12 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:35:11 CST 2018]; root of context hierarchy<br>Car destory ·····<br>Dog @PreDestroy ····<br>Cat destroy ····<br></code></pre></td></tr></table></figure></p><hr><h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h4><p>BeanPostProcessor:bean后置处理器（意思是bean初始化前后执行）</p><p>postProcessBeforeInitialization：在初始化之前执行，这里是初始化指：上述的init-method、InitializingBean、@PostConstruct。</p><p>postProcessAfterInitialization：在初始化之后执行。</p><hr><p>1）在com.liuzhuo.bean包下，创建MyBeanPostProcessor并实现BeanPostProcessor接口<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class MyBeanPostProcessor implements BeanPostProcessor &#123;<br><br>    //初始化之前执行<br>    /**<br>     * @param bean     容器创建的Bean<br>     * @param beanName bean的id<br>     * @return<br>     * @throws BeansException<br>     */<br>    @Override<br>    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;<br><br>        System.out.println(beanName + &quot;------postProcessBeforeInitialization&quot;);<br>        //返回值是原始的Bean，或者是包装后的Bean<br>        return bean;<br>    &#125;<br><br>    //初始化之后执行<br>    @Override<br>    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;<br>        System.out.println(beanName + &quot;------postProcessAfterInitialization&quot;);<br>        return bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 运行测试方法test01：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocOfLifeTest &#123;<br><br>    @Test<br>    public void test01() &#123;<br><br>        //启动容器<br>        AnnotationConfigApplicationContext applicationContext =<br>                new AnnotationConfigApplicationContext(MainConfigOfLife.class);<br><br>        applicationContext.getBean(&quot;dog&quot;);<br><br>        //关闭容器<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfigOfLife------postProcessBeforeInitialization<br>mainConfigOfLife------postProcessAfterInitialization<br>Cat constructer ···<br>cat------postProcessBeforeInitialization<br>Cat afterPropertiesSet ····<br>cat------postProcessAfterInitialization<br>Dog construct ····<br>dog------postProcessBeforeInitialization<br>Dog @PostConstruct ····<br>dog------postProcessAfterInitialization<br>Car construct ····<br>car------postProcessBeforeInitialization<br>Car init ·····<br>car------postProcessAfterInitialization<br>Car destory ·····<br>Dog @PreDestroy ····<br>Cat destroy ····<br>十月 15, 2018 9:57:03 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:57:03 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>分析：<br>Cat constructer ···<br>cat——postProcessBeforeInitialization<br>Cat afterPropertiesSet ····<br>cat——postProcessAfterInitialization<br>Cat destroy ····  </p><p><strong>构造–初始化之前–初始化–初始化之后–销毁</strong></p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_05</title>
      <link href="/2018/10/15/spring-annotation-day-05/"/>
      <url>/2018/10/15/spring-annotation-day-05/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天，学习给容器中注入组件<br><a id="more"></a></p><h3 id="Import注解"><a href="#Import注解" class="headerlink" title="@Import注解"></a>@Import注解</h3><p>给容器中注册组件：<br>1）、包扫描+组件标记注解（@Controller、@Service、@Repository、@Component)[导入我们自己写的组件]<br>2）、@Bean[导入第三方包里面的组件]<br>3）、@Import[快速给容器中导入一个组件]  </p><hr><p>@Bean导入，只能一个一个的导入，不太方便，所以需要@Import注解。现在我们来看@Import的用法。</p><h4 id="一、-Import"><a href="#一、-Import" class="headerlink" title="一、@Import"></a>一、@Import</h4><p>@Import：容器中会自动注册这个组件，id默认是全类名  </p><p>1）在com.liuzhuo.bean包下，创建Color对象。<br>2）修改配置类MainConfig2类：(看@Import注解)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@Import(Color.class)<br>public class MainConfig2<br></code></pre></td></tr></table></figure></p><p>3）在test类中，创建新的测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void testImport() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>    printBeanName(applicationContext);<br>&#125;<br><br>private void printBeanName(AnnotationConfigApplicationContext applicationContext) &#123;<br>    String[] names = applicationContext.getBeanDefinitionNames();<br>    for (String name : names) &#123;<br>        System.out.println(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig2<br>com.liuzhuo.bean.Color<br>person<br>bier<br></code></pre></td></tr></table></figure></p><p>观察结果：发现Color组件已经注册到容器中了，而且id名是全类名。</p><hr><p>点击@Import。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Target(&#123;ElementType.TYPE&#125;)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>public @interface Import &#123;<br>    Class&lt;?&gt;[] value();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>发现，@Import中的value是一个Class类型的数组，说明可以注入多个Class类型  </p><p>1）现在，在com.liuzhuo.bean包下，再创建一个Red类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Red &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2）修改配置类MainConfig2：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@Import(&#123;Color.class, Red.class&#125;)<br>public class MainConfig2<br></code></pre></td></tr></table></figure></p><p>3) 运行测试方法testImport:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig2<br>com.liuzhuo.bean.Color<br>com.liuzhuo.bean.Red<br>person<br>bier<br></code></pre></td></tr></table></figure></p><p>结果：Red类也被注册到容器中了。</p><hr><h4 id="二、ImportSelect"><a href="#二、ImportSelect" class="headerlink" title="二、ImportSelect"></a>二、ImportSelect</h4><p>ImporSelect：返回要导入的全类名数组。</p><p>在@Import的value属性中，导入实现了ImportSelect接口的类，该实现类返回我们需要导入的组件的全类名即可。</p><p>1）在com.liuzhuo.condition包下，创建MyImportSelect类并实现ImportSelect接口：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyImportSelect implements ImportSelector &#123;<br><br>    /*<br>    * annotationMetadata:获取注解的信息。<br>    * 返回值：全类名的字符串数组<br>    * */<br>    @Override<br>    public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br><br>        //返回值不能是null，否则会出空指针异常<br>        return new String[0];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 在com.liuzhuo.bean包下，创建Bule、Yellow类。</p><p>3）修改selectImports方法是返回值：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyImportSelect implements ImportSelector &#123;<br><br>    /*<br>    * annotationMetadata:获取注解的信息。<br>    * 返回值：全类名的字符串数组<br>    * */<br>    @Override<br>    public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br><br>        //返回值不能是null，否则会出空指针异常<br>        return new String[]&#123;&quot;com.liuzhuo.bean.Blue&quot;,&quot;com.liuzhuo.bean.Yellow&quot;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 修改配置类MainConfig2:(添加类MyImportSelect类)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@Import(&#123;Color.class, Red.class, MyImportSelect.class&#125;)<br>public class MainConfig2<br></code></pre></td></tr></table></figure></p><p>5)运行测试方法testImport:</p><p>结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig2<br>com.liuzhuo.bean.Color<br>com.liuzhuo.bean.Red<br>com.liuzhuo.bean.Blue<br>com.liuzhuo.bean.Yellow<br>person<br>bier<br></code></pre></td></tr></table></figure></p><p>发现：Blue、Yellow也被注册到容器中了。</p><hr><h4 id="三、ImportBeanDefinitionRegistrar"><a href="#三、ImportBeanDefinitionRegistrar" class="headerlink" title="三、ImportBeanDefinitionRegistrar"></a>三、ImportBeanDefinitionRegistrar</h4><p>ImportBeanDefinitionRegistrar ：手动注册Bean。</p><p>使用的形式与ImportSelect类似。</p><p>1）在com.liuzhuo.condition包下，创建MyImportBeanDefinitionRegistrar类实现ImportBeanDefinitionRegistrar接口。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;<br>    /*<br>    *<br>    * importingClassMetadata:注解类的信息<br>    * registry：注册组件，使用register.registerBeanDefinition()方法，手动注册Bean。<br>    * */<br>    @Override<br>    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2)在com.liuzhuo.bean包下，创建RainBow类。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class RainBow &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 修改registerBeanDefinitions方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;<br><br>    /*<br>     * 这里，我们根据是否有Bule和Yellow组件来注册RainBow组件。<br>     * */<br><br>    //注意这里传入的是Bean的id。<br>    boolean b = registry.containsBeanDefinition(&quot;com.liuzhuo.bean.Blue&quot;);<br>    boolean y = registry.containsBeanDefinition(&quot;com.liuzhuo.bean.Yellow&quot;);<br>    if (b &amp;&amp; y) &#123;<br>        //两个参数：String beanName<br>        //         BeanDefinition beanDefinition<br>        // beanName：要注册的Bean的id<br>        //beanDefinition:Bean的定义。是一个接口，我们需要传入一个实现类。<br>        RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(RainBow.class);<br>        registry.registerBeanDefinition(&quot;rainBow&quot;, rootBeanDefinition);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 修改配置类MainConfig2：(MyImportBeanDefinitionRegistrar.class)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@Import(&#123;Color.class, Red.class, MyImportSelect.class, MyImportBeanDefinitionRegistrar.class&#125;)<br>public class MainConfig2<br></code></pre></td></tr></table></figure></p><p>5) 运行测试方法testImport:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig2<br>com.liuzhuo.bean.Color<br>com.liuzhuo.bean.Red<br>com.liuzhuo.bean.Blue<br>com.liuzhuo.bean.Yellow<br>person<br>bier<br>rainBow<br></code></pre></td></tr></table></figure></p><p>结果：发现rainBow已经被注册到容器中了。</p><hr><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>第四种方法给容器注册Bean.</p><p>使用Spring提供的FactoryBean（工厂Bean）<br> &nbsp;&nbsp;&nbsp;&nbsp;1）默认获取的是工厂bean调用getObject创建的对象<br> &nbsp;&nbsp;&nbsp;&nbsp;2）要想获取工厂Bean本身，需要给id前面加一个&amp;</p><hr><p>1) 在com.liuzhuo.bean包下，创建ColorFactoryBean类，实现FactoryBean接口：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class ColorFactoryBean implements FactoryBean&lt;Color&gt; &#123;<br><br>    //返回的Bean对象<br>    @Override<br>    public Color getObject() throws Exception &#123;<br>        return new Color();<br>    &#125;<br><br>    //Bean的类型<br>    @Override<br>    public Class&lt;?&gt; getObjectType() &#123;<br>        return Color.class;<br>    &#125;<br><br>    //是否是单例：<br>    //true:单例<br>    //false:多例<br>    @Override<br>    public boolean isSingleton() &#123;<br>        return true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 注册ColorFactoryBean到容器中，在配置文件MainConfig2中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean<br>public ColorFactoryBean colorFactoryBean() &#123;<br>    return new ColorFactoryBean();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 修改testImport方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void testImport() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>    printBeanName(applicationContext);<br><br><br>    Object colorFactoryBean = applicationContext.getBean(&quot;colorFactoryBean&quot;);<br>    System.out.println(colorFactoryBean);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig2<br>com.liuzhuo.bean.Color<br>com.liuzhuo.bean.Red<br>com.liuzhuo.bean.Blue<br>com.liuzhuo.bean.Yellow<br>person<br>bier<br>colorFactoryBean<br>rainBow<br>com.liuzhuo.bean.Color@6107227e<br></code></pre></td></tr></table></figure></p><p>发现：com.liuzhuo.bean.Color@6107227e 已经注册到容器中了。<br><strong>注意：我们注册到容器中的是ColorFactoryBean，但是获取Bean的时候，却是Color。</strong></p><p>底层是调用ColorFactoryBean的getObject()来获取的。</p><p>如果就是想要获取ColorFactoryBean本身的话，在id前面加一个&amp;：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Object colorFactoryBean = applicationContext.getBean(&quot;colorFactoryBean&quot;);<br>System.out.println(colorFactoryBean);<br>Object colorFactoryBean2 = applicationContext.getBean(&quot;&amp;colorFactoryBean&quot;);<br>System.out.println(colorFactoryBean2);<br></code></pre></td></tr></table></figure></p><p>结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">com.liuzhuo.bean.Color@6107227e<br>com.liuzhuo.bean.ColorFactoryBean@7c417213<br></code></pre></td></tr></table></figure></p><p>ps:点击BeanFactory：<br>会发现有一个字段：<br><code>String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</code><br>这就是为啥加&amp;会获取FactoryBean本身的原因.</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_04</title>
      <link href="/2018/10/14/spring-annotation-day-04/"/>
      <url>/2018/10/14/spring-annotation-day-04/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天，学习条件注解！！！<br><a id="more"></a></p><h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h3><p>作用：按照一定的条件进行判断，满足条件给容器中注入bean  </p><p>现在我们的需求的是根据操作系统的类型来，注入给定的bean对象。</p><p>在配置类中，添加两个方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean(&quot;bier&quot;)<br>public Person person01() &#123; //如果是windows系统就注入到容器中<br>    return new Person(&quot;Bier&quot;, 16);<br>&#125;<br><br>@Bean(&quot;linux&quot;)<br>public Person person02() &#123; //如果是Linux系统就注入到容器中<br>    return new Person(&quot;Linux&quot;, 18);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>在测试类中，创建新的test03方法:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test03() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>    //根据Bean类来获取所有的Bean类的id名字<br>    String[] beanNamesForType = applicationContext.getBeanNamesForType(Person.class);<br>    for (String name : beanNamesForType) &#123;<br>        System.out.println(name);<br>    &#125;<br>    //根据Bean类来获取Map结构<br>    Map&lt;String, Person&gt; beansOfType = applicationContext.getBeansOfType(Person.class);<br>    System.out.println(beansOfType);<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">D:\Java1.8\bin\java  <br>person<br>bier<br>linux<br>加载person类到容器中~~~<br>&#123;person=Person&#123;name=&apos;dengjie&apos;, age=18&#125;, bier=Person&#123;name=&apos;Bier&apos;, age=16&#125;, linux=Person&#123;name=&apos;Linux&apos;, age=18&#125;&#125;<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>此时：获取了所有的person类的Bean的id的名字。</p><hr><p>现在，我们创建com.liuzhuo.conditaion包，并创建两个实现了condition接口的类。如下：</p><p><img src="/images/20181014203017.png" style="width:50%">  </p><p>WinCondition类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class WinCondition implements Condition &#123;<br>    /*<br>     * conditionContext：     条件上下文（获取我们需要的资源）<br>     * annotatedTypeMetadata：注解类型的信息<br>     * */<br>    @Override<br>    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123;<br><br>        //获取beanFactory工厂<br>        ConfigurableListableBeanFactory beanFactory = conditionContext.getBeanFactory();<br>        //获取加载类<br>        ClassLoader classLoader = conditionContext.getClassLoader();<br>        //获取注解类<br>        BeanDefinitionRegistry registry = conditionContext.getRegistry();<br>        //获取环境变量<br>        Environment environment = conditionContext.getEnvironment();<br>        //获取资源加载类<br>        ResourceLoader resourceLoader = conditionContext.getResourceLoader();<br><br>        /*<br>        * 创建如果是windows系统的话，就注入到容器中<br>        * */<br>        String property = environment.getProperty(&quot;os.name&quot;);<br>        if (property.contains(&quot;Windows&quot;)) return true;<br>        return false;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>LinuxCondition类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class LinuxCondition implements Condition &#123;<br>    @Override<br>    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123;<br><br>        Environment environment = conditionContext.getEnvironment();<br>        String property = environment.getProperty(&quot;os.name&quot;);<br>        if (property.contains(&quot;Linux&quot;)) return true;<br>        return false;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>修改配置类：给刚刚创建的两个方法添加@Conditional注解</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Conditional(&#123;WinCondition.class&#125;)<br>@Bean(&quot;bier&quot;)<br>public Person person01() &#123; //如果是windows系统就注入到容器中<br>    return new Person(&quot;Bier&quot;, 16);<br>&#125;<br><br>@Conditional(&#123;LinuxCondition.class&#125;)<br>@Bean(&quot;linux&quot;)<br>public Person person02() &#123; //如果是Linux系统就注入到容器中<br>    return new Person(&quot;Linux&quot;, 18);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">person<br>bier<br>加载person类到容器中~~~<br>&#123;person=Person&#123;name=&apos;dengjie&apos;, age=18&#125;, bier=Person&#123;name=&apos;Bier&apos;, age=16&#125;&#125;<br>Windows 10<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>看到结果：现在作者的操作系统是windows系统，所以现在是bier给注入到容器中了。</p><p>现在修改操作系统的类型。</p><p>修改test03的运行环境，在idea的右上角点击”Edit Configrations···”:</p><p><img src="/images/20181014204146.png" style="width:50%"></p><p>编辑里面的 VM options: -Dos.name=Linux </p><p>然后运行test03.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">person<br>linux<br>加载person类到容器中~~~<br>&#123;person=Person&#123;name=&apos;dengjie&apos;, age=18&#125;, linux=Person&#123;name=&apos;Linux&apos;, age=18&#125;&#125;<br>Linux<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>此时，注入到容器中的是linux。</p><hr><p>总结：@Conditional注解是用来按照一定的条件进行判断，满足条件给容器中注入bean。<br>点击@Conditional：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>public @interface Conditional &#123;<br>    Class&lt;? extends Condition&gt;[] value();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>说明@Conditional里面是Condition&gt;[] value()数组。我们需要在@Conditional的value中写入数组。数组需要使用｛｝来写。传入的是实现了Condition接口的类。比如这里的WinCondition、LinuxCondition类。<br>实例：@Conditional({WinCondition.class})、@Conditional({LinuxCondition.class})。</p><p>@Conditional，不仅可以放在方法上面，还可以是类上面。<br>放在类上面，就是对这个类统一设置。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_03</title>
      <link href="/2018/10/14/spring-annotation-day-03/"/>
      <url>/2018/10/14/spring-annotation-day-03/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天，学习Spring中的@Scope注解<br><a id="more"></a></p><h3 id="Scope注解"><a href="#Scope注解" class="headerlink" title="@Scope注解"></a>@Scope注解</h3><p>@Scope注解：是用来控制创建对象的作用域的，这里的作用域是我们平时所说的作用域。<br>这里是：单例模式、多例模式等。  </p><p>现在创建新的配置类com.liuzhuo.config.MainConfig2:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig2 &#123;<br><br>    @Bean(&quot;person&quot;)<br>    public Person person() &#123;<br>        return new Person(&quot;dengjie&quot;, 18);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在测试类IocTest中创建新的测试方法，test02：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test02() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>    //获取所有已经注入到容器中的Bean的id.<br>    String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();<br>    for (String name : beanDefinitionNames) &#123;<br>        System.out.println(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig2<br>person<br></code></pre></td></tr></table></figure><hr><p>现在我们修改配置类MainConfig2：<br>使用@Scope注解（作用域的功能）</p><p>@Scope可以使用四个值：<br>1.singleton：单例模式（<strong>默认值</strong>）<br>2.prototype：多例模式<br>3.request  ：一个request请求，创建一个新的实例<br>4.session  ：一个session请求，创建一个新的实例 </p><p>在配置类下的person方法上加入@Scope注解：   </p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig2 &#123;<br><br>    @Scope<br>    @Bean(&quot;person&quot;)<br>    public Person person() &#123;<br>        return new Person(&quot;dengjie&quot;, 18);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>现在修改test02测试方法，测试person是否是单例：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test02() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>    //获取所有已经注入到容器中的Bean的id.<br>    /*String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();<br>    for (String name : beanDefinitionNames) &#123;<br>        System.out.println(name);<br>    &#125;*/<br><br>    Object person = applicationContext.getBean(&quot;person&quot;);<br>    Object person2 = applicationContext.getBean(&quot;person&quot;);<br>    System.out.println(person == person2);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：true。注意：<strong>此时已经加载的是配置文件2了！！！</strong><br>说明@Scope默认是单例模式。</p><hr><p>现在修改成多例模式：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig2 &#123;<br><br>    @Scope(value = &quot;prototype&quot;)<br>    @Bean(&quot;person&quot;)<br>    public Person person() &#123;<br>        return new Person(&quot;dengjie&quot;, 18);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行测试方法test02：输出false。<br>说明：现在是多例模式。</p><hr><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>修改配置类，在person方法中加入一句输出语句。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig2 &#123;<br><br>    @Scope(value = &quot;singleton&quot;)<br>    @Bean(&quot;person&quot;)<br>    public Person person() &#123;<br>        System.out.println(&quot;加载person类到容器中~~~&quot;);<br>        return new Person(&quot;dengjie&quot;, 18);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>修改测试类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test02() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行测试方法：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">D:\Java1.8\bin\java -ea -Didea.test.cyclic.buffer.size=1048576 <br>加载person类到容器中~~~<br>true<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure><p>此时虽然只加载了容器类，但是person还是被加载到了容器中。<br>说明单例模式下，注入到容器中的类是立即注入的。不用到使用person类才注入到容器中来。</p><hr><p>现在讲单例变成多例模式，不改测试方法。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig2 &#123;<br><br>    @Scope(value = &quot;prototype&quot;)<br>    @Bean(&quot;person&quot;)<br>    public Person person() &#123;<br>        System.out.println(&quot;加载person类到容器中~~~&quot;);<br>        return new Person(&quot;dengjie&quot;, 18);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>此时啥也不输出！！!</strong></p><p>现在修改测试方法：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test02() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>  <br>    Object person = applicationContext.getBean(&quot;person&quot;);<br>    Object person2 = applicationContext.getBean(&quot;person&quot;);<br>    System.out.println(person == person2);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">加载person类到容器中~~~<br>加载person类到容器中~~~<br>false<br></code></pre></td></tr></table></figure></p><p>说明：多例是懒加载，只有等到获取person对象时，才会将person注入到容器中。</p><hr><h3 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h3><p>使用@Lazy注解来控制是否是懒加载。</p><p>修改配置类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig2 &#123;<br><br>    @Scope<br>    @Lazy<br>    @Bean(&quot;person&quot;)<br>    public Person person() &#123;<br>        System.out.println(&quot;加载person类到容器中~~~&quot;);<br>        return new Person(&quot;dengjie&quot;, 18);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>修改测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test02() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行测试方法：啥也不输出，说明此时已经是懒加载了。</p><hr><p>修改测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test02() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br><br>    Object person = applicationContext.getBean(&quot;person&quot;);<br>    Object person2 = applicationContext.getBean(&quot;person&quot;);<br>    System.out.println(person == person2);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">加载person类到容器中~~~<br>true<br></code></pre></td></tr></table></figure></p><p>此时是到使用person对象时，才会加载。并且只是加载了一次，因为是单例模式。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_02</title>
      <link href="/2018/10/13/spring-annotation-day-02/"/>
      <url>/2018/10/13/spring-annotation-day-02/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天，学习包的扫描<br><a id="more"></a></p><p>接着day01天的内容，我们知道怎么使用java配置来初始化容器，使用@Configuration注解来标记一个java类就等同于了bean.xml文件了。</p><p>接下来，我们看看包扫描怎么配置，因为我们不可能给每个类都配置，那样太花时间和精力，所以我们需要包扫描的配置，来自动帮我们把需要的bean对象注入到容器中。</p><h3 id="一：xml版的包扫描"><a href="#一：xml版的包扫描" class="headerlink" title="一：xml版的包扫描"></a>一：xml版的包扫描</h3><hr><p>注意：这里在Bean.xml文件中需要配置命名空间,加上context的命名空间.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>       xsi:schemaLocation=&quot;<br>         http://www.springframework.org/schema/beans<br>         http://www.springframework.org/schema/beans/spring-beans.xsd<br>         http://www.springframework.org/schema/context<br>         http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;<br></code></pre></td></tr></table></figure></p><p>主要加入了xmlns:context=····和xsi:中的两个context(看结尾).</p><p>bean.xml配置文件加入了：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!--包扫描、只要标注了@Controller、@Service、@Repository、@Component都会自动注入到容器中--&gt;<br>&lt;!-- base-package包名，在该包下的子包也会被扫描--&gt;<br>&lt;context:component-scan base-package=&quot;com.liuzhuo&quot;/&gt;<br></code></pre></td></tr></table></figure></p><p>现在将bean.xml中的person配置注解掉。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!--以前的开发模式，使用配置文件--&gt;<br>&lt;!--&lt;bean id=&quot;person&quot; class=&quot;com.liuzhuo.bean.Person&quot;&gt;<br>    &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;<br>    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;<br>&lt;/bean&gt;--&gt;<br></code></pre></td></tr></table></figure></p><p>在Person类上面加入@Component注解。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Person<br></code></pre></td></tr></table></figure></p><p>运行MainTest测试类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);<br>Person person = (Person) applicationContext.getBean(&quot;person&quot;);<br>System.out.println(person);<br></code></pre></td></tr></table></figure></p><p>输出:</p><p><code>Person{name=&#39;null&#39;, age=null}</code>  </p><p>说明包扫描成功!</p><hr><h3 id="二：java类版的包扫描"><a href="#二：java类版的包扫描" class="headerlink" title="二：java类版的包扫描"></a>二：java类版的包扫描</h3><hr><p>首先将xml版本中的包扫描注解掉。</p><p>在java配置类上加入@ComponentScan(value = “com.liuzhuo”)<br>value：就是扫描的具体包的路径。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@ComponentScan(value = &quot;com.liuzhuo&quot;) //包扫描<br>public class MainConfig &#123;<br>   ·····<br>&#125;<br></code></pre></td></tr></table></figure><p>创建com.liuzhuo.controller、com.liuzhuo.service包、com.liuzhuo.dao<br>并创建相应的java类，BookController，BookService，BookDao。如下：</p><p><img src="/images/20181013170247.png" style="width:50%;">  </p><p>并在相应的类上面标注相应的注解。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Controller<br>public class BookController &#123;<br>&#125;<br>-----------------------------<br>@Service<br>public class BookService &#123;<br>&#125;<br>-----------------------------<br>@Repository<br>public class BookDao &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要是@Controller、@Service、@Repository三个注解。  </p><p>现在在test文件夹下面的jave包下创建测试类。</p><p>com.liuzhuo.test.IocTest类。</p><p>并在pom.xml文件中加入依赖<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependency&gt;<br>    &lt;groupId&gt;junit&lt;/groupId&gt;<br>    &lt;artifactId&gt;junit&lt;/artifactId&gt;<br>    &lt;version&gt;4.12&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>在IocTest类中写入一下代码:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocTest &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);<br>        //获取所有已经注入到容器中的Bean的id.<br>        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();<br>        for (String name : beanDefinitionNames) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>执行test01，结果：<br>除了spring内置的Bean对象外，主要有以下我们自己定义的Bean对象的id名<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>bookController<br>bookDao<br>bookService<br>person01<br></code></pre></td></tr></table></figure></p><hr><h3 id="三、-ComponentScan的用法"><a href="#三、-ComponentScan的用法" class="headerlink" title="三、@ComponentScan的用法"></a>三、@ComponentScan的用法</h3><p>上面，我们已经初步了解了@ComponentScan包扫描的基本用法了。<br>点击@ComponentScan注解。我们会看到<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Retention(RetentionPolicy.RUNTIME)<br>@Target(&#123;ElementType.TYPE&#125;)<br>@Documented<br>@Repeatable(ComponentScans.class)<br>public @interface ComponentScan &#123;<br>    @AliasFor(&quot;basePackages&quot;)<br>    String[] value() default &#123;&#125;;<br>    ····<br>&#125;<br></code></pre></td></tr></table></figure></p><p>value这个字段，说明是一个字符串类型的数组。说明value值，我们可以填写多个值，数组的话，用大花括号来表示，{}.每个值用逗号，来隔开。</p><p>ps:提一个小技巧，在idea中，Alt+7可以查看这个类中所有的字段和方法。</p><p>我们可以看到其中有一个includeFilters()的字段。<br><img src="/images/20181013173018.png" style="width:50%"></p><p>ComponentScan.Filter[] includeFilters() default {};</p><p>看到includeFilters也是一个数组，类型是ComponentScan的内部类Filter。<br>点击Filter，发现也是一个注解.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Retention(RetentionPolicy.RUNTIME)<br>    @Target(&#123;&#125;)<br>    public @interface Filter &#123;<br>        FilterType type() default FilterType.ANNOTATION;<br><br>        @AliasFor(&quot;classes&quot;)<br>        Class&lt;?&gt;[] value() default &#123;&#125;;<br><br>        @AliasFor(&quot;value&quot;)<br>        Class&lt;?&gt;[] classes() default &#123;&#125;;<br><br>        String[] pattern() default &#123;&#125;;<br>    &#125;<br></code></pre></td></tr></table></figure></p><p>发现有一个类型和字节码类的字段。</p><p><strong>1.includeFilters</strong></p><p>现在我们来使用这个includeFilters来在包扫描的时候，只扫描我们相要的类。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = &#123;<br>        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)<br>&#125;) //包扫描<br></code></pre></td></tr></table></figure></p><p>type是来说明过滤的类型的，这里的类型是注解(FilterType.ANNOTATION)。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public enum FilterType &#123;<br>    ANNOTATION,<br>    ASSIGNABLE_TYPE,<br>    ASPECTJ,<br>    REGEX,<br>    CUSTOM;<br><br>    private FilterType() &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总共有以上五个类型。<br>ANNOTATION：注解类型<br>ASSIGNABLE_TYPE：赋值类型</p><hr><p>运行test01类，发现结果还是<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>bookController<br>bookDao<br>bookService<br>person01<br></code></pre></td></tr></table></figure></p><p>是配置出现问题了嘛？不是，是因为我们忘记了，包扫描，默认是配置是扫描所有，所以，我们只需要将默认的配置设置为false就好了。<br>useDefaultFilters = false</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = &#123;<br>        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)<br>&#125;,useDefaultFilters = false) //包扫描<br>public class MainConfig<br></code></pre></td></tr></table></figure><p>结果为：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>bookController<br>person01<br></code></pre></td></tr></table></figure></p><p><strong>2.excludeFilters</strong></p><p>excludeFilters：是和includeFilters对着来的，是排除哪些类不扫描。</p><p>具体的配置情况如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@ComponentScan(value = &quot;com.liuzhuo&quot;, excludeFilters = &#123;<br>        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)<br>&#125;) //包扫描<br>public class MainConfig<br></code></pre></td></tr></table></figure></p><p>输出结果为：将@Controller注解的类就没有扫描。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>bookDao<br>bookService<br>person01<br></code></pre></td></tr></table></figure></p><p>总结：<br>@ComponentScan value:指定要扫描的包<br>jdk1.8中@ComponentScan是可重复的，所以可以写两个@ComponentScan<br>不过，可以使用@ComponentScans来配置多个@ComponentScan<br>excludeFilters = Filter[]: 指定扫描的时候按照什么规则排除哪些组件<br>includeFilters = Filter[]: 指定扫描的时候只需要包含哪些组件<br>ps:includeFilters,需要将默认的配置设置为false。(useDefaultFilters = false)</p><hr><h3 id="四、详解Filter的类型"><a href="#四、详解Filter的类型" class="headerlink" title="四、详解Filter的类型"></a>四、详解Filter的类型</h3><p>FilterType.ANNOTATION        按照注解<br>FilterType.ASSIGNABLE_TYPE   按照给定的类型<br>FilterType.ASPECTJ           使用ASPECTJ表达式<br>FilterType.REGEX             使用正则表达式<br>FilterType.CUSTOM            使用自定义的规则</p><p>更新MainConfig类:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@ComponentScans(value = &#123;<br>        @ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = &#123;<br>                @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)<br>        &#125;, useDefaultFilters = false)<br>&#125;)<br>public class MainConfig<br></code></pre></td></tr></table></figure><p>现在的输出结果为：(包含有@Controller注解的类)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>bookController<br>person01<br></code></pre></td></tr></table></figure></p><p>现在我们使用FilterType.ASSIGNABLE_TYPE 类型(给定类的类型)</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@ComponentScans(value = &#123;<br>        @ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = &#123;<br>                @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = &#123;BookService.class&#125;)<br>        &#125;, useDefaultFilters = false)<br>&#125;)<br>public class MainConfig<br></code></pre></td></tr></table></figure><p>输出结果是只要BookService类型的就行，他的子类也行。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>bookService<br>person01<br></code></pre></td></tr></table></figure></p><p>现在我们使用自定义规则，FilterType.CUSTOM。</p><p>需要自己创建一个类并实现TypeFilter接口。(我放在com.liuzhuo.config包)</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyTypeFilter implements TypeFilter &#123;<br>    @Override<br>    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123;<br>        return false;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释一下：<br>1.metadataReader  读取到当前正在扫描的类的信息<br>2.metadataReaderFactory  可以获取到其他任何类信息</p><p>我们通过这两个参数可以获取很多当前扫描类的信息。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyTypeFilter implements TypeFilter &#123;<br>    @Override<br>    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123;<br><br>        //获取当前类的注解信息<br>        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();<br>        //获取当前正在扫描的类信息<br>        ClassMetadata classMetadata = metadataReader.getClassMetadata();<br>        //获取当前类的资源(类的路径)<br>        Resource resource = metadataReader.getResource();<br><br>        String className = classMetadata.getClassName();<br>        System.out.println(&quot;---&gt;&quot; + className);<br><br>        return false;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述的方法，我们可以打印出被扫描的类的名字；<br>在此之前，我们还需要修改MainConfig配置类：<br>将Filter类型改为自定义类型。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@ComponentScans(value = &#123;<br>        @ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = &#123;<br>                @ComponentScan.Filter(type = FilterType.CUSTOM, classes = &#123;MyTypeFilter.class&#125;)<br>        &#125;, useDefaultFilters = false)<br>&#125;)<br>public class MainConfig<br></code></pre></td></tr></table></figure></p><p>运行test01测试类：<br>结果如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">---&gt;com.liuzhuo.test.IocTest<br>---&gt;com.liuzhuo.bean.Person<br>---&gt;com.liuzhuo.config.MyTypeFilter<br>---&gt;com.liuzhuo.controller.BookController<br>---&gt;com.liuzhuo.dao.BookDao<br>---&gt;com.liuzhuo.MainTest<br>---&gt;com.liuzhuo.service.BookService<br></code></pre></td></tr></table></figure></p><p>现在我们的MyTypeFilter返回都是false，所以被注入到容器的是<br>mainConfig<br>person01</p><p>现在，我们来更改MyTypeFilter类，我们只注入类名包含‘er’的类。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyTypeFilter implements TypeFilter &#123;<br>    @Override<br>    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123;<br><br>        //获取当前类的注解信息<br>        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();<br>        //获取当前正在扫描的类信息<br>        ClassMetadata classMetadata = metadataReader.getClassMetadata();<br>        //获取当前类的资源(类的路径)<br>        Resource resource = metadataReader.getResource();<br><br>        String className = classMetadata.getClassName();<br>        System.out.println(&quot;---&gt;&quot; + className);<br><br>        if (className.contains(&quot;er&quot;)) return true;<br>        return false;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>其实就是加了一句代码：<br><code>if (className.contains(&quot;er&quot;)) return true;</code></p><p>运动test01测试类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>person<br>myTypeFilter<br>bookController<br>bookService<br>person01<br></code></pre></td></tr></table></figure></p><p>除了本来的mainConfig、person01是配置文件帮我注入的。<br>其他的注入的类都是类名包含‘er’的。</p><p><strong>ps：都是在包扫描@ComponentScan(value = “com.liuzhuo”)</strong><br><strong>com.liuzhuo包下的’er’.</strong></p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_01</title>
      <link href="/2018/10/12/spring-annotation-01/"/>
      <url>/2018/10/12/spring-annotation-01/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天学习Spring的第一天，大家一起跟着我动手搭建环境，最后一定会有收获。<br><a id="more"></a></p><p>开发流程：主要是使用idea来完成的，此教程是针对有spring开发经验的人看的。用来对比以前的配置文件来注入依赖和java类配置来注入依赖的区别。  </p><p>打开idea创建Maven工程，输入三个坐标，groupId，artifactId，version。<br>我们这里的三个坐标是:  </p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;groupId&gt;com.liuzhuo&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-annotation&lt;/artifactId&gt;<br>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;<br></code></pre></td></tr></table></figure><p>创建后的工程如下：<br><img src="/images/20181012212912.png" style="width:300px; heigh:300px"></p><hr><p>现在打开pom.xml文件:添加依赖如下<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;<br>            &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;<br>        &lt;/dependency&gt;<br>&lt;/dependencies&gt;<br></code></pre></td></tr></table></figure></p><p>更新pom文件，会自动导入jar包。 </p><hr><p>在src下的main下的java中创建Person类。我的包名是com.liuzhuo.bean<br>Person类中主要是两个字段，一个name，一个age，如图:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Person &#123;<br>    private String name;<br>    private Integer age;<br><br>    ···中间省略了无参、有参的构造函数和getter、setter方法以及toString方法.    <br>&#125;<br></code></pre></td></tr></table></figure></p><p>现在在main下的resources下创建bean.xml文件  </p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;<br><br>    &lt;!--以前的开发模式，使用配置文件--&gt;<br>    &lt;bean id=&quot;person&quot; class=&quot;com.liuzhuo.bean.Person&quot;&gt;<br>        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;<br>        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;<br>    &lt;/bean&gt;<br><br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><hr><p>现在在com.liuzhuo包下创建MainTest类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MainTest &#123;<br><br>    public static void main(String[] args) &#123;<br><br>        //以前的开发模式，使用xml来配置bean<br>        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);<br>        Person person = (Person) applicationContext.getBean(&quot;person&quot;);<br>        System.out.println(person);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><p>输出结果:就是在配置文件中的配置的person类。</p><p><code>Person{name=&#39;zhangsan&#39;, age=18}</code></p><hr><p>现在创建com.liuzhuo.config包，并创建MainConfig类:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig &#123;<br><br>    //给容器中注册一个Bean；类型为返回值的类型，id默认为方法名<br>    @Bean<br>    public Person person() &#123;<br>        return new Person(&quot;lisi&quot;, 16);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><p>修改MainTest类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MainTest &#123;<br><br>    public static void main(String[] args) &#123;<br><br>        //以前的开发模式，使用xml来配置bean<br>        /*ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);<br>        Person person = (Person) applicationContext.getBean(&quot;person&quot;);<br>        System.out.println(person);*/<br><br>        //现在使用java类来配置上下文容器<br>        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig.class);<br>        Person person = context.getBean(Person.class);<br>        System.out.println(person);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><p>输出结果：是MainConfig类中配置Person类(@Bean注解的类) </p><p><code>Person{name=&#39;lisi&#39;, age=16}</code></p><p>在配置文件类必须使用@Configuration注解，然后再注入自己想要的Bean对象<br>创建一个方法，使用@Bean注解，返回值就是注入到容器中的Bean类型，默认情况下方法名就是注入到容器中的id。  </p><p>@Bean注解()中，可以输入参数，其中就有value来修改Bean的id名，如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MainConfig &#123;<br><br>    //给容器中注册一个Bean；类型为返回值的类型，id默认为方法名<br>    @Bean(value = &quot;person01&quot;) //修改了Bean的id为person01<br>    public Person person() &#123;<br>        return new Person(&quot;lisi&quot;, 16);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>在MainTest文件中输入获取Person类的名字：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//现在使用java类来配置上下文容器<br>AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig.class);<br>Person person = context.getBean(Person.class);<br>System.out.println(person);<br><br>String[] beanNames = context.getBeanNamesForType(Person.class);<br>for(String name:beanNames)&#123;<br>   System.out.println(name);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果： </p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Person&#123;name=&apos;lisi&apos;, age=16&#125;<br>person01<br></code></pre></td></tr></table></figure><p>说明此时，Bean的id名字是被@Bean(value=”person01”)给替换了，不再是方法名person了。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown</title>
      <link href="/2018/10/12/markdown/"/>
      <url>/2018/10/12/markdown/</url>
      
        <content type="html"><![CDATA[<p> <strong>序言</strong>:<br></p><p></p><p>很久没有写日记了，以前只是在QQ空间写，现在觉得在自己的平台写日记还是感觉不错的，还是要多写博客来加强自己学习的知识，学的知识点感觉还是记不住，渐渐地让我明白，看的越多，懂的越少（你这话不是有毛病吗？应该是看的越多，懂的越多才对），此话怎讲，当你在茫茫的知识库里面东看西看的时候，很快就被海量的知识给淹没了，根本就不知道哪些是对的，哪些是错的，感觉好像这个也懂了，那个也懂了，但是真正写起来，脑子又一片空白，又好像什么都不懂，这种状态时有发生，这就叫不懂装懂，最根本的原因就是看的太多，写的太少，所以为了改掉这样毛病，把被动学习变成主动学习，接下来的日子，多写写，即使是写一些学习工作中遇到的坑也是好的，没事翻出来看看，还可以加深印象，好了，废话到处！<br></p><br>正文：<br><br><strong>一、标题的几种写法</strong>：<p></p><p><strong>第一种</strong>：<br></p><p>#一级标题<br></p><p>##二级标题<br></p><p>###三级级标题<br></p><p>####四级标题<br></p><p>#####五级标题<br></p><p>######六级标题<br><br><strong>说明：真正使用的时候，需要在#后加空格!!!!!</strong><br><br>效果:<br>   </p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级级标题"><a href="#三级级标题" class="headerlink" title="三级级标题"></a>三级级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p><strong>第二种</strong>：<br><br>  这是一级标题<br><br>  ======<br><br>  这是二级标题<br><br>  ———<br><br>这种只能表示一级和二级标题,==和–的数量个数没有限制，多少都行!!!<br>效果：<br></p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><p><strong>第三种</strong>：<br></p><p>#一级标题#<br></p><p>##二级标题##<br><br>其他几级标题类似，就是一个封闭的意思，也是注意#后面需要有空格!!!</p><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><p>那既然3种都可以使用，可不可以混合使用呢？我试了一下，是可以的，但是为了让页面标签的统一性，不建议混合使用，推荐使用第一种，比较简洁，全面</p><p>为了搞清楚原理，我特意在网上搜一下在线编写markdown的工具，发现实际上是把这些标签最后转化为html标签，如图：<br><br><img src="https://i.imgur.com/QSo6UUP.png" alt=""><br>在线地址请看这里:<a href="http://tool.oschina.net/markdown/" title="markdown在线编辑器" target="_blank" rel="noopener">markdown在线编辑器</a><br></p><hr><p><strong>二：列表</strong><br><br>1.无序列表：<br><br>*1<br><br>*2<br><br>*3<br><br>+1<br><br>+2<br><br>+3<br><br>-1<br><br>-2<br><br>-3<br><br>效果:<br></p><ul><li>1</li><li>2</li><li>3</li></ul><ul><li>1</li><li>2</li><li>3</li></ul><ul><li>1</li><li>2</li><li>3<br></li></ul><p>可以看到，无序列表可以用 * ， + ， - 来创建，用在线编辑器看，实际上是转换成了ul&gt;li ，所以使用哪个都可以，推荐使用*吧.<br><br><br>2.有序列表:<br><br>1.列表1<br>2.列表2<br>3.列表3</p><ol><li>列表1</li><li>列表2</li><li>列表3</li></ol><p>有序列表就相对简单一点，只有这一种方式，注意，数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的。</p><hr><p><strong>三：区块引用</strong><br>比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语句。使用&gt;  </p><ul><li>犯我帝国者，虽远必诛!  <blockquote><p>这是嘉文四世说的</p></blockquote></li></ul><p><strong>四：华丽的分割线</strong><br>分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以</p><hr><p><strong>五:图片</strong><br>图片也有2种方式：行内式和参数式.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">![我是图片](https://www.fdfdfdf.jpg)<br>[我是图片]: (https://www.fdfdfdf.jpg)<br>参数式图片，这里是[我是图片]<br></code></pre></td></tr></table></figure></p><p>用法跟链接的基本一样，唯一的不同就是，图片前面要写一个！（这是必须的），没什么好说的。</p><hr><p><strong>六：代码块</strong></p><p>这个就比较重要了，很多时候都需要展示出一些代码</p><p>如果代码量比较少，只有单行的话，可以用单反引号包起来，如下： </p><p>第一种：单行（两个）: ``</p><p><code>var js = new object();</code>  </p><p>要是多行这个就不行了，多行可以用3个 `</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">int a = 10;  <br>int b = 20;  <br>int sum = a + b;  <br>printf(&quot;%d&quot;,sum);<br></code></pre></td></tr></table></figure><hr><p><strong>七：强调</strong>  </p><p>*字体倾斜*<br>_字体倾斜_<br>**字体加粗**<br>__字体加粗__  </p><p>一个星号或者是一个下划线包起来，会转换为<code>&lt;em&gt;</code>倾斜，如果是2个，会转换为<code>&lt;strong&gt;</code>加粗</p><hr><p><strong>八：转义</strong>  </p><p> \：转义符号，和js一样。</p><hr><p><strong>九：删除线</strong>  </p><p>~~请删除我~~:</p><p><del>请删除我</del>  </p><hr><p><strong>十：html原始码</strong> </p><p>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理.</p><hr><p>常用的基本上就这些了，如果还有一些常用的，可以跟我留言，我补充上去. </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>新文章</title>
      <link href="/2018/10/11/my-new-post/"/>
      <url>/2018/10/11/my-new-post/</url>
      
        <content type="html"><![CDATA[<p>这是作者的第一篇文章，主要是为了纪念自己的博客!!</p><a id="more"></a><hr><p>欢迎大家在此篇文章下面评论，我会尽量回复大家的问题。</p><p>不管是生活上面的，还是学习上面的疑惑都可以提</p><p>一段故事温柔人心，爱分享爱解忧，么么哒~~</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>  <img src="/images/gakki.png"></p><p>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;本人只是一个即将毕业的程序猿小哥哥，由于秋招结束，闲暇时间搭建了这个平台，只为给自己的生活增添一点乐趣。</p><p></p><p>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;本人也是Gakki酱的脑残粉，非常喜欢她的微笑，看了好多她的电视剧，比如：父女七日变、恋空、花水木、逃避虽可耻但有用、Legal High、全开女孩等，欢迎大家关注我的<a href="https://weibo.com/p/1005053310889015/home/" target="_blank" rel="noopener">微博</a>，比心~~~</p><p></p><p>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;平时喜欢的娱乐是打篮球和逛B站，对二次元有着一定的情怀，B站也给我机会，为了生活放弃了机会，不知道是对还是错，只能一路走到黑了。游戏的话，英雄联盟也陪伴了我的大学生活，现在都不怎么玩了，最多玩玩荣耀和吃鸡，但是还是少了当初那种在网吧5连坐开黑的感觉，我觉得人生最大的乐趣莫过于回忆，等老了，和老伴坐在板凳上面，说着过去的回忆，想想就很幸福。</p><p></p><p>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;作为一个程序员对技术不感兴趣，说来也惭愧，平时我也会更新自己的技术博客的，为了生活，不容易，fighting~</p><p></p><p>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;最后放一段爱豆的视频让大家欣赏一下，萨拉拉~</p><p></p>  <iframe src="//player.bilibili.com/player.html?aid=23675732&cid=39547539&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="80%" height="500px" style="margin-left:30px"><br>  </iframe>]]></content>
      
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
  
</search>
