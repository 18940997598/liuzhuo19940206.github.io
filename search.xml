<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>spring_annotation_day_13</title>
      <link href="/2018/10/19/spring-annotation-day-13/"/>
      <url>/2018/10/19/spring-annotation-day-13/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong> </p><p>AOP原理：</p><p>我们上篇文章已经描述了AOP的使用情况，现在来研究一下AOP的原理。首先从@EnableAspectJAutoProxy注解开始。</p><hr><h3 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h3><p>1）点击@EnableAspectJAutoProxy注解：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Target(ElementType.TYPE)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>@Import(AspectJAutoProxyRegistrar.class)<br>public @interface EnableAspectJAutoProxy<br></code></pre></td></tr></table></figure></p><p>发现，使用了@Import注解来注入组件。组件是AspectJAutoProxyRegistrar类。</p><p>2）点击AspectJAutoProxyRegistrar类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar&#123;<br>  ···<br>&#125;<br></code></pre></td></tr></table></figure></p><p>该类，实现了ImportBeanDefinitionRegistrar接口，说明是用来自定义注入组件的。其中有一个registerBeanDefinitions（）方法。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;<br><br>AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);<br><br>AnnotationAttributes enableAspectJAutoProxy =<br>AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);<br>if (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;)) &#123;<br>AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);<br>&#125;<br>if (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;)) &#123;<br>AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>查看其中的AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</p><p>最终会调用registerOrEscalateApcAsRequired方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs undefined">private static BeanDefinition registerOrEscalateApcAsRequired(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source) &#123;<br>Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);<br>if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;<br>BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);<br>if (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;<br>int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());<br>int requiredPriority = findPriorityForClass(cls);<br>if (currentPriority &lt; requiredPriority) &#123;<br>apcDefinition.setBeanClassName(cls.getName());<br>&#125;<br>&#125;<br>return null;<br>&#125;<br>RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);<br>beanDefinition.setSource(source);<br>beanDefinition.getPropertyValues().add(&quot;order&quot;, Ordered.HIGHEST_PRECEDENCE);<br>beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<br>registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);<br>return beanDefinition;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>最后是给容器注入了一个Bean：<br>id：internalAutoProxyCreator ==》 Class：AnnotationAwareAspectJAutoProxyCreator</p><hr><h3 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h3><p>@EnableAspectJAutoProxy注解帮我们注入了AnnotationAwareAspectJAutoProxyCreator组件，这个组件有什么作用呢？</p><p>我们观察一下AnnotationAwareAspectJAutoProxyCreator的继承关系：</p><p>AnnotationAwareAspectJAutoProxyCreator</p><p>&nbsp;&nbsp;&nbsp;AspectJAwareAdvisorAutoProxyCreator  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractAdvisorAutoProxyCreator  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractAutoProxyCreator</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware</strong></p><p><strong>关键:实现了两个接口，一个后置处理器(在Bean初始化完成前后做事情)、一个自动装配BeanFactory</strong></p><hr><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>打上断点：(与后置处理器，自动装配有关的)</p><p>1）AbstractAutoProxyCreator.setBeanFactory<br>2）AbstractAutoProxyCreator.postProcessBeforeInstantiation<br>3) AbstractAutoProxyCreator.postProcessAfterInitialization</p><p>4) AbstractAdvisorAutoProxyCreator.setBeanFactory(父类重写的方法也打上断点)<br>5）AbstractAdvisorAutoProxyCreator.initBeanFactory</p><p>6) AspectJAwareAdvisorAutoProxyCreator类没有相关的就不打上断点</p><p>7）AnnotationAwareAspectJAutoProxyCreator.initBeanFactory(父类重写的方法也打上断点)</p><p>8) MainConfigOfAOP配置类的中的两个Bean对象打上断点：<br>&nbsp;&nbsp;&nbsp;mathCalculator和logAspects</p><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>流程：<br>1）传入配置类，创建IoC容器<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAOP.class);<br></code></pre></td></tr></table></figure></p><p>2) 注册配置类，调用refresh（）, 刷新容器<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) &#123;<br>this();<br>register(annotatedClasses); //注入配置类<br>refresh();  //刷新容器<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3）registerBeanPostProcessors(beanFactory);注册bean的后置处理器，来拦截bean的初始化操作。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;1.先获取IoC容器已经定义了的需要创建对象的所有BeanPostProcessor<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);<br></code></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;2.给容器中加别的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;3.优先注册实现了PriorityOrdered接口的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;4.再注册实现了Ordered接口的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;5.注册没有实现优先级接口的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;6.注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象，保存到容器中</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 创建    internalAutoProxyCreator的BeanPostProcessor【AnnotationAwareAspectJAutoProxyCreator】 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.创建Bean对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.populateBean：给bean的属性赋值</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.initializeBean：初始化bean</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.invokeAwareMethods：处理Aware接口的回调：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">private void invokeAwareMethods(final String beanName, final Object bean) &#123;<br>if (bean instanceof Aware) &#123;<br>if (bean instanceof BeanNameAware) &#123;<br>((BeanNameAware) bean).setBeanName(beanName);<br>&#125;<br>if (bean instanceof BeanClassLoaderAware) &#123;<br>((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());<br>&#125;<br>if (bean instanceof BeanFactoryAware) &#123;<br>((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.applyBeanPostProcessorsBeforeInitialization:执行后置处理器的postProcessor：postProcessBeforeInitialization方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.invokeInitMethods：自定义的初始化方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.applyBeanPostProcessorsAfterInitialization：执行postProcessor：postProcessAfterInitialization方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;7.把BeanPostProcessor注册到BeanFactory中：beanFactory.addBeanPostProcessor（）</p><hr><p>以上是创建AnnotationAwareAspectJAutoProxyCreator的过程。</p><p>AnnotationAwareAspectJAutoProxyCreator =》InstantiationAwareBeanPostProcessor，而不是 BeanPostProcessor 后置处理器</p><p>InstantiationAwareBeanPostProcessor是 postProcessBeforeInstantiation（实例化）</p><p>BeanPostProcessor是postProcessBeforeInitialization（初始化）</p><p><strong>说明InstantiationAwareBeanPostProcessor后置处理器是 在Bean实例化前后执行</strong></p><p><strong>BeanPostProcessor后置处理器是 在Bean对象初始化前后执行</strong></p><p>4）finishBeanFactoryInitialization(beanFactory);完成BeanFactory初始化工作，创建剩下的没有创建的Bean组件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;1.遍历获取容器中所有的Bean，依次创建对象；getBean(beanName)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getBean()-&gt;doGetBean()-&gt;getSingleton()-&gt;createBean()</p><p>&nbsp;&nbsp;&nbsp;&nbsp;2.创建Bean：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.先从缓存中获取当前的Bean，如果能获取到，说明bean是之前被创建过，直接使用，否则再创建.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要创建了bean就会被缓存起来。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.createBean():创建Bean</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.resolveBeforeInstantiation():解析BeanPostProcessors<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>想让后置处理器在次能返回一个代理对象</strong>，如果能返回代理对象就使用，如果不能就继续。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.后置处理器先尝试返回代理对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bean=applyBeanPostProcessorsBeforeInstantiation();拿到所有的后置处理器，如果是 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InstantiationAwareBeanPostProcessor；就执行postProcessBeforeInstantiation方法<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined"> if (bean != null) &#123;<br>  bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.doCreateBean()：真正去创建一个bean实例；和3.6流程一样</p><hr><p>AnnotationAwareAspectJAutoProxyCreator[InstantiationAwareBeanPostProcessor]</p><p>1) 每一个bean创建之前，调用postProcessBeforeInstantiation()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关心<strong>mathCalculator</strong>和<strong>logAspects</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）判断当前bean是否是在advicedBean中（保存了所有需要增强bean）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）判断当前bean是否是基础类型的Advice、PointCut、Advisor、AopInfrastructureBean或者是否是切面(@Aspect)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）是否需要跳过</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）获取候选的增强器(切面里面的通知方法)【List<advisor> candidateAdvisors】<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个封装的通知方法的增强器是InstantiationModelAwarePointcutAdvisor<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判断每一个增强器是否是AspectJPointcutAdvisor类型的；返回true</advisor></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）永远返回false</p><p>2）创建对象<br>postProcessAfterInitialization：<br>return wrapIfNecessary(bean, beanName, cacheKey);//需要包装的情况下  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）获取当前bean的所有增强器(通知方法) Object[] specificInterceptors</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）找到候选的所有增强器(找哪些通知方法是需要切入当前bean方法的)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）获取到能在bean使用的增强器</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）给增强器排序</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）保存当前bean在advisedBeans中；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）如果当前bean需要增强，创建当前bean的代理对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）获取所有的增强器(通知方法)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）保存到proxyFactory</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）创建代理对象：Spring自动决定<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jdk代理<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cglib代理</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）给容器中返回当前组件使用cglib代理的对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5）以后容器中获取的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程</p><p>3）目标方法的执行流程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容器中保存了组件的代理对象(cglib增强后的对象)，这个对象里面保存了详细信息(比如增强器、目标对象，xxx)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）CglibAopProxy.intercept();拦截目标方法的执行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）根据ProxyFactory对象获取将要执行的目标方法拦截器</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List<object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</object></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）List<object> interceptorList保存所有拦截器：5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个默认的ExposeInvocationInterceptor和4个增强器</object></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）遍历所有的增强器，将其转为Interceptor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）将增强器转为List<methodinterceptor>,如果是MethodInterceptor，直接加入集合中，如果不是，使用AdvisorAdapter将增强器转为   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MethodInterceptor，转换完后返回MethodInterceptor数组</methodinterceptor></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）如果没有拦截器链，直接执行目标方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）如果有拦截器链，把需要执行的目标对象，目标方法，拦截器链等信息传入，创建一个CglibMethodInvocation对象，并调用<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object retVal = mi.proceed();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5) 拦截器链的触发过程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）如果没有拦截器执行，就直接执行目标方法，或者拦截器的索引和拦截器数组的个数-1一样大，执行目标方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）链式获取每一个拦截器，拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拦截器链的机制，保证通知方法与目标方法的执行顺序.<br><img src="/images/20181019201432.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1）@EnableAspectJAutoProxy注解 开启AOP功能</p><p>2）@EnableAspectJAutoProxy 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator</p><p>3）AnnotationAwareAspectJAutoProxyCreator是一个后置处理器</p><p>4）容器的创建流程：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）registerBeanPostProcessors()注册后置处理器，创建AnnotationAwareAspectJAutoProxyCreator对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）finishBeanFactoryInitialization()：初始化剩下的单实例bean<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）创建业务逻辑组件和切面组件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）组件创建完之后，判断组件是否需要增强。是：切面的通知方法，包装成增强器(Advisor);给业务逻辑组件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个代理对象 </p><p>5）执行目标方法：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）代理对象执行目标方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）CglibAopProxy.Intercept:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）得到目标方法的拦截器链(增强器包装成拦截器MethodIntercept)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）利用拦截器的链式机制，依次进入每一个拦截器进行执行；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）效果：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 正常执行：前置通知 -》目标方法 -》后置通知 -》返回通知<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 出现异常：前置通知 -》目标方法 -》后置通知 -》异常通知  </p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring和SpringMVC父子容器关系初窥</title>
      <link href="/2018/10/19/Spring%E5%92%8CSpringMVC%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8%E5%85%B3%E7%B3%BB%E5%88%9D%E7%AA%A5/"/>
      <url>/2018/10/19/Spring%E5%92%8CSpringMVC%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8%E5%85%B3%E7%B3%BB%E5%88%9D%E7%AA%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>最近由于项目的包扫描出现了问题，在解决问题的过程中，偶然发现了Spring和SpringMVC是有父子容器关系的，而且正是因为这个才往往会出现包扫描的问题，我们在此来分析和理解Spring和SpringMVC的父子容器关系并且给出Spring和SpringMVC配置文件中包扫描的官方推荐方式。</p><h3 id="二、概念理解和知识铺垫"><a href="#二、概念理解和知识铺垫" class="headerlink" title="二、概念理解和知识铺垫"></a>二、概念理解和知识铺垫</h3><p>在Spring整体框架的核心概念中，容器是核心思想，就是用来管理Bean的整个生命周期的，而在一个项目中，容器不一定只有一个，Spring中可以包括多个容器，而且容器有上下层关系</p><p>目前最常见的一种场景就是在一个项目中引入Spring和SpringMVC这两个框架，那么它其实就是两个容器，Spring是父容器，SpringMVC是其子容器</p><p>并且在Spring父容器中注册的Bean对于SpringMVC容器中是可见的，而在SpringMVC容器中注册的Bean对于Spring父容器中是不可见的，也就是子容器可以看见父容器中的注册的Bean，反之就不行。</p><p>我们可以使用统一的如下注解配置来对Bean进行批量注册，而不需要再给每个Bean单独使用xml的方式进行配置。</p><p><code>&lt;context:component-scan base-package=&quot;com.liuzhuo.www&quot; /&gt;</code></p><p>从Spring提供的参考手册中我们得知该配置的功能是扫描配置的base-package包下的所有使用了@Component注解的类，并且将它们自动注册到容器中，同时也扫描@Controller，@Service，@Respository这三个注解，因为他们是继承自@Component</p><hr><p>在项目中我们经常见到还有如下这个配置，其实有了上面的配置，这个是可以省略掉的，因为上面的配置会默认打开以下配置。</p><p>以下配置会默认声明了@Required、@Autowired、 @PostConstruct、@PersistenceContext、@Resource、@PreDestroy等注解</p><p><code>&lt;context:annotation-config/&gt;</code></p><p><strong>另外，还有一个和SpringMVC相关如下配置，经过验证，这个是SpringMVC必须要配置的，因为它声明了@RequestMapping、@RequestBody、@ResponseBody等。并且，该配置默认加载很多的参数绑定方法，比如json转换解析器等。</strong></p><p><code>&lt;mvc:annotation-driven /&gt;</code></p><p>而上面这句,配置Spring3.1之前的版本和以下配置方式等价</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!--配置注解控制器映射器,它是SpringMVC中用来将Request请求URL到映射到具体Controller--&gt;<br>&lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping&quot;/&gt;<br>&lt;!--配置注解控制器适配器,它是SpringMVC中用来将具体请求映射到具体方法--&gt;<br>&lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;/&gt;<br></code></pre></td></tr></table></figure><p>Spring3.1之后的版本和以下配置方式等价：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!--配置注解控制器映射器,它是SpringMVC中用来将Request请求URL到映射到具体Controller--&gt;<br>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;<br>&lt;!--配置注解控制器适配器,它是SpringMVC中用来将具体请求映射到具体方法--&gt;<br>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;<br></code></pre></td></tr></table></figure></p><h3 id="三、具体场景分析"><a href="#三、具体场景分析" class="headerlink" title="三、具体场景分析"></a>三、具体场景分析</h3><p>下面让我们来详细扒一扒Spring与SpringMVC的容器冲突的原因到底在那里？</p><p>我们共有Spring和SpringMVC两个容器，它们的配置文件分别为applicationContext.xml和applicationContext-MVC.xml</p><p>1、在applicationContext.xml中配置了&lt;context:component-scan base-package=“com.hafiz.www” /&gt;，负责所有需要注册的Bean的扫描和注册工作</p><p>2、在applicationContext-MVC.xml中配置&lt;mvc:annotation-driven /&gt;，负责SpringMVC相关注解的使用</p><p>3、启动项目我们发现SpringMVC无法进行跳转，将log的日志打印级别设置为DEBUG进行调试，发现SpringMVC容器中的请求好像没有映射到具体controller中</p><p>4、在applicationContext-MVC.xml中配置&lt;context:component-scan base-package=“com.hafiz.www” /&gt;，重启后，验证成功，springMVC跳转有效</p><p>下面我们来查看具体原因，翻看源码，从SpringMVC的DispatcherServlet开始往下找，我们发现SpringMVC初始化时，会寻找SpringMVC容器中的所有使用了@Controller注解的Bean，来确定其是否是一个handler</p><p>1、2两步的配置使得当前SpringMVC容器中并没有注册带有@Controller注解的Bean，而是把所有带有@Controller注解的Bean都注册在Spring这个父容器中了，所以SpringMVC找不到处理器，不能进行跳转。核心源码如下:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">protected void initHandlerMethods() &#123;<br>　　if (logger.isDebugEnabled()) &#123;<br>　　　　logger.debug(&quot;Looking for request mappings in application context: &quot; + getApplicationContext());<br>　　&#125;<br>　　String[] beanNames = (this.detectHandlerMethodsInAncestorContexts ?<br>　　　　　　  BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) :<br>　　　　　　　getApplicationContext().getBeanNamesForType(Object.class));<br>　　for (String beanName : beanNames) &#123;<br>　　　　if (isHandler(getApplicationContext().getType(beanName)))&#123;<br>　　　　　　detectHandlerMethods(beanName);<br>　　　　&#125;<br>　　&#125;<br>　　handlerMethodsInitialized(getHandlerMethods());<br>&#125;<br></code></pre></td></tr></table></figure></p><p>在方法isHandler中会判断当前bean的注解是否是controller，源码如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">protected boolean isHandler(Class&lt;?&gt; beanType) &#123;<br>　　return AnnotationUtils.findAnnotation(beanType, Controller.class) != null;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>而在第4步配置中，SpringMVC容器中也注册了所有带有@Controller注解的Bean，故SpringMVC能找到处理器进行处理，从而正常跳转。</p><p>我们找到了出现不能正确跳转的原因，那么它的解决办法是什么呢？</p><p>我们注意到在initHandlerMethods()方法中，detectHandlerMethodsInAncestorContexts这个Switch，它主要控制获取哪些容器中的bean以及是否包括父容器，默认是不包括的。</p><p>所以解决办法就是在SpringMVC的配置文件中配置HandlerMapping的detectHandlerMethodsInAncestorContexts属性为true即可（这里需要根据具体项目看使用的是哪种HandlerMapping），让它检测父容器的bean。如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;&gt;<br>  &lt;property name=&quot;detectHandlerMethodsInAncestorContexts&quot;&gt;<br>      &lt;value&gt;true&lt;/value&gt;<br>  &lt;/property&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>但在实际工程中会包括很多配置，我们按照官方推荐根据不同的业务模块来划分不同容器中注册不同类型的Bean：</p><p>Spring父容器负责所有其他非@Controller注解的Bean的注册，而SpringMVC只负责@Controller注解的Bean的注册，使得他们各负其责、明确边界。配置方式如下</p><p>1、在applicationContext.xml中配置:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!-- Spring容器中注册非@controller注解的Bean --&gt;<br>&lt;context:component-scan base-package=&quot;com.hafiz.www&quot;&gt;<br>  &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;<br>&lt;/context:component-scan&gt;<br></code></pre></td></tr></table></figure></p><p>2、applicationContext-MVC.xml中配置<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!-- SpringMVC容器中只注册带有@controller注解的Bean --&gt;<br>&lt;context:component-scan base-package=&quot;com.hafiz.www&quot; use-default-filters=&quot;false&quot;&gt;<br>  &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;<br>&lt;/context:component-scan&gt;<br></code></pre></td></tr></table></figure></p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>这样我们在清楚了Spring和SpringMVC的父子容器关系、以及扫描注册的原理以后，根据官方建议我们就可以很好把不同类型的Bean分配到不同的容器中进行管理。再出现Bean找不到或者SpringMVC不能跳转以及事务的配置失效的问题，我们就可以很快的定位以及解决问题了。很开心，有木有~</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_12</title>
      <link href="/2018/10/18/spring-annotation-day-12/"/>
      <url>/2018/10/18/spring-annotation-day-12/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><h3 id="AOP介绍"><a href="#AOP介绍" class="headerlink" title="AOP介绍"></a>AOP介绍</h3><p>AOP是Spring 框架的一个关键组件，全称为Aspect-Oriented-Programming（面向切面编程），目前已是一种比较成熟的编程方式。</p><p>AOP采取横向抽取机制，将分散在各个方法中的重复代码提取出来，然后在编译或运行的时候，再将这些代码应用到需要执行的地方。</p><p><strong>注：提取出来的代码应用到需要执行的地方，并不会把源代码加到需要的地方执行，即源代码文件不会更改，但是它会影响最终的机器编译代码</strong></p><p>意思就是，有一些通用功能的代码可以提取出来，然后在使用的时候应用进去就可以了，比如表单验证和日志记录等等。</p><h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><p>Aspect（切面）</p><p>通常指封装起来用于插入到指定位置实现某项功能的类</p><p>Join point（连接点）</p><p>在SpringAOP中，连接点指方法的调用</p><p>Pointcut（切入点）</p><p>切面与程序流程的交叉点，即那些需要处理的连接点，通常在程序中，切入点指的是类或者方法名</p><p>Advice（通知/增强处理）</p><p>就是程序实际运行之前或之后执行的方法，也就是AOP加入的代码</p><p>Target Object（目标对象）</p><p>即需要加入AOP代码的对象</p><p>Proxy（代理）</p><p>AOP框架动态生成的一个对象，该对象可以作为目标对象使用</p><p>Weaving（织入）</p><p>把切面连接到其它的应用程序类型或者对象上，并创建一个需要Advice对象的过程</p><h3 id="AOP的例子（JDK代理）"><a href="#AOP的例子（JDK代理）" class="headerlink" title="AOP的例子（JDK代理）"></a>AOP的例子（JDK代理）</h3><p>1）首先建立一个java工程</p><p><img src="/images/20181018211302.png" style="width:50%"></p><p>UserDao接口:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package com.aop.jdk;<br><br>public interface UserDao &#123;<br> <br> public void addUser();<br> <br>&#125;<br></code></pre></td></tr></table></figure></p><p>UserDaoImpl:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package com.aop.jdk;<br><br>public class UserDaoImpl implements UserDao &#123;<br><br> @Override<br> public void addUser() &#123;<br>   <br>   System.out.println(&quot;新增用户&quot;);<br> &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure></p><p>JdkProxy:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package com.aop.jdk;<br><br>import java.lang.reflect.InvocationHandler;<br>import java.lang.reflect.Method;<br>import java.lang.reflect.Proxy;<br><br>import com.aop.aspect.MyAspect;<br><br>/**<br>* JDK代理类<br>*/<br>public class JdkProxy implements InvocationHandler&#123;<br> <br> // 声明目标类接口<br> private UserDao userDao;<br> <br> // 创建代理方法<br> public  Object createProxy(UserDao userDao) &#123;<br>   <br>   this.userDao = userDao;<br>   <br>   // 1.类加载器<br>   ClassLoader classLoader = JdkProxy.class.getClassLoader();<br>   <br>   // 2.被代理对象实现的所有接口<br>   @SuppressWarnings(&quot;rawtypes&quot;)<br>   Class[] clazz = userDao.getClass().getInterfaces();<br>   <br>   // 3.使用代理类，进行增强，返回的是代理后的对象<br>   return  Proxy.newProxyInstance(classLoader,clazz,this);<br>   <br> &#125;<br> <br> /*<br>  * 所有动态代理类的方法调用，都会交由invoke()方法去处理<br>  * proxy 被代理后的对象 <br>  * method 将要执行的方法<br>  * args 执行方法时需要的参数<br>  */<br> @Override<br> public Object invoke(Object proxy, Method method, Object[] args) <br>     throws Throwable &#123;<br>   <br>   // 声明切面<br>   MyAspect myAspect = new MyAspect();<br>   <br>   // 指定位置程序执行前执行这个方法<br>   myAspect.start();<br>   <br>   // 在目标类上调用方法<br>   Object obj = method.invoke(userDao, args);<br>   <br>   // 指定位置程序执行结束后执行<br>   myAspect.end();<br>   <br>   return obj;<br> &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure></p><p>MyAspect:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package com.aop.aspect;<br><br>/**<br>*  切面<br>*/<br>public class MyAspect &#123;<br> <br> public void start()&#123;<br>   System.out.println(&quot;模拟事务处理功能 ...&quot;);<br> &#125;<br> <br> public void end()&#123;<br>   System.out.println(&quot;程序结束后执行此处 ...&quot;);<br> &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure></p><p>JdkTest:</p><p>测试结果项目编写完之后运行该类</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package com.aop.test;<br><br>import com.aop.jdk.JdkProxy;<br>import com.aop.jdk.UserDao;<br>import com.aop.jdk.UserDaoImpl;<br><br>public class JdkTest &#123;<br> <br> public static void main(String[] args) &#123;<br>   <br>   // 创建代理对象<br>   JdkProxy jdkProxy = new JdkProxy();<br>        // 创建目标对象<br>   UserDao userDao= new UserDaoImpl();<br>   // 从代理对象中获取增强后的目标对象<br>   UserDao userDao1 = (UserDao) jdkProxy.createProxy(userDao);<br>   // 执行方法<br>   userDao1.addUser();<br> &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>运行之后，我们可以看到以下结果：<br><img src="/images/20181018211845.png" style="width:50%"></p><hr><p>我们可以看到，在我们执行新增用户的方法时，依据我们AOP编程，系统自动执行了start方法和end方法</p><p>在实际运用中，我们可以把一些通用的方法放到start和end的位置，在需要的方法处加入切面即可</p><p>此外，建议大家再了解下AspectJ</p><p>AspectJ实现AOP有两种方式：一种是基于XML的声明式，另一种是基于注解的声明式</p><p>基于XML的声明式AspectJ要便捷一些，但是存在配置信息多的缺点</p><p>基于注解的声明式AspectJ则通过注解的方式减少了很多配置信息</p><h3 id="Spring中的AOP使用"><a href="#Spring中的AOP使用" class="headerlink" title="Spring中的AOP使用"></a>Spring中的AOP使用</h3><p>1）创建新的配置类MainConfigOfAOP<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class MainConfigOfAOP &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 在com.liuzhuo.aop包下，创建MathCalculator类<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MathCalculator &#123;<br><br>    public int div(int a, int b) &#123;<br>        return a / b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 在com.liuzhuo.aop包下，创建切面类MathCalculator<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class LogAspects &#123;<br><br>    public void logStart()&#123;<br>        System.out.println(&quot;方法调用之前------&quot;);<br>    &#125;<br><br>    public void logEnd()&#123;<br>        System.out.println(&quot;方法调用之后-------&quot;);<br>    &#125;<br><br>    public void logReturn()&#123;<br>        System.out.println(&quot;方法成功返回之后------&quot;);<br>    &#125;<br><br>    public void logThrowing()&#123;<br>        System.out.println(&quot;方法出现异常之后------&quot;);<br>    &#125;<br><br>    public void logRound()&#123;<br>        //环绕方法<br>        System.out.println(&quot;环绕：方法调用之前----&quot;);<br>        System.out.println(&quot;环绕：方法调用之后----&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 添加AOP的依赖，在pom文件中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">      <br>&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;<br>    &lt;version&gt;5.1.1.RELEASE&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>4) 将切面与目标方法进行连接：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Aspect<br>public class LogAspects &#123;<br><br>    @Pointcut(&quot;execution(public int com.liuzhuo.aop.MathCalculator.div(int,int))&quot;)<br>    public void pointCut() &#123;<br>    &#125;<br><br>    //调用本类的切点<br>    @Before(&quot;pointCut()&quot;)<br>    public void logStart() &#123;<br>        System.out.println(&quot;方法调用之前------&quot;);<br>    &#125;<br><br>    //调用外面类的切点<br>    @After(&quot;com.liuzhuo.aop.LogAspects.pointCut()&quot;)<br>    public void logEnd() &#123;<br>        System.out.println(&quot;方法调用之后-------&quot;);<br>    &#125;<br><br>    @AfterReturning(value = &quot;pointCut()&quot;, returning = &quot;returns&quot;)<br>    public void logReturn(Object returns) &#123;<br>        System.out.println(&quot;方法成功返回之后------:&quot; + returns);<br>    &#125;<br><br>    @AfterThrowing(value = &quot;pointCut()&quot;, throwing = &quot;e&quot;)<br>    public void logThrowing(Exception e) &#123;<br>        System.out.println(&quot;方法出现异常之后------:&quot; + e);<br>    &#125;<br><br>    @Around(&quot;pointCut()&quot;)<br>    public Object logRound(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;<br>        //环绕方法<br>        System.out.println(&quot;环绕：方法调用之前----&quot;);<br>        Object proceed = proceedingJoinPoint.proceed();<br>        System.out.println(&quot;环绕：方法调用之后----&quot;);<br>        return proceed;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5) 将切面和目标类注入到容器中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class MainConfigOfAOP &#123;<br><br>    @Bean<br>    public MathCalculator mathCalculator() &#123;<br>        return new MathCalculator();<br>    &#125;<br><br>    @Bean<br>    public LogAspects logAspects() &#123;<br>        return new LogAspects();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>6) <strong>开启Aspect的注解驱动</strong>：@EnableAspectJAutoProxy<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@EnableAspectJAutoProxy //开启AOP注解驱动<br>public class MainConfigOfAOP &#123;<br><br>    @Bean<br>    public MathCalculator mathCalculator() &#123;<br>        return new MathCalculator();<br>    &#125;<br><br>    @Bean<br>    public LogAspects logAspects() &#123;<br>        return new LogAspects();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>7) 创建新的测试类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IoCTest_AOP &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAOP.class);<br><br>        //不要自己创建MathCalculator类<br>        //MathCalculator mathCalculator = new MathCalculator();<br>        //mathCalculator.div(1, 1);<br><br>        MathCalculator mathCalculator = applicationContext.getBean(MathCalculator.class);<br>        mathCalculator.div(1, 1);<br><br>        applicationContext.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>8) 运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">环绕：方法调用之前----<br>方法调用之前------<br>div:正在执行-----<br>环绕：方法调用之后----<br>方法调用之后-------<br>方法成功返回之后------:1<br>十月 18, 2018 10:03:03 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@3a4afd8d: startup date [Thu Oct 18 22:03:02 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>将业务逻辑组件和切面类都加入到容器中，告诉Spring哪个是切面类(Aspect)  </li><li>在切面类上的每一个通知方法上标注通知注解，告诉Spring何时何地运行（切入点表达式）</li><li>开启基于注解的AOP模式：@EnableAspectJAutoProxy</li></ol>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Bean的生命周期</title>
      <link href="/2018/10/18/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/10/18/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>Spring作为当前Java最流行、最强大的轻量级框架，受到了程序员的热烈欢迎。准确的了解Spring Bean的生命周期是非常必要的。</p><p>我们通常使用ApplicationContext作为Spring容器。这里，我们讲的也是 ApplicationContext中Bean的生命周期。而实际上BeanFactory也是差不多的，只不过处理器需要手动注册。</p><h3 id="一、生命周期流程图："><a href="#一、生命周期流程图：" class="headerlink" title="一、生命周期流程图："></a>一、生命周期流程图：</h3><p>Spring Bean的完整生命周期从创建Spring容器开始，直到最终Spring容器销毁Bean，这其中包含了一系列关键点。<br><img src="/images/20181018162309.png"><br><img src="/images/20181018162419.png"></p><p>若容器注册了以上各种接口，程序那么将会按照以上的流程进行。下面将仔细讲解各接口作用。</p><h3 id="二、各种接口方法分类"><a href="#二、各种接口方法分类" class="headerlink" title="二、各种接口方法分类"></a>二、各种接口方法分类</h3><p>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：</p><p>1、Bean自身的方法:这个包括了Bean本身调用的方法和通过配置文件中<bean>的init-method和destroy-method指定的方法</bean></p><p>2、Bean级生命周期接口方法:这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法</p><p>3、容器级生命周期接口方法:这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</p><p>4、工厂后处理器接口方法:这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</p><h3 id="三、演示"><a href="#三、演示" class="headerlink" title="三、演示"></a>三、演示</h3><p>我们用一个简单的Spring Bean来演示一下Spring Bean的生命周期。</p><p>1、首先是一个简单的Spring Bean，调用Bean自身的方法和Bean级生命周期接口方法，为了方便演示，它实现了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这4个接口，同时有2个方法，对应配置文件中<bean>的init-method和destroy-method。如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package springBeanTest;<br><br>import org.springframework.beans.BeansException;<br>import org.springframework.beans.factory.BeanFactory;<br>import org.springframework.beans.factory.BeanFactoryAware;<br>import org.springframework.beans.factory.BeanNameAware;<br>import org.springframework.beans.factory.DisposableBean;<br>import org.springframework.beans.factory.InitializingBean;<br><br>/**<br>* @author qsk<br>*/<br>public class Person implements BeanFactoryAware, BeanNameAware,<br>       InitializingBean, DisposableBean &#123;<br><br>   private String name;<br>   private String address;<br>   private int phone;<br><br>   private BeanFactory beanFactory;<br>   private String beanName;<br><br>   public Person() &#123;<br>       System.out.println(&quot;【构造器】调用Person的构造器实例化&quot;);<br>   &#125;<br><br>   public String getName() &#123;<br>       return name;<br>   &#125;<br><br>   public void setName(String name) &#123;<br>       System.out.println(&quot;【注入属性】注入属性name&quot;);<br>       this.name = name;<br>   &#125;<br><br>   public String getAddress() &#123;<br>       return address;<br>   &#125;<br><br>   public void setAddress(String address) &#123;<br>       System.out.println(&quot;【注入属性】注入属性address&quot;);<br>       this.address = address;<br>   &#125;<br><br>   public int getPhone() &#123;<br>       return phone;<br>   &#125;<br><br>   public void setPhone(int phone) &#123;<br>       System.out.println(&quot;【注入属性】注入属性phone&quot;);<br>       this.phone = phone;<br>   &#125;<br><br>   @Override<br>   public String toString() &#123;<br>       return &quot;Person [address=&quot; + address + &quot;, name=&quot; + name + &quot;, phone=&quot;<br>               + phone + &quot;]&quot;;<br>   &#125;<br><br>   // 这是BeanFactoryAware接口方法<br>   @Override<br>   public void setBeanFactory(BeanFactory arg0) throws BeansException &#123;<br>       System.out<br>               .println(&quot;【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()&quot;);<br>       this.beanFactory = arg0;<br>   &#125;<br><br>   // 这是BeanNameAware接口方法<br>   @Override<br>   public void setBeanName(String arg0) &#123;<br>       System.out.println(&quot;【BeanNameAware接口】调用BeanNameAware.setBeanName()&quot;);<br>       this.beanName = arg0;<br>   &#125;<br><br>   // 这是InitializingBean接口方法<br>   @Override<br>   public void afterPropertiesSet() throws Exception &#123;<br>       System.out<br>               .println(&quot;【InitializingBean接口】调用InitializingBean.afterPropertiesSet()&quot;);<br>   &#125;<br><br>   // 这是DiposibleBean接口方法<br>   @Override<br>   public void destroy() throws Exception &#123;<br>       System.out.println(&quot;【DiposibleBean接口】调用DiposibleBean.destory()&quot;);<br>   &#125;<br><br>   // 通过&lt;bean&gt;的init-method属性指定的初始化方法<br>   public void myInit() &#123;<br>       System.out.println(&quot;【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法&quot;);<br>   &#125;<br><br>   // 通过&lt;bean&gt;的destroy-method属性指定的初始化方法<br>   public void myDestory() &#123;<br>       System.out.println(&quot;【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法&quot;);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></bean></p><p>2、接下来是演示BeanPostProcessor接口的方法，如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package springBeanTest;<br><br>import org.springframework.beans.BeansException;<br>import org.springframework.beans.factory.config.BeanPostProcessor;<br><br>public class MyBeanPostProcessor implements BeanPostProcessor &#123;<br><br>   public MyBeanPostProcessor() &#123;<br>       super();<br>       System.out.println(&quot;这是BeanPostProcessor实现类构造器！！&quot;);<br>       // TODO Auto-generated constructor stub<br>   &#125;<br><br>   @Override<br>   public Object postProcessAfterInitialization(Object arg0, String arg1)<br>           throws BeansException &#123;<br>       System.out<br>       .println(&quot;BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！&quot;);<br>       return arg0;<br>   &#125;<br><br>   @Override<br>   public Object postProcessBeforeInitialization(Object arg0, String arg1)<br>           throws BeansException &#123;<br>       System.out<br>       .println(&quot;BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！&quot;);<br>       return arg0;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如上，BeanPostProcessor接口包括2个方法: postProcessAfterInitialization和postProcessBeforeInitialization，这两个方法的第一个参数都是要处理的Bean对象，第二个参数都是Bean的name。返回值也都是要处理的Bean对象。这里要注意。</strong></p><p>3、InstantiationAwareBeanPostProcessor 接口本质是BeanPostProcessor的子接口，一般我们继承Spring为其提供的适配器类InstantiationAwareBeanPostProcessor Adapter来使用它，如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package springBeanTest;<br><br>import java.beans.PropertyDescriptor;<br><br>import org.springframework.beans.BeansException;<br>import org.springframework.beans.PropertyValues;<br>import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;<br><br>public class MyInstantiationAwareBeanPostProcessor extends<br>       InstantiationAwareBeanPostProcessorAdapter &#123;<br><br>   public MyInstantiationAwareBeanPostProcessor() &#123;<br>       super();<br>       System.out<br>               .println(&quot;这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！&quot;);<br>   &#125;<br><br>   // 接口方法、实例化Bean之前调用<br>   @Override<br>   public Object postProcessBeforeInstantiation(Class beanClass,<br>           String beanName) throws BeansException &#123;<br>       System.out<br>               .println(&quot;InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法&quot;);<br>       return null;<br>   &#125;<br><br>   // 接口方法、实例化Bean之后调用<br>   @Override<br>   public Object postProcessAfterInitialization(Object bean, String beanName)<br>           throws BeansException &#123;<br>       System.out<br>               .println(&quot;InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法&quot;);<br>       return bean;<br>   &#125;<br><br>   // 接口方法、设置某个属性时调用<br>   @Override<br>   public PropertyValues postProcessPropertyValues(PropertyValues pvs,<br>           PropertyDescriptor[] pds, Object bean, String beanName)<br>           throws BeansException &#123;<br>       System.out<br>               .println(&quot;InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法&quot;);<br>       return pvs;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>这个有3个方法，其中第二个方法postProcessAfterInitialization就是重写了BeanPostProcessor的方法。第三个方法postProcessPropertyValues用来操作属性，返回值也应该是PropertyValues对象。</strong></p><p>4、演示工厂后处理器接口方法，如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package springBeanTest;<br><br>import org.springframework.beans.BeansException;<br>import org.springframework.beans.factory.config.BeanDefinition;<br>import org.springframework.beans.factory.config.BeanFactoryPostProcessor;<br>import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;<br><br>public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;<br><br>   public MyBeanFactoryPostProcessor() &#123;<br>       super();<br>       System.out.println(&quot;这是BeanFactoryPostProcessor实现类构造器！！&quot;);<br>   &#125;<br><br>   @Override<br>   public void postProcessBeanFactory(ConfigurableListableBeanFactory arg0)<br>           throws BeansException &#123;<br>       System.out.println(&quot;BeanFactoryPostProcessor调用postProcessBeanFactory方法&quot;);<br>       BeanDefinition bd = arg0.getBeanDefinition(&quot;person&quot;);<br>       bd.getPropertyValues().addPropertyValue(&quot;phone&quot;, &quot;110&quot;);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>5、配置文件如下beans.xml，很简单，使用ApplicationContext处理器不用手动注册：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br><br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;<br>   xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;<br>   xsi:schemaLocation=&quot;<br>           http://www.springframework.org/schema/beans <br>           http://www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;&gt;<br><br>   &lt;bean id=&quot;beanPostProcessor&quot; class=&quot;springBeanTest.MyBeanPostProcessor&quot;&gt;<br>   &lt;/bean&gt;<br><br>   &lt;bean id=&quot;instantiationAwareBeanPostProcessor&quot; class=&quot;springBeanTest.MyInstantiationAwareBeanPostProcessor&quot;&gt;<br>   &lt;/bean&gt;<br><br>   &lt;bean id=&quot;beanFactoryPostProcessor&quot; class=&quot;springBeanTest.MyBeanFactoryPostProcessor&quot;&gt;<br>   &lt;/bean&gt;<br>   <br>   &lt;bean id=&quot;person&quot; class=&quot;springBeanTest.Person&quot; init-method=&quot;myInit&quot;<br>       destroy-method=&quot;myDestory&quot; scope=&quot;singleton&quot; p:name=&quot;张三&quot; p:address=&quot;广州&quot;<br>       p:phone=&quot;15900000000&quot; /&gt;<br><br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure></p><p>6、下面测试一下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package springBeanTest;<br><br>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;<br><br>public class BeanLifeCycle &#123;<br><br>   public static void main(String[] args) &#123;<br><br>       System.out.println(&quot;现在开始初始化容器&quot;);<br>       <br>       ApplicationContext factory = new ClassPathXmlApplicationContext(&quot;springBeanTest/beans.xml&quot;);<br>       System.out.println(&quot;容器初始化成功&quot;);    <br>       //得到Preson，并使用<br>       Person person = factory.getBean(&quot;person&quot;,Person.class);<br>       System.out.println(person);<br>       <br>       System.out.println(&quot;现在开始关闭容器！&quot;);<br>       ((ClassPathXmlApplicationContext)factory).registerShutdownHook();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关闭容器使用的是实际是AbstractApplicationContext的钩子方法。</p><p>我们来看一下结果：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs undefined">现在开始初始化容器<br>2014-5-18 15:46:20 org.springframework.context.support.AbstractApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@19a0c7c: startup date [Sun May 18 15:46:20 CST 2014]; root of context hierarchy<br>2014-5-18 15:46:20 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions<br>信息: Loading XML bean definitions from class path resource [springBeanTest/beans.xml]<br>这是BeanFactoryPostProcessor实现类构造器！！<br>BeanFactoryPostProcessor调用postProcessBeanFactory方法<br>这是BeanPostProcessor实现类构造器！！<br>这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！<br>2014-5-18 15:46:20 org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletons<br>信息: Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@9934d4: defining beans [beanPostProcessor,instantiationAwareBeanPostProcessor,beanFactoryPostProcessor,person]; root of factory hierarchy<br>InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法<br>【构造器】调用Person的构造器实例化<br>InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法<br>【注入属性】注入属性address<br>【注入属性】注入属性name<br>【注入属性】注入属性phone<br>【BeanNameAware接口】调用BeanNameAware.setBeanName()<br>【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()<br>BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！<br>【InitializingBean接口】调用InitializingBean.afterPropertiesSet()<br>【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法<br>BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！<br>InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法<br>容器初始化成功<br>Person [address=广州, name=张三, phone=110]<br>现在开始关闭容器！<br>【DiposibleBean接口】调用DiposibleBean.destory()<br>【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IntelliJ Idea 常用快捷键 列表(实战终极总结！！！！)</title>
      <link href="/2018/10/18/idea/"/>
      <url>/2018/10/18/idea/</url>
      
        <content type="html"><![CDATA[<h3 id="自动代码"><a href="#自动代码" class="headerlink" title="自动代码"></a>自动代码</h3><p>常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码 。</p><p>例如要输入for(User user : users) 只需输入user.for+Tab ;</p><p><strong>再比如，要输入Date birthday = user.getBirthday() 只需输入user.getBirthday().var+Tab即可。<br>代码标签输入完成后，按Tab，生成代码。</strong></p><p>Ctrl+Alt+O 优化导入的类和包 </p><p>Alt+Insert 生成代码(如get,set方法,构造函数等)   或者右键（Generate） </p><p>fori/sout/psvm + Tab  </p><p>Ctrl+Alt+T  生成try catch  或者 Alt+enter </p><p>CTRL+ALT+T  把选中的代码放在 TRY{} IF{} ELSE{} 里 </p><p>Ctrl + O 重写方法  </p><p>Ctrl + I 实现方法 </p><p>Ctrl+shift+U 大小写转化  </p><p>ALT+回车    导入包,自动修正  </p><p>ALT+/       代码提示 </p><p>CTRL+J      自动代码  </p><p>Ctrl+Shift+J，整合两行为一行 </p><p>CTRL+空格   代码提示  </p><p>CTRL+SHIFT+SPACE 自动补全代码  </p><p>CTRL+ALT+L  格式化代码  </p><p>CTRL+ALT+I  自动缩进  </p><p>CTRL+ALT+O  优化导入的类和包  </p><p>ALT+INSERT  生成代码(如GET,SET方法,构造函数等)  </p><p>CTRL+E      最近更改的代码  </p><p>CTRL+ALT+SPACE  类名或接口名提示  </p><p>CTRL+P   方法参数提示  </p><p>CTRL+Q，可以看到当前方法的声明 </p><p>Shift+F6  重构-重命名 (包、类、方法、变量、甚至注释等) </p><p>Ctrl+Alt+V 提取变量 </p><h3 id="查询快捷键"><a href="#查询快捷键" class="headerlink" title="查询快捷键"></a>查询快捷键</h3><p>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 </p><p>CTRL+ALT+ left/right 前后导航编辑过的地方 </p><p>ALT+7  靠左窗口显示当前文件的结构 </p><p>Ctrl+F12 浮动显示当前文件的结构 </p><p>ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 </p><p>CTRL+ALT+F7  找到你的函数或者变量或者类的所有引用到的地方 </p><p>Ctrl+Shift+Alt+N 查找类中的方法或变量 </p><p>双击SHIFT 在项目的所有目录查找文件 </p><p>Ctrl+N   查找类 </p><p>Ctrl+Shift+N 查找文件 </p><p>CTRL+G   定位行  </p><p>CTRL+F   在当前窗口查找文本  </p><p>CTRL+SHIFT+F  在指定窗口查找文本  </p><p>CTRL+R   在 当前窗口替换文本  </p><p>CTRL+SHIFT+R  在指定窗口替换文本  </p><p>ALT+SHIFT+C  查找修改的文件  </p><p>CTRL+E   最近打开的文件  </p><p>F3   向下查找关键字出现位置  </p><p>SHIFT+F3  向上一个关键字出现位置  </p><p>选中文本，按Alt+F3 ，高亮相同文本，F3逐个往下查找相同文本 </p><p>F4   查找变量来源  </p><p>CTRL+SHIFT+O  弹出显示查找内容 </p><p>Ctrl+W 选中代码，连续按会有其他效果 </p><p>F2 或Shift+F2 高亮错误或警告快速定位 </p><p>Ctrl+Up/Down 光标跳转到第一行或最后一行下 </p><p>Ctrl+B 快速打开光标处的类或方法  </p><p>CTRL+ALT+B  找所有的子类  </p><p>CTRL+SHIFT+B  找变量的类  </p><p>Ctrl+Shift+上下键  上下移动代码 </p><p>Ctrl+Alt+ left/right 返回至上次浏览的位置 </p><p>Ctrl+X 删除行 </p><p>Ctrl+D 复制行 </p><p>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>…</em>/ ） </p><p>Ctrl+H 显示类结构图 </p><p>Ctrl+Q 显示注释文档 </p><p>Alt+F1 查找代码所在位置 </p><p>Alt+1 快速打开或隐藏工程面板 </p><p>Alt+ left/right 切换代码视图 </p><p>ALT+ ↑/↓  在方法间快速移动定位  </p><p>CTRL+ALT+ left/right 前后导航编辑过的地方 </p><p>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 </p><p>Alt+6    查找TODO </p><h3 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h3><p>SHIFT+ENTER 另起一行 </p><p>CTRL+Z   倒退(撤销) </p><p>CTRL+SHIFT+Z  向前(取消撤销) </p><p>CTRL+ALT+F12  资源管理器打开文件夹  </p><p>ALT+F1   查找文件所在目录位置  </p><p>SHIFT+ALT+INSERT 竖编辑模式  </p><p>CTRL+F4  关闭当前窗口 </p><p>Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 </p><p>Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） </p><h3 id="svn快捷键"><a href="#svn快捷键" class="headerlink" title="svn快捷键"></a>svn快捷键</h3><p>ctrl+k 提交代码到SVN </p><p>ctrl+t 更新代码 </p><h3 id="调试快捷键"><a href="#调试快捷键" class="headerlink" title="调试快捷键"></a>调试快捷键</h3><p>其实常用的 就是F8 F7 F9 最值得一提的就是Drop Frame 可以让运行过的代码从头再来。</p><p>alt+F8    debug时选中查看值 </p><p>Alt+Shift+F9，选择 Debug </p><p>Alt+Shift+F10，选择 Run </p><p>Ctrl+Shift+F9，编译 </p><p>Ctrl+Shift+F8，查看断点 </p><p>F7，步入 </p><p>Shift+F7，智能步入 </p><p>Alt+Shift+F7，强制步入 </p><p>F8，步过 </p><p>Shift+F8，步出 </p><p>Alt+Shift+F8，强制步过 </p><p>Alt+F9，运行至光标处 </p><p>Ctrl+Alt+F9，强制运行至光标处 </p><p>F9，恢复程序 </p><p>Alt+F10，定位到断点 </p><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>Ctrl+Alt+Shift+T，弹出重构菜单 </p><p>Shift+F6，重命名 </p><p>F6，移动 </p><p>F5，复制 </p><p>Alt+Delete，安全删除 </p><p>Ctrl+Alt+N，内联 </p><h3 id="十大Intellij-IDEA快捷键"><a href="#十大Intellij-IDEA快捷键" class="headerlink" title="十大Intellij IDEA快捷键"></a>十大Intellij IDEA快捷键</h3><p>Intellij IDEA中有很多快捷键让人爱不释手，stackoverflow上也有一些有趣的讨论。每个人都有自己的最爱，想排出个理想的榜单还真是困难。 </p><p>以前也整理过Intellij的快捷键，这次就按照我日常开发时的使用频率，简单分类列一下我最喜欢的十大快捷-神-键吧。 </p><p>1 <strong>智能提示:</strong><br>Intellij首当其冲的当然就是Intelligence智能！基本的代码提示用Ctrl+Space，还有更智能地按类型信息提示Ctrl+Shift+Space，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。</p><p>用F2/ Shift+F2移动到有错误的代码，Alt+Enter快速修复(即Eclipse中的Quick Fix功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲Ctrl+Shift+Enter就能自动补全末尾的字符。而且不只是括号，例如敲完if/for时也可以自动补上{}花括号。 </p><p>最后要说一点，Intellij能够智能感知Spring、Hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。 </p><p>2 <strong>重构:</strong><br>Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。 </p><p>切入正题，先说一个无敌的重构功能大汇总快捷键Ctrl+Shift+Alt+T，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如Shift+F6直接就是改名，Ctrl+Alt+V则是提取变量。 </p><p>3 <strong>代码生成：</strong><br>这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码，用Ctrl+J可以查看所有模板。后面“辅助”一节中将会讲到Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter/setter。 </p><p>另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入user.for+Tab。再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。 </p><p>4 <strong>编辑：</strong><br>编辑中不得不说的一大神键就是能够自动按语法选中代码的Ctrl+W以及反向的Ctrl+Shift+W了。此外，Ctrl+Left/Right移动光标到前/后单词，Ctrl+[/]移动到前/后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left/Right/[]加上Shift的话就能选中跳跃范围内的代码。Alt+Forward/Backward移动到前/后方法。还有些非常普通的像Ctrl+Y删除行、Ctrl+D复制行、Ctrl+折叠代码就不多说了。 </p><p>关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。另外，Intellij的书签功能也是不错的，用Ctrl+Shift+Num定义1-10书签(再次按这组快捷键则是删除书签)，然后通过Ctrl+Num跳转。这避免了多次使用前/下一编辑位置Ctrl+Left/Right来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。</p><p>5 <strong>查找打开：</strong><br>类似Eclipse，Intellij的Ctrl+N/Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按Shift+Shift即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。 </p><p>类的继承关系则可用Ctrl+H打开类层次窗口，在继承层次上跳转则用Ctrl+B/Ctrl+Alt+B分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用Ctrl+F12。 </p><p>要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用Ctrl+F/Ctrl+Shift+F在当前窗口或全工程中查找，再配合F3/Shift+F3前后移动到下一匹配处。 </p><p>Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。 </p><p>6 <strong>其他辅助：</strong><br>以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有：</p><p>Ø  命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。 </p><p>Ø  新建：Alt+Insert可以新建类、方法等任何东西。 </p><p>Ø  格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。 </p><p>Ø  切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。 </p><p>Ø  单元测试：Ctrl+Alt+T创建单元测试用例。 </p><p>Ø  运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。 </p><p>Ø  调试：F7/F8/F9分别对应Step into，Step over，Continue。<br><i><strong>此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。</strong> </i></p><p>Ø  Top #10切来切去：Ctrl+Tab </p><p>Ø  Top #9选你所想：Ctrl+W </p><p>Ø  Top #8代码生成：Template/Postfix +Tab </p><p>Ø  Top #7发号施令：Ctrl+Shift+A </p><p>Ø  Top #6无处藏身：Shift+Shift </p><p>Ø  Top #5自动完成：Ctrl+Shift+Enter </p><p>Ø  Top #4创造万物：Alt+Insert </p><p><strong>太难割舍，前三名并列吧！</strong></p><p>Ø  Top #1智能补全：Ctrl+Shift+Space </p><p>Ø  Top #1自我修复：Alt+Enter </p><p>Ø  Top #1重构一切：Ctrl+Shift+Alt+T </p><p>CTRL+ALT+ left/right 前后导航编辑过的地方<br>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方</p>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring_Ioc</title>
      <link href="/2018/10/18/Spring-Ioc/"/>
      <url>/2018/10/18/Spring-Ioc/</url>
      
        <content type="html"><![CDATA[<h3 id="广义的Ioc"><a href="#广义的Ioc" class="headerlink" title="广义的Ioc"></a>广义的Ioc</h3><p>面试被问烂的 Spring IOC(求求你别再问了)  </p><p>1）IoC(Inversion of Control) 控制反转，即“不用打电话过来，我们会打给你”。</p><p>两种实现： 依赖查找（DL）和 依赖注入（DI）。</p><p>IoC 和 DI 、DL 的关系（这个 DL，Avalon 和 EJB 就是使用的这种方式实现的 IoC）：</p><p><img src="/images/20181018125125.png"></p><p>2) DL 已经被抛弃，因为他需要用户自己去是使用 API 进行查找资源和组装对象。即有侵入性。  </p><p>3) DI 是 Spring 使用的方式，容器负责组件的装配。</p><p><strong>注意：</strong><br>Java 使用 DI 方式实现 IoC 的不止 Spring，包括 Google 的 Guice，还有一个冷门的 PicoContainer（极度轻量，但只提供 IoC）。</p><h3 id="Spring的IoC"><a href="#Spring的IoC" class="headerlink" title="Spring的IoC"></a>Spring的IoC</h3><ol><li>依赖注入</li><li>依赖检查</li><li>自动装配</li><li>支持集合</li><li>指定初始化方法和销毁方法</li><li>支持回调某些方法(但是需要实现Spring接口，略有侵入)</li></ol><p>其中，最重要的就是依赖注入，从 XML 的配置上说， 即 ref 标签。对应 Spring RuntimeBeanReference 对象。</p><p><strong>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</strong>  </p><p>那么， Spring 如何设计容器的呢？  </p><p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。  </p><ol><li>BeanFactory</li><li>ApplicationContext</li></ol><p>BeanFactory 粗暴简单，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。</p><p>ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。</p><p>例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。  </p><p>该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p><p>当然，除了这两个大接口，还有其他的辅助接口，但我今天不会花太多篇幅介绍他们。</p><p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，我这里通过常用的 ClassPathXmlApplicationContext 类，来展示整个容器的层级 UML 关系。</p><p><img src="/images/20181018130402.png"></p><p>有点复杂？ 先不要慌，我来解释一下。</p><p>最上面的 BeanFactory 知道吧？我就不讲了。</p><p>下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p><p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p><p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p><p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置。生命周期事件回调等。</p><font color="#00ffff" size="4">好，解释了低级容器和高级容器，我们可以看看一个 IoC 启动过程是什么样子的。说白了，就是 ClassPathXmlApplicationContext 这个类，在启动时，都做了啥。</font><p>下图是 ClassPathXmlApplicationContext 的构造过程，实际就是 Spring IoC 的初始化过程。<br><img src="/images/20181018131026.png"></p><p>注意，这里为了理解方便，有所简化。</p><p>这里再用文字来描述这个过程：</p><ol><li>用户构造 ClassPathXmlApplicationContext（简称 CPAC）</li><li>CPAC 首先访问了 “抽象高级容器” 的 final 的 refresh 方法，这个方法是模板方法。所以要回调子类（低级容器）的 refreshBeanFactory 方法，这个方法的作用是使用低级容器加载所有 BeanDefinition 和 Properties 到容器中。</li><li>低级容器加载成功后，高级容器开始处理一些回调，例如 Bean 后置处理器。回调 setBeanFactory 方法。或者注册监听器等，发布事件，实例化单例 Bean 等等功能，这些功能，随着 Spring 的不断升级，功能越来越多，很多人在这里迷失了方向）。</li></ol><p>简单说就是：</p><ol><li>低级容器 加载配置文件（从 XML，数据库，Applet），并解析成 BeanDefinition 到低级容器中。</li><li>加载成功后，高级容器启动高级功能，例如接口回调，监听器，自动实例化单例，发布事件等等功能。</li></ol><p><strong>所以，一定要把 “低级容器” 和“高级容器” 的区别弄清楚。不能一叶障目不见泰山。</strong></p><p>好，当我们创建好容器，就会使用 getBean 方法，获取 Bean，而 getBean 的流程如下：<br><img src="/images/20181018131432.png" heigth="50%"></p><p>从图可以看出，getBean 的操作都是在低级容器里操作的。其中有个递归操作，这个是什么意思呢？</p><font color="#00ffff" size="4"><br>假设：当 Bean_A 依赖着 Bean_B，而这个 Bean_A 在加载的时候，其配置的 ref = “Bean_B” 在解析的时候只是一个占位符，被放入了 Bean_A 的属性集合中，当调用 getBean 时，需要真正 Bean_B 注入到 Bean_A 内部时，就需要从容器中获取这个 Bean_B，因此产生了递归。<br></font><p>为什么不是在加载的时候，就直接注入呢？因为加载的顺序不同，很可能 Bean_A 依赖的 Bean_B 还没有加载好，也就无法从容器中获取，你不能要求用户把 Bean 的加载顺序排列好，这是不人道的。</p><p>所以，Spring 将其分为了 2 个步骤：</p><ol><li><p>加载所有的 Bean 配置成 BeanDefinition 到容器中，如果 Bean 有依赖关系，则使用占位符暂时代替。</p></li><li><p>然后，在调用 getBean 的时候，进行真正的依赖注入，即如果碰到了属性是 ref 的（占位符），那么就从容器里获取这个 Bean，然后注入到实例中 —— 称之为依赖注入。<br>可以看到，依赖注入实际上，只需要 “低级容器” 就可以实现。  </p></li></ol><p>这就是 IoC。</p><p>所以 ApplicationContext refresh 方法里面的操作不只是 IoC，是高级容器的所有功能（包括 IoC），IoC 的功能在低级容器里就可以实现。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p><ol><li><p>加载配置文件，解析成 BeanDefinition 放在 Map 里。</p></li><li><p>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</p></li></ol><p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p><p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p><p>可以预见，随着 Spring 的不断发展，高级容器的功能会越来越多。</p><font color="#00ffff" size="4"><br>诚然，了解 IoC 的过程，实际上为了了解 Spring 初始化时，各个接口的回调时机。例如 InitializingBean，BeanFactoryAware，ApplicationListener 等等接口，这些接口的作用，笔者之前写过一篇文章进行介绍，有兴趣可以看一下，关键字：Spring 必知必会 扩展接口。<br></font><p>但是请注意，实现 Spring 接口代表着你这个应用就绑定死 Spring 了！代表 Spring 具有侵入性！要知道，Spring 发布时，无侵入性就是他最大的宣传点之一 —— 即 IoC 容器可以随便更换，代码无需变动。而现如今，Spring 已然成为 J2EE 社区准官方解决方案，也没有了所谓的侵入性这个说法。因为他就是标准，和 Servlet 一样，你能不实现 Servlet 的接口吗？: -)</p><p>好了，下次如果再有面试官问 Spring IoC 初始化过程，就再也不会含糊其词、支支吾吾了！！！</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_11</title>
      <link href="/2018/10/17/spring-annotation-day-11/"/>
      <url>/2018/10/17/spring-annotation-day-11/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><h3 id="Profile注解"><a href="#Profile注解" class="headerlink" title="@Profile注解"></a>@Profile注解</h3><p>Profile：Spring为我们提供的可以根据当前环境，动态的激活和切换一系列组件的功能。</p><p>比如：开发环境、测试环境、生产环境；</p><p>根据不同是环境，我们自动切换我们的数据源。</p><p>1）添加c3p0的数据源和mysql的驱动依赖：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt;<br> &lt;dependency&gt;<br>     &lt;groupId&gt;com.mchange&lt;/groupId&gt;<br>     &lt;artifactId&gt;c3p0&lt;/artifactId&gt;<br>     &lt;version&gt;0.9.5.2&lt;/version&gt;<br> &lt;/dependency&gt;<br> &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;<br> &lt;dependency&gt;<br>     &lt;groupId&gt;mysql&lt;/groupId&gt;<br>     &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br>     &lt;version&gt;8.0.12&lt;/version&gt;<br> &lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>2) 创建数据源的配置dbconfig.properties：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">db.user=root<br>db.password=123456<br>db.driverClass=com.mysql.jdbc.Driver<br></code></pre></td></tr></table></figure></p><p>3) 创建新的配置类MainConfigOfProfile：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@PropertySource(value = &quot;classpath:/dbconfig.properties&quot;)<br>public class MainConfigOfProfile implements EmbeddedValueResolverAware &#123;<br><br>    @Value(&quot;$&#123;db.user&#125;&quot;)<br>    private String user;<br><br>    private StringValueResolver valueResolver;<br>    private String driverClass;<br><br>    @Override<br>    public void setEmbeddedValueResolver(StringValueResolver resolver) &#123;<br>        this.valueResolver = resolver;<br>        String driverClass = valueResolver.resolveStringValue(&quot;$&#123;db.driverClass&#125;&quot;);<br>        this.driverClass = driverClass;<br>    &#125;<br><br><br>    @Bean(&quot;testDataSource&quot;)<br>    public DataSource dataSourceTest(@Value(&quot;$&#123;db.password&#125;&quot;) String pwd) throws PropertyVetoException &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(user);<br>        dataSource.setPassword(pwd);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);<br>        dataSource.setDriverClass(driverClass);<br>        return dataSource;<br>    &#125;<br><br>    @Bean(&quot;devDataSource&quot;)<br>    public DataSource dataSourceDev() throws PropertyVetoException &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(user);<br>        dataSource.setPassword(&quot;123456&quot;);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/school&quot;);<br>        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);<br>        return dataSource;<br>    &#125;<br><br>    @Bean(&quot;proDataSource&quot;)<br>    public DataSource dataSourcePro() throws PropertyVetoException &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(&quot;root&quot;);<br>        dataSource.setPassword(&quot;123456&quot;);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/sell&quot;);<br>        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);<br>        return dataSource;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>上述，有三个不同环境的数据源，test，dev，pro数据源，使用了不同的方式来给数据源进行赋值。</p><p>4）创建新的测试类IoCTest_Profile:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IoCTest_Profile &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfProfile.class);<br>        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();<br>        for (String name : beanDefinitionNames) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5) 运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfigOfProfile<br>testDataSource<br>devDataSource<br>proDataSource<br></code></pre></td></tr></table></figure></p><p>说明数据源都已经注入到容器中了。</p><hr><p>现在我们需要根据不同的环境，来指定加载需要的配置。</p><p>1)使用@Profile注解，是个属性、类加上一个标记的，标记这个属性或者类是属于这个环境的，只有激活了这个环境，才能被注册到容器中，默认激活default的环境，即@Profile(“default”）.</p><p>2)写在配置类上的@Profile，只能在该环境激活的情况下，整个配置类才能起作用，不管配置类里面的Bean是否是符合当前环境。</p><p>3）没有标记环境的bean，在任何环境下都是加载的</p><p><strong>验证：</strong></p><p>1) 在配置类MainConfigOfProfile中，给三个数据源加上标记：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@PropertySource(value = &quot;classpath:/dbconfig.properties&quot;)<br>public class MainConfigOfProfile implements EmbeddedValueResolverAware &#123;<br><br>    @Value(&quot;$&#123;db.user&#125;&quot;)<br>    private String user;<br><br>    private StringValueResolver valueResolver;<br>    private String driverClass;<br><br>    @Override<br>    public void setEmbeddedValueResolver(StringValueResolver resolver) &#123;<br>        this.valueResolver = resolver;<br>        String driverClass = valueResolver.resolveStringValue(&quot;$&#123;db.driverClass&#125;&quot;);<br>        this.driverClass = driverClass;<br>    &#125;<br><br><br>    @Profile(&quot;test&quot;)<br>    @Bean(&quot;testDataSource&quot;)<br>    public DataSource dataSourceTest(@Value(&quot;$&#123;db.password&#125;&quot;) String pwd) throws PropertyVetoException &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(user);<br>        dataSource.setPassword(pwd);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);<br>        dataSource.setDriverClass(driverClass);<br>        return dataSource;<br>    &#125;<br><br>    @Profile(&quot;dev&quot;)<br>    @Bean(&quot;devDataSource&quot;)<br>    public DataSource dataSourceDev() throws PropertyVetoException &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(user);<br>        dataSource.setPassword(&quot;123456&quot;);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/school&quot;);<br>        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);<br>        return dataSource;<br>    &#125;<br><br>    @Profile(&quot;pro&quot;)<br>    @Bean(&quot;proDataSource&quot;)<br>    public DataSource dataSourcePro() throws PropertyVetoException &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(&quot;root&quot;);<br>        dataSource.setPassword(&quot;123456&quot;);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/sell&quot;);<br>        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);<br>        return dataSource;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 设置当前的环境：</p><p><strong>方法一：</strong>  </p><p> 配置虚拟机的运行参数。</p><p>-Dspring.profiles.active=test</p><p>运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfigOfProfile<br>testDataSource<br></code></pre></td></tr></table></figure></p><p>此时，容器中只有testDataSource数据源了。</p><hr><p>-Dspring.profiles.active=dev</p><p>运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfigOfProfile<br>devDataSource<br></code></pre></td></tr></table></figure></p><p>此时，容器中只有devDataSource数据源了。</p><p><strong>方法二：</strong>  </p><p>使用无参数的AnnotationConfigApplicationContext容器。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IoCTest_Profile &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        //1.无参数<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();<br>        //2.设置环境,这里激活了test和dev<br>        applicationContext.getEnvironment().setActiveProfiles(&quot;test&quot;,&quot;dev&quot;);<br>        //3.设置配置类<br>        applicationContext.register(MainConfigOfProfile.class);<br>        //4.刷新容器<br>        applicationContext.refresh();<br><br><br>        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();<br>        for (String name : beanDefinitionNames) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfigOfProfile<br>testDataSource<br>devDataSource<br></code></pre></td></tr></table></figure></p><p>这里，test和dev数据源被激活了。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_10</title>
      <link href="/2018/10/17/spring-annotation-day-10/"/>
      <url>/2018/10/17/spring-annotation-day-10/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>自定义组件想要使用Spring容器底层的一些组件(ApplicationContext,BeanFactory,xxx)  </p><p>自定义组件实现xxxAware，在创建对象的时候，会调用接口规定的方法注入相关组件，Aware会把Spring底层的一些组件注入到自定义的Bean中。</p><p>xxxAware:功能使用xxxAwareProcessor现实的，比如：ApplicationContextAware是用ApplicationContextAwareProcessor注入的。</p><h3 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h3><p>1）在com.liuzhuo.bean包，随便找个Bean来实验：</p><p>这里使用Red类来实验：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Red implements ApplicationContextAware &#123;<br><br>    private ApplicationContext applicationContext;<br><br>    @Override<br>    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;<br>        this.applicationContext = applicationContext;<br>        System.out.println(&quot;容器:&quot; + applicationContext.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2）将Red类注入到容器中，使用包扫描，修改MainConfigOfAutowired配置类：<br><strong>加入了com.liuzhuo.bean包的扫描</strong><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(value = &#123;&quot;com.liuzhuo.controller&quot;, &quot;com.liuzhuo.service&quot;, &quot;com.liuzhuo.dao&quot;,&quot;com.liuzhuo.bean&quot;&#125;)<br>public class MainConfigOfAutowired<br></code></pre></td></tr></table></figure></p><p>3) 运行测试类IocTest_Autowired：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocTest_Autowired &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAutowired.class);<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs undefined">org.springframework.context.event.internalEventListenerProcessor------postProcessBeforeInitialization<br>org.springframework.context.event.internalEventListenerProcessor------postProcessAfterInitialization<br>org.springframework.context.event.internalEventListenerFactory------postProcessBeforeInitialization<br>org.springframework.context.event.internalEventListenerFactory------postProcessAfterInitialization<br>mainConfigOfAutowired------postProcessBeforeInitialization<br>mainConfigOfAutowired------postProcessAfterInitialization<br>bookController------postProcessBeforeInitialization<br>bookController------postProcessAfterInitialization<br>bookDao2------postProcessBeforeInitialization<br>bookDao2------postProcessAfterInitialization<br>bookService------postProcessBeforeInitialization<br>bookService------postProcessAfterInitialization<br>bookDao------postProcessBeforeInitialization<br>bookDao------postProcessAfterInitialization<br>Cat constructer ···<br>cat------postProcessBeforeInitialization<br>Cat afterPropertiesSet ····<br>cat------postProcessAfterInitialization<br>Dog construct ····<br>dog------postProcessBeforeInitialization<br>Dog @PostConstruct ····<br>dog------postProcessAfterInitialization<br>容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:08:27 CST 2018]; root of context hierarchy<br>red------postProcessBeforeInitialization<br>red------postProcessAfterInitialization<br>Dog @PreDestroy ····<br>Cat destroy ····<br>十月 17, 2018 2:08:28 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:08:27 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>能观察到：</p><p><code>容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:08:27 CST 2018]; root of context hierarchy</code></p><p>说明在Red类中，注入了容器类。</p><p>5）验证是否是同一个容器，修改测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocTest_Autowired &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAutowired.class);<br>        System.out.println(applicationContext);<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>6) 运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs undefined">org.springframework.context.event.internalEventListenerProcessor------postProcessBeforeInitialization<br>org.springframework.context.event.internalEventListenerProcessor------postProcessAfterInitialization<br>org.springframework.context.event.internalEventListenerFactory------postProcessBeforeInitialization<br>org.springframework.context.event.internalEventListenerFactory------postProcessAfterInitialization<br>mainConfigOfAutowired------postProcessBeforeInitialization<br>mainConfigOfAutowired------postProcessAfterInitialization<br>bookController------postProcessBeforeInitialization<br>bookController------postProcessAfterInitialization<br>bookDao2------postProcessBeforeInitialization<br>bookDao2------postProcessAfterInitialization<br>bookService------postProcessBeforeInitialization<br>bookService------postProcessAfterInitialization<br>bookDao------postProcessBeforeInitialization<br>bookDao------postProcessAfterInitialization<br>Cat constructer ···<br>cat------postProcessBeforeInitialization<br>Cat afterPropertiesSet ····<br>cat------postProcessAfterInitialization<br>Dog construct ····<br>dog------postProcessBeforeInitialization<br>Dog @PostConstruct ····<br>dog------postProcessAfterInitialization<br>容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:14:10 CST 2018]; root of context hierarchy<br>red------postProcessBeforeInitialization<br>red------postProcessAfterInitialization<br>十月 17, 2018 2:14:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:14:10 CST 2018]; root of context hierarchy<br>org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:14:10 CST 2018]; root of context hierarchy<br>Dog @PreDestroy ····<br>Cat destroy ····<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>观察到：<br>容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: </p><p>org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf:</p><p>一样，都是@2f410acf，说明是一个容器。</p><hr><h3 id="BeanNameAware"><a href="#BeanNameAware" class="headerlink" title="BeanNameAware"></a>BeanNameAware</h3><p>给自定义组件，注入自己在容器的id名。</p><p>1）修改Red类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Red implements ApplicationContextAware,BeanNameAware &#123;<br><br>    private ApplicationContext applicationContext;<br><br>    @Override<br>    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;<br>        this.applicationContext = applicationContext;<br>        System.out.println(&quot;容器:&quot; + applicationContext.toString());<br>    &#125;<br><br>    @Override<br>    public void setBeanName(String name) &#123;<br>        System.out.println(&quot;自定义组件的id名字：&quot;+name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">自定义组件的id名字：red<br>容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:21:56 CST 2018]; root of context hierarchy<br>red------postProcessBeforeInitialization<br>red------postProcessAfterInitialization<br></code></pre></td></tr></table></figure></p><p><strong>总结：</strong></p><p>想让自定义组件使用Spring底层的组件，就实现xxxAware接口就行。</p><p>ApplicationContextAware<br>ApplicationEventPublisherAware<br>BeanClassLoaderAware<br>BeanFactoryAware<br>BeanNameAware<br>BootstrapContextAware<br>EmbeddedValueResolverAware<br>EnvironmentAware<br>ImportAware<br>LoadTimeWeaverAware<br>MessageSourceAware<br>NotificationPublisherAware<br>PortletConfigAware<br>PortletContextAware<br>ResourceLoaderAware<br>SchedulerContextAware<br>ServletConfigAware<br>ServletContextAware</p><hr><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>1）在Red类下的setApplicationContext方法上面打上断点</p><p>2) 运行测试方法：</p><p>发现ApplicationContextAware是由ApplicationContextAwareProcessor处理的：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException &#123;<br>AccessControlContext acc = null;<br><br>if (System.getSecurityManager() != null &amp;&amp;<br>(bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||<br>bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||<br>bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) &#123;<br>acc = this.applicationContext.getBeanFactory().getAccessControlContext();<br>&#125;<br><br>if (acc != null) &#123;<br>AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;<br>@Override<br>public Object run() &#123;<br>invokeAwareInterfaces(bean);<br>return null;<br>&#125;<br>&#125;, acc);<br>&#125;<br>else &#123;<br>invokeAwareInterfaces(bean);<br>&#125;<br><br>return bean;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>内部执行postProcessBeforeInitialization方法来判断自定义的组件是否实现类xxxAware接口。</p><p>最后调用invokeAwareInterfaces(bean)方法</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">private void invokeAwareInterfaces(Object bean) &#123;<br>if (bean instanceof Aware) &#123;<br>if (bean instanceof EnvironmentAware) &#123;<br>((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());<br>&#125;<br>if (bean instanceof EmbeddedValueResolverAware) &#123;<br>((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);<br>&#125;<br>if (bean instanceof ResourceLoaderAware) &#123;<br>((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);<br>&#125;<br>if (bean instanceof ApplicationEventPublisherAware) &#123;<br>((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);<br>&#125;<br>if (bean instanceof MessageSourceAware) &#123;<br>((MessageSourceAware) bean).setMessageSource(this.applicationContext);<br>&#125;<br>if (bean instanceof ApplicationContextAware) &#123;<br>((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用相应的方法来实现注入。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_09</title>
      <link href="/2018/10/16/spring-annotation-day-09/"/>
      <url>/2018/10/16/spring-annotation-day-09/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>Spring的自动装配：  </p><p>Spring利用依赖注入(DI)，完成对IoC容器中各个组件的依赖关系赋值。</p><h3 id="Autowired注解"><a href="#Autowired注解" class="headerlink" title="@Autowired注解"></a>@Autowired注解</h3><p>1）在com.liuzhuo.config包下，创建新的类MainConfigOfAutowired：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并扫描三个包.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(value = &#123;&quot;com.liuzhuo.controller&quot;, &quot;com.liuzhuo.service&quot;, &quot;com.liuzhuo.dao&quot;&#125;)<br>public class MainConfigOfAutowired &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 修改BookService类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    @Autowired<br>    private BookDao bookDao;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 修改BookDao类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Repository<br>public class BookDao &#123;<br><br>    private Integer laber = 1;<br><br>    public BookDao() &#123;<br>    &#125;<br><br>    public BookDao(Integer laber) &#123;<br>        this.laber = laber;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookDao&#123;&quot; +<br>                &quot;laber=&quot; + laber +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 创建新的测试类IocTest_Autowired：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocTest_Autowired &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAutowired.class);<br>        BookService bookService = applicationContext.getBean(BookService.class);<br>        System.out.println(bookService);<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5) 运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:20:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:20:48 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=BookDao&#123;laber=1&#125;&#125;<br>十月 16, 2018 9:20:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:20:48 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>看到，BookService对象中的BookDao对象也注入进来了。</p><hr><p>当我们有多个相同类型的对象时，会注入哪个对象呢？</p><p>1）我们在配置文件MainConfigOfAutowired中添加先的BookDao对象：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(value = &#123;&quot;com.liuzhuo.controller&quot;, &quot;com.liuzhuo.service&quot;, &quot;com.liuzhuo.dao&quot;&#125;)<br>public class MainConfigOfAutowired &#123;<br><br>    @Bean<br>    public BookDao bookDao() &#123;<br>        return new BookDao(2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2）运行测试：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:27:35 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:27:35 CST 2018]; root of context hierarchy<br>十月 16, 2018 9:27:36 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>BookService&#123;bookDao=BookDao&#123;laber=1&#125;&#125;<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:27:35 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p><strong>结果不变，说明有多个相同类型时，注入到容器中的对象是与@AutoWired下面属性的名字相同的id的Bean对象。</strong></p><p>3）验证我们的结论，修改BookService类下的属性BookDao的属性名字：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    @Autowired<br>    private BookDao bookDao2;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao2 +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 运行测试：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:30:54 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:30:54 CST 2018]; root of context hierarchy<br>十月 16, 2018 9:30:54 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>BookService&#123;bookDao=BookDao&#123;laber=2&#125;&#125;<br><br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:30:54 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>验证正确，说明注入的Bean是与属性的名字相同的对象。</p><hr><p>除了，上述的方法来处理多个相同类型的对象。我们还可以使用 @Qualifier来指定注入容器中的Bean的id名。</p><p>1）修改BookService类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    @Qualifier(&quot;bookDao&quot;)<br>    @Autowired<br>    private BookDao bookDao2;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao2 +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 测试：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:34:12 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:34:12 CST 2018]; root of context hierarchy<br>十月 16, 2018 9:34:12 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:34:12 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=BookDao&#123;laber=1&#125;&#125;<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>此时注入容器中的BookDao对象就是@Qualifier(“bookDao”)注解的对象，而不是bookDao2了。</p><hr><p>默认情况下，@Autowired注解的属性，必须要在容器中已经注入了，否则会报错。</p><p>1）将刚刚的两个BookDao对象都注释掉。</p><p>2）运行测试：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:38:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:38:48 CST 2018]; root of context hierarchy<br>十月 16, 2018 9:38:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext refresh<br>警告: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;bookService&apos;: Unsatisfied dependency expressed through field &apos;bookDao2&apos;; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &apos;com.liuzhuo.dao.BookDao&apos; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125;<br><br>org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;bookService&apos;: Unsatisfied dependency expressed through field &apos;bookDao2&apos;; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &apos;com.liuzhuo.dao.BookDao&apos; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125;<br><br>at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:588)<br>at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:88)<br>at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:366)<br>at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1264)<br>at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553)<br>at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)<br>at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)<br>at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)<br>at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)<br>at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)<br>at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761)<br>at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:867)<br>at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:543)<br>at org.springframework.context.annotation.AnnotationConfigApplicationContext.&lt;init&gt;(AnnotationConfigApplicationContext.java:84)<br>at com.liuzhuo.test.IocTest_Autowired.test01(IocTest_Autowired.java:18)<br>at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>at java.lang.reflect.Method.invoke(Method.java:498)<br>at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)<br>at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)<br>at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)<br>at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)<br>at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)<br>at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)<br>at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)<br>at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)<br>at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)<br>at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)<br>at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)<br>at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)<br>at org.junit.runners.ParentRunner.run(ParentRunner.java:363)<br>at org.junit.runner.JUnitCore.run(JUnitCore.java:137)<br>at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)<br>at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)<br>at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)<br>at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)<br>Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &apos;com.liuzhuo.dao.BookDao&apos; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125;<br>at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoMatchingBeanFound(DefaultListableBeanFactory.java:1493)<br>at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1104)<br>at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1066)<br>at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:585)<br>... 36 more<br><br><br>Process finished with exit code -1<br></code></pre></td></tr></table></figure></p><p>我们也可以使@Autowired注解的属性，不是必须的。<br>因为@Autowired注解里面有一个属性 boolean required() default true;<br>将required设置为：false</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    //@Qualifier(&quot;bookDao&quot;)<br>    @Autowired(required = false)<br>    private BookDao bookDao2;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao2 +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:43:23 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:43:23 CST 2018]; root of context hierarchy<br>十月 16, 2018 9:43:24 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:43:23 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=null&#125;<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>此时不报错了。修改了默认情况下，必须给@Autowired注解的属性，注入到容器中。</p><hr><p>@primary注解：使用这个注解，就是当有多个类型的情况下，优先注入的bean对象：</p><p>1) 修改配置文件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(value = &#123;&quot;com.liuzhuo.controller&quot;, &quot;com.liuzhuo.service&quot;, &quot;com.liuzhuo.dao&quot;&#125;)<br>public class MainConfigOfAutowired &#123;<br><br>    @Primary<br>    @Bean(value = &quot;bookDao2&quot;)<br>    public BookDao bookDao() &#123;<br>        return new BookDao(2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 修改BookService：注释掉@Qualifier(“bookDao”)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    //@Qualifier(&quot;bookDao&quot;)<br>    @Autowired(required = false)<br>    private BookDao bookDao;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 运行测试：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:47:44 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:47:44 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=BookDao&#123;laber=2&#125;&#125;<br>十月 16, 2018 9:47:44 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:47:44 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>此时，输出的是laber=2的BookDao对象了，不再根据@Autowired注解下的属性名来注入到容器中了。</p><p>4）将BookService中的@Qualifier(“bookDao”)的注释去掉：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    @Qualifier(&quot;bookDao&quot;)<br>    @Autowired(required = false)<br>    private BookDao bookDao;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5) 运行测试：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:51:00 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:51:00 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=BookDao&#123;laber=1&#125;&#125;<br>十月 16, 2018 9:51:00 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:51:00 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p><strong>说明：当@Primary和@Qualifier同时存在时，是以@Qualifier为标准的！</strong></p><hr><h3 id="Resource注解"><a href="#Resource注解" class="headerlink" title="@Resource注解"></a>@Resource注解</h3><p>1）修改BookService类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    //@Qualifier(&quot;bookDao&quot;)<br>    //@Autowired(required = false)<br>    @Resource<br>    private BookDao bookDao;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 10:09:41 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:09:41 CST 2018]; root of context hierarchy<br>十月 16, 2018 10:09:41 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:09:41 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=BookDao&#123;laber=1&#125;&#125;<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>此时，输出的是laber=1的bookService对象，说明@primary注解没有起作用。<br>@Resource注解，默认是注入属性的名。也可以通过@Resource的name属性来修改需要注入到容器中的Bean对象。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    //@Qualifier(&quot;bookDao&quot;)<br>    //@Autowired(required = false)<br>    @Resource(name = &quot;bookDao2&quot;)<br>    private BookDao bookDao;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 10:13:02 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:13:02 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=BookDao&#123;laber=2&#125;&#125;<br>十月 16, 2018 10:13:02 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:13:02 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><hr><h3 id="Inject注解"><a href="#Inject注解" class="headerlink" title="@Inject注解"></a>@Inject注解</h3><p>@Inject注解：需要导入javax.inject包。</p><p>1）在pom文件中添加依赖：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependency&gt;<br>    &lt;groupId&gt;javax.inject&lt;/groupId&gt;<br>    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;<br>    &lt;version&gt;1&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>2) 修改BookService类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    //@Qualifier(&quot;bookDao&quot;)<br>    //@Autowired(required = false)<br>    //@Resource(name = &quot;bookDao2&quot;)<br>    @Inject<br>    private BookDao bookDao;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 10:16:52 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:16:52 CST 2018]; root of context hierarchy<br>十月 16, 2018 10:16:52 下午 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &lt;init&gt;<br>信息: JSR-330 &apos;javax.inject.Inject&apos; annotation found and supported for autowiring<br>BookService&#123;bookDao=BookDao&#123;laber=2&#125;&#125;<br>十月 16, 2018 10:16:52 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:16:52 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>输出的是laber=2的BookService对象，说明支持@primary注解。</p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1）@Autowired：自动注入<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1）、默认优先按照类型去容器中找对应的组件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2）、如果找到多个相同类型的组件，再将属性的名称作为组件的id去容器中查找<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.3）、@Qualifier：使用@Qualifier指定需要装配的组件的id，而不使用属性名<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.4）、自动装配默认是一定将属性赋值好，没有就报错。可以使用@Autowired(required=false)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.5）、@Primary:当存在多个同类型的Bean时，优先装配的Bean，优先级没有@Qualifier高。  </p><p>2）Spring还支持使用@Resource(JSR250)和@Inject(JSR330)[java规范的注解]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Resource：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以和@Autowired一样实现自动装配功能，默认是按照组件名称进行装配的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不支持@primary功能和@Autowired(required=false)功能，但是有@Resource(name = “bookDao2”)修改注入容器Bean的id的功能。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Inject：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要导入javax.inject包，和@Autowired的功能一样，但是没有required=false的功能。</p><p>3）@Autowired是Spring定义的，只能在有Spring的环境时才有作用，@Resource和@Inject注解是java规范，只有是满足java规范的都可以使用，意思就是跨框架性更好。</p><p>4）上述自动注入都是通过AutowiredAnnotationBeanPostProcessor这个后置处理器完成。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_08</title>
      <link href="/2018/10/16/spring-annotation-day-08/"/>
      <url>/2018/10/16/spring-annotation-day-08/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><h3 id="Value注解"><a href="#Value注解" class="headerlink" title="@Value注解"></a>@Value注解</h3><p>使用@Value注解来注入值</p><p>1）在com.liuzhuo.config包下，创建新的配置类MainConfigOfProperty：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class MainConfigOfProperty &#123;<br><br>    @Bean<br>    public Person person() &#123;<br>        return new Person();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2）在com.liuzhuo.test包下，创建新的测试类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class PropertyTest &#123;<br><br>    private AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfProperty.class);<br><br>    @Test<br>    public void test01() &#123;<br>        printBeanName(applicationContext);<br>        Person person = (Person) applicationContext.getBean(&quot;person&quot;);<br>        System.out.println(person);<br>        applicationContext.close();<br>    &#125;<br><br>    private void printBeanName(AnnotationConfigApplicationContext applicationContext) &#123;<br>        String[] names = applicationContext.getBeanDefinitionNames();<br>        for (String name : names) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 运行测试方法：test01<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">org.springframework.context.annotation.internalConfigurationAnnotationProcessor<br>org.springframework.context.annotation.internalAutowiredAnnotationProcessor<br>org.springframework.context.annotation.internalRequiredAnnotationProcessor<br>org.springframework.context.annotation.internalCommonAnnotationProcessor<br>org.springframework.context.event.internalEventListenerProcessor<br>org.springframework.context.event.internalEventListenerFactory<br>mainConfigOfProperty<br>person<br>Person&#123;name=&apos;null&apos;, age=null&#125;<br>十月 16, 2018 5:34:32 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2ff5659e: startup date [Tue Oct 16 17:34:31 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>我们能看到，打印出来的Person对象的属性都是null。</p><p>4）修改Person类<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Person &#123;<br><br>    /*<br>    * value:<br>    *     1.使用直接值，比如字符串，数值等<br>    *     2.使用SpEL表达式，#&#123;&#125;<br>    *     3.使用$&#123;&#125;,获取资源文件中的数据<br>    * */<br>    @Value(&quot;张三&quot;)<br>    private String name;<br>    @Value(&quot;#&#123;20-2&#125;&quot;)<br>    private Integer age;<br>    <br>    ·····<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5）再次运行test01：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">org.springframework.context.annotation.internalConfigurationAnnotationProcessor<br>org.springframework.context.annotation.internalAutowiredAnnotationProcessor<br>org.springframework.context.annotation.internalRequiredAnnotationProcessor<br>org.springframework.context.annotation.internalCommonAnnotationProcessor<br>org.springframework.context.event.internalEventListenerProcessor<br>org.springframework.context.event.internalEventListenerFactory<br>mainConfigOfProperty<br>person<br>Person&#123;name=&apos;张三&apos;, age=18&#125;<br>十月 16, 2018 5:37:41 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2ff5659e: startup date [Tue Oct 16 17:37:41 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><hr><h3 id="PropertySource注解"><a href="#PropertySource注解" class="headerlink" title="@PropertySource注解"></a>@PropertySource注解</h3><p>使用@PropertySource注解来获取资源配置文件中的数据。</p><p>1）在resource包下，创建person.properties文件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">person.nickName=小张三<br></code></pre></td></tr></table></figure></p><p>2) 修改Person类：<br>添加nickName属性和对应的get、set方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Person &#123;<br><br>    /*<br>     * value:<br>     *     1.使用直接值，比如字符串，数值等<br>     *     2.使用SpEL表达式，#&#123;&#125;<br>     *     3.使用$&#123;&#125;,获取资源文件中的数据<br>     * */<br>    @Value(&quot;张三&quot;)<br>    private String name;<br>    @Value(&quot;#&#123;20-2&#125;&quot;)<br>    private Integer age;<br>    @Value(&quot;$&#123;person.nickName&#125;&quot;)<br>    private String nickName;<br>    <br>    ·····<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3）在配置文件中，加入资源文件的扫描：<br>&nbsp;&nbsp;&nbsp;@PropertySource(value = “classpath:person.properties”)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@PropertySource(value = &quot;classpath:person.properties&quot;)<br>public class MainConfigOfProperty<br></code></pre></td></tr></table></figure></p><p>这里的@PropertySource(value = “classpath:person.properties”)，相当于以前在xml中的配置的<br>&lt;context:property-placeholder location=”person.properties”/&gt;，如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>       xsi:schemaLocation=&quot;<br>        http://www.springframework.org/schema/beans<br>        http://www.springframework.org/schema/beans/spring-beans.xsd<br>        http://www.springframework.org/schema/context<br>        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;<br><br>    &lt;!--包扫描、只要标注了@Controller、@Service、@Repository、@Component都会自动注入到容器中--&gt;<br>    &lt;!--&lt;context:component-scan base-package=&quot;com.liuzhuo&quot;/&gt;--&gt;<br><br>    &lt;!--扫描资源文件--&gt;<br>    &lt;context:property-placeholder location=&quot;person.properties&quot;/&gt;<br><br>    &lt;!--以前的开发模式，使用配置文件--&gt;<br>    &lt;bean id=&quot;person&quot; class=&quot;com.liuzhuo.bean.Person&quot; init-method=&quot;&quot; destroy-method=&quot;&quot;&gt;<br>        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;<br>        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;<br>    &lt;/bean&gt;<br><br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure></p><p>4) 运行test01：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfigOfProperty<br>person<br>Person&#123;name=&apos;张三&apos;, age=18, nickName=&apos;小张三&apos;&#125;<br></code></pre></td></tr></table></figure></p><p>这里的昵称，小张三也打印出来了。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_07</title>
      <link href="/2018/10/16/spring-annotation-day-07/"/>
      <url>/2018/10/16/spring-annotation-day-07/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><h3 id="BeanPostProcessor的生命周期流程"><a href="#BeanPostProcessor的生命周期流程" class="headerlink" title="BeanPostProcessor的生命周期流程"></a>BeanPostProcessor的生命周期流程</h3><p>我们知道BeanPostProcessor是后置处理器，是在Bean初始化前后执行一些列操作的，底层到底是怎么执行的呢？现在debug一下。</p><p>1）设置断点，在com.liuzhuo.bean包下的MyBeanPostProcessor类中，给postProcessBeforeInitialization方法设置断点。</p><p><img src="/images/20181016100600.png"></p><p>2) debug一下。发现调用栈如下：</p><p><img src="/images/20181016101036.png" style="width:50%"></p><p>程序是从test01开始：</p><p>1）创建AnnotationConfigApplicationContext对象  </p><p>2）执行AnnotationConfigApplicationContext的构造方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) &#123;<br>this();<br>register(annotatedClasses);<br>refresh();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 调用refresh()方法：完成一系列资源配置操作。最后调用finishBeanFactoryInitialization()方法，初始化容器。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public void refresh() throws BeansException, IllegalStateException &#123;<br>synchronized (this.startupShutdownMonitor) &#123;<br>// Prepare this context for refreshing.<br>prepareRefresh();<br><br>// Tell the subclass to refresh the internal bean factory.<br>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<br><br>// Prepare the bean factory for use in this context.<br>prepareBeanFactory(beanFactory);<br><br>try &#123;<br>// Allows post-processing of the bean factory in context subclasses.<br>postProcessBeanFactory(beanFactory);<br><br>// Invoke factory processors registered as beans in the context.<br>invokeBeanFactoryPostProcessors(beanFactory);<br><br>// Register bean processors that intercept bean creation.<br>registerBeanPostProcessors(beanFactory);<br><br>// Initialize message source for this context.<br>initMessageSource();<br><br>// Initialize event multicaster for this context.<br>initApplicationEventMulticaster();<br><br>// Initialize other special beans in specific context subclasses.<br>onRefresh();<br><br>// Check for listener beans and register them.<br>registerListeners();<br><br>// Instantiate all remaining (non-lazy-init) singletons.<br>finishBeanFactoryInitialization(beanFactory);<br><br>// Last step: publish corresponding event.<br>finishRefresh();<br>&#125;<br><br>catch (BeansException ex) &#123;<br>if (logger.isWarnEnabled()) &#123;<br>logger.warn(&quot;Exception encountered during context initialization - &quot; +<br>&quot;cancelling refresh attempt: &quot; + ex);<br>&#125;<br><br>// Destroy already created singletons to avoid dangling resources.<br>destroyBeans();<br><br>// Reset &apos;active&apos; flag.<br>cancelRefresh(ex);<br><br>// Propagate exception to caller.<br>throw ex;<br>&#125;<br><br>finally &#123;<br>// Reset common introspection caches in Spring&apos;s core, since we<br>// might not ever need metadata for singleton beans anymore...<br>resetCommonCaches();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4）进入finishBeanFactoryInitialization：<br>调用<br><code>beanFactory.preInstantiateSingletons();</code></p><p>5) 最终调用doCreateBean()方法：<br>我们主要看其中的：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">      // Initialize the bean instance.<br>Object exposedObject = bean;<br>try &#123;<br>populateBean(beanName, mbd, instanceWrapper);<br>if (exposedObject != null) &#123;<br>exposedObject = initializeBean(beanName, exposedObject, mbd);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>populateBean:给Bean的属性赋值等操作<br>initializeBean:Bean初始化操作。</p><p>6）点击initializeBean方法:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Object wrappedBean = bean;<br>if (mbd == null || !mbd.isSynthetic()) &#123;<br>wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>&#125;<br><br>try &#123;<br>invokeInitMethods(beanName, wrappedBean, mbd);<br>&#125;<br>catch (Throwable ex) &#123;<br>throw new BeanCreationException(<br>(mbd != null ? mbd.getResourceDescription() : null),<br>beanName, &quot;Invocation of init method failed&quot;, ex);<br>&#125;<br><br>if (mbd == null || !mbd.isSynthetic()) &#123;<br>wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>&#125;<br>return wrappedBean;<br></code></pre></td></tr></table></figure></p><p>其中：<br>applyBeanPostProcessorsBeforeInitialization：完成初始化之前的操作。</p><p>invokeInitMethods：初始化是操作(@PostConstruc、init-method等)</p><p>applyBeanPostProcessorsAfterInitialization：完成初始化之后的操作。</p><p>7）点击applyBeanPostProcessorsBeforeInitialization：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)<br>throws BeansException &#123;<br><br>Object result = existingBean;<br>for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;<br>result = beanProcessor.postProcessBeforeInitialization(result, beanName);<br>if (result == null) &#123;<br>return result;<br>&#125;<br>&#125;<br>return result;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>发现：就是使用for循环来调用一系列BeanPostProcessor接口的实现类，包括Spring容器自身的和我们自定义的实现类。</p><p><strong>注意:如果其中的某一个BeanPostProcessor实现类返回了null，那么后面的BeanPostProcessor实现类就不执行了！！！</strong></p><p>大概的流程就走完了~~~</p><hr><h3 id="Spring底层对BeanPostProcessor的使用"><a href="#Spring底层对BeanPostProcessor的使用" class="headerlink" title="Spring底层对BeanPostProcessor的使用"></a>Spring底层对BeanPostProcessor的使用</h3><p>ps：在idea中：类名查找类:Ctrl+Shift+Alt+N; </p><p><img src="/images/20181016104349.png"></p><p>1) 找到BeanPostProcessor接口：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public interface BeanPostProcessor &#123;<br><br><br>Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;<br><br><br>Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 在BeanPostProcessor上Ctrl+T：找到所有的实现类：</p><p><img src="/images/20181016105219.png"></p><p>我们能看到各种BeanPostProcessor的实现类</p><p>3）ApplicationContextAwareProcessor</p><p>我们使用一下ApplicationContextAwareProcessor这个处理器。这个处理器是给我们的自定义Bean注入容器的。</p><p>4）在com.liuzhuo.bean包下，随便找个一个Bean，并实现ApplicationContextAware接口：<br>ps:这里使用的Dog类<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Dog implements ApplicationContextAware<br></code></pre></td></tr></table></figure></p><p>5）需要实现：setApplicationContext方法<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;<br>    this.applicationContext = applicationContext;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这样我们就将容器注入到Dog类中。</p><hr><p>还有：<br>InitDestroyAnnotationBeanPostProcessor处理我们的@PostConstruct、@PreDestory注解。<br>AutowiredAnnotationBeanPostProcessor处理我们的@Autowired注解等。</p><p><strong>总结：<br>&nbsp;&nbsp;&nbsp;&nbsp;Spring对底层BeanPostProcessor的使用：bean的赋值、注入其他组件、@Autowired、生命周期注解功能、@Async、xxxBeanPostProcessor等等。</strong></p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_06</title>
      <link href="/2018/10/15/spring-annotation-day-06/"/>
      <url>/2018/10/15/spring-annotation-day-06/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p>在Spring中Bean的生命周期：<br>Bean的创建—-初始化—–调用—–销毁。</p><p>构造(对象的创建)：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单实例：在容器启动的时候创建对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多实例：在每次获取的时候创建对象 </p><p>初始化：<br>对象创建完成，并赋值好，调用初始化方法</p><p>销毁：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单实例：容器关闭的时候<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多实例：容器不会管理这个Bean，容器不会调用销毁方法</p><p>以前，我们定义初始化和销毁方法是在xml文件中配置的：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!--以前的开发模式，使用配置文件--&gt;<br>    &lt;bean id=&quot;person&quot; class=&quot;com.liuzhuo.bean.Person&quot; init-method=&quot;&quot; destroy-method=&quot;&quot;&gt;<br>        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;<br>        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;<br>    &lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>init-method=””    : 定义初始化方法<br>destroy-method=”” : 定义销毁方法  </p><hr><p>现在，我们可以使用其他方式来完成生命周期。</p><h4 id="通过-Bean指定init-method和destroy-method"><a href="#通过-Bean指定init-method和destroy-method" class="headerlink" title="通过@Bean指定init-method和destroy-method"></a>通过@Bean指定init-method和destroy-method</h4><p>1）在com.liuzhuo.config包下，创建MainConfigOfLife配置类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class MainConfigOfLife &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 在com.liuzhuo.bean包下，创建Car类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Car &#123;<br><br>    public Car() &#123;<br>        System.out.println(&quot;Car construct ····&quot;);<br>    &#125;<br><br>    //定义初始化方法<br>    public void init()&#123;<br>        System.out.println(&quot;Car init ·····&quot;);<br>    &#125;<br><br>    //定义销毁方法<br>    public void destory()&#123;<br>        System.out.println(&quot;Car destory ·····&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 将Car注册到容器中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class MainConfigOfLife &#123;<br><br>    @Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;destory&quot;)<br>    public Car car() &#123;<br>        return new Car();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 在com.liuzhuo.test包下，创建新的测试类(IocOfLifeTest):<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocOfLifeTest &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext =<br>                new AnnotationConfigApplicationContext(MainConfigOfLife.class);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5)运行测试test01方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Car construct ····<br>Car init ·····<br></code></pre></td></tr></table></figure></p><p>说明：单例模式下，容器启动就会将Bean对象注入到容器中，并执行了初始化方法。</p><p>想要调用销毁方法，关闭容器就好。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocOfLifeTest &#123;<br><br>    @Test<br>    public void test01() &#123;<br><br>        //启动容器<br>        AnnotationConfigApplicationContext applicationContext =<br>                new AnnotationConfigApplicationContext(MainConfigOfLife.class);<br>        //关闭容器<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">D:\Java1.8\bin\java<br>十月 15, 2018 9:08:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:08:11 CST 2018]; root of context hierarchy<br>Car construct ····<br>Car init ·····<br>十月 15, 2018 9:08:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:08:11 CST 2018]; root of context hierarchy<br>Car destory ·····<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><hr><h4 id="InitializingBean和DisposableBean"><a href="#InitializingBean和DisposableBean" class="headerlink" title="InitializingBean和DisposableBean"></a>InitializingBean和DisposableBean</h4><p>通过让Bean实现InitializingBean和DisposableBean两个接口来定义初始化和销毁。</p><p>1）在com.liuzhuo.bean包下，创建Cat类，并实现上述两个接口：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Cat implements InitializingBean, DisposableBean &#123;<br><br>    public Cat() &#123;<br>        System.out.println(&quot;Cat constructer ···&quot;);<br>    &#125;<br><br>    @Override<br>    public void destroy() throws Exception &#123;<br>        System.out.println(&quot;Cat destroy ····&quot;);<br>    &#125;<br><br>    @Override<br>    public void afterPropertiesSet() throws Exception &#123;<br>        System.out.println(&quot;Cat afterPropertiesSet ····&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 将Cat类注入到容器中，这里我使用了包扫描:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(value = &quot;com.liuzhuo&quot;)<br>public class MainConfigOfLife<br></code></pre></td></tr></table></figure></p><p>3) 运行测试方法test01:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocOfLifeTest &#123;<br><br>    @Test<br>    public void test01() &#123;<br><br>        //启动容器<br>        AnnotationConfigApplicationContext applicationContext =<br>                new AnnotationConfigApplicationContext(MainConfigOfLife.class);<br><br>        Object cat = applicationContext.getBean(&quot;cat&quot;);<br>        //关闭容器<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 15, 2018 9:21:42 下午 org.springframework.beans.factory.support.DefaultListableBeanFactory registerBeanDefinition<br>信息: Overriding bean definition for bean &apos;person&apos; with a different definition: replacing [Generic bean: class [com.liuzhuo.bean.Person]; scope=singleton; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [E:\ideaProject\springannotation\target\classes\com\liuzhuo\bean\Person.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=true; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=mainConfig2; factoryMethodName=person; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/liuzhuo/config/MainConfig2.class]]<br>Cat constructer ···<br>Cat afterPropertiesSet ····<br>Car construct ····<br>Car init ·····<br>十月 15, 2018 9:21:43 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:21:42 CST 2018]; root of context hierarchy<br>Car destory ·····<br>Cat destroy ····<br></code></pre></td></tr></table></figure></p><hr><h4 id="JSR250-PostConstruct和-PreDestory"><a href="#JSR250-PostConstruct和-PreDestory" class="headerlink" title="JSR250:@PostConstruct和@PreDestory"></a>JSR250:@PostConstruct和@PreDestory</h4><p>@PostConstruct: 在bean创建完成并且属性赋值完成，来执行初始化方法<br>@PreDestory：&nbsp;&nbsp;在容器销毁bean之前通知我们进行清理工作</p><p>1) 在com.liuzhuo.bean包下，创建Dog类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Dog &#123;<br><br>    public Dog() &#123;<br>        System.out.println(&quot;Dog construct ····&quot;);<br>    &#125;<br><br>    //在构造函数之后<br>    @PostConstruct<br>    public void init() &#123;<br>        System.out.println(&quot;Dog @PostConstruct ····&quot;);<br>    &#125;<br><br>    //在销毁之前<br>    @PreDestroy<br>    public void destory() &#123;<br>        System.out.println(&quot;Dog @PreDestroy ····&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 运行测试类test01:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocOfLifeTest &#123;<br><br>    @Test<br>    public void test01() &#123;<br><br>        //启动容器<br>        AnnotationConfigApplicationContext applicationContext =<br>                new AnnotationConfigApplicationContext(MainConfigOfLife.class);<br><br>        applicationContext.getBean(&quot;dog&quot;);<br>        <br>        //关闭容器<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 15, 2018 9:35:11 下午 org.springframework.beans.factory.support.DefaultListableBeanFactory registerBeanDefinition<br>信息: Overriding bean definition for bean &apos;person&apos; with a different definition: replacing [Generic bean: class [com.liuzhuo.bean.Person]; scope=singleton; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [E:\ideaProject\springannotation\target\classes\com\liuzhuo\bean\Person.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=true; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=mainConfig2; factoryMethodName=person; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/liuzhuo/config/MainConfig2.class]]<br>Cat constructer ···<br>Cat afterPropertiesSet ····<br>Dog construct ····<br>Dog @PostConstruct ····<br>Car construct ····<br>Car init ·····<br>十月 15, 2018 9:35:12 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:35:11 CST 2018]; root of context hierarchy<br>Car destory ·····<br>Dog @PreDestroy ····<br>Cat destroy ····<br></code></pre></td></tr></table></figure></p><hr><h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h4><p>BeanPostProcessor:bean后置处理器（意思是bean初始化前后执行）</p><p>postProcessBeforeInitialization：在初始化之前执行，这里是初始化指：上述的init-method、InitializingBean、@PostConstruct。</p><p>postProcessAfterInitialization：在初始化之后执行。</p><hr><p>1）在com.liuzhuo.bean包下，创建MyBeanPostProcessor并实现BeanPostProcessor接口<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class MyBeanPostProcessor implements BeanPostProcessor &#123;<br><br>    //初始化之前执行<br>    /**<br>     * @param bean     容器创建的Bean<br>     * @param beanName bean的id<br>     * @return<br>     * @throws BeansException<br>     */<br>    @Override<br>    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;<br><br>        System.out.println(beanName + &quot;------postProcessBeforeInitialization&quot;);<br>        //返回值是原始的Bean，或者是包装后的Bean<br>        return bean;<br>    &#125;<br><br>    //初始化之后执行<br>    @Override<br>    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;<br>        System.out.println(beanName + &quot;------postProcessAfterInitialization&quot;);<br>        return bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 运行测试方法test01：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocOfLifeTest &#123;<br><br>    @Test<br>    public void test01() &#123;<br><br>        //启动容器<br>        AnnotationConfigApplicationContext applicationContext =<br>                new AnnotationConfigApplicationContext(MainConfigOfLife.class);<br><br>        applicationContext.getBean(&quot;dog&quot;);<br><br>        //关闭容器<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfigOfLife------postProcessBeforeInitialization<br>mainConfigOfLife------postProcessAfterInitialization<br>Cat constructer ···<br>cat------postProcessBeforeInitialization<br>Cat afterPropertiesSet ····<br>cat------postProcessAfterInitialization<br>Dog construct ····<br>dog------postProcessBeforeInitialization<br>Dog @PostConstruct ····<br>dog------postProcessAfterInitialization<br>Car construct ····<br>car------postProcessBeforeInitialization<br>Car init ·····<br>car------postProcessAfterInitialization<br>Car destory ·····<br>Dog @PreDestroy ····<br>Cat destroy ····<br>十月 15, 2018 9:57:03 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:57:03 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>分析：<br>Cat constructer ···<br>cat——postProcessBeforeInitialization<br>Cat afterPropertiesSet ····<br>cat——postProcessAfterInitialization<br>Cat destroy ····  </p><p><strong>构造–初始化之前–初始化–初始化之后–销毁</strong></p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_05</title>
      <link href="/2018/10/15/spring-annotation-day-05/"/>
      <url>/2018/10/15/spring-annotation-day-05/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><h3 id="Import注解"><a href="#Import注解" class="headerlink" title="@Import注解"></a>@Import注解</h3><p>给容器中注册组件：<br>1）、包扫描+组件标记注解（@Controller、@Service、@Repository、@Component)[导入我们自己写的组件]<br>2）、@Bean[导入第三方包里面的组件]<br>3）、@Import[快速给容器中导入一个组件]  </p><hr><p>@Bean导入，只能一个一个的导入，不太方便，所以需要@Import注解。现在我们来看@Import的用法。</p><h4 id="一、-Import"><a href="#一、-Import" class="headerlink" title="一、@Import"></a>一、@Import</h4><p>@Import：容器中会自动注册这个组件，id默认是全类名  </p><p>1）在com.liuzhuo.bean包下，创建Color对象。<br>2）修改配置类MainConfig2类：(看@Import注解)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@Import(Color.class)<br>public class MainConfig2<br></code></pre></td></tr></table></figure></p><p>3）在test类中，创建新的测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void testImport() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>    printBeanName(applicationContext);<br>&#125;<br><br>private void printBeanName(AnnotationConfigApplicationContext applicationContext) &#123;<br>    String[] names = applicationContext.getBeanDefinitionNames();<br>    for (String name : names) &#123;<br>        System.out.println(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig2<br>com.liuzhuo.bean.Color<br>person<br>bier<br></code></pre></td></tr></table></figure></p><p>观察结果：发现Color组件已经注册到容器中了，而且id名是全类名。</p><hr><p>点击@Import。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Target(&#123;ElementType.TYPE&#125;)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>public @interface Import &#123;<br>    Class&lt;?&gt;[] value();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>发现，@Import中的value是一个Class类型的数组，说明可以注入多个Class类型  </p><p>1）现在，在com.liuzhuo.bean包下，再创建一个Red类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Red &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2）修改配置类MainConfig2：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@Import(&#123;Color.class, Red.class&#125;)<br>public class MainConfig2<br></code></pre></td></tr></table></figure></p><p>3) 运行测试方法testImport:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig2<br>com.liuzhuo.bean.Color<br>com.liuzhuo.bean.Red<br>person<br>bier<br></code></pre></td></tr></table></figure></p><p>结果：Red类也被注册到容器中了。</p><hr><h4 id="二、ImportSelect"><a href="#二、ImportSelect" class="headerlink" title="二、ImportSelect"></a>二、ImportSelect</h4><p>ImporSelect：返回要导入的全类名数组。</p><p>在@Import的value属性中，导入实现了ImportSelect接口的类，该实现类返回我们需要导入的组件的全类名即可。</p><p>1）在com.liuzhuo.condition包下，创建MyImportSelect类并实现ImportSelect接口：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyImportSelect implements ImportSelector &#123;<br><br>    /*<br>    * annotationMetadata:获取注解的信息。<br>    * 返回值：全类名的字符串数组<br>    * */<br>    @Override<br>    public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br><br>        //返回值不能是null，否则会出空指针异常<br>        return new String[0];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 在com.liuzhuo.bean包下，创建Bule、Yellow类。</p><p>3）修改selectImports方法是返回值：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyImportSelect implements ImportSelector &#123;<br><br>    /*<br>    * annotationMetadata:获取注解的信息。<br>    * 返回值：全类名的字符串数组<br>    * */<br>    @Override<br>    public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br><br>        //返回值不能是null，否则会出空指针异常<br>        return new String[]&#123;&quot;com.liuzhuo.bean.Blue&quot;,&quot;com.liuzhuo.bean.Yellow&quot;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 修改配置类MainConfig2:(添加类MyImportSelect类)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@Import(&#123;Color.class, Red.class, MyImportSelect.class&#125;)<br>public class MainConfig2<br></code></pre></td></tr></table></figure></p><p>5)运行测试方法testImport:</p><p>结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig2<br>com.liuzhuo.bean.Color<br>com.liuzhuo.bean.Red<br>com.liuzhuo.bean.Blue<br>com.liuzhuo.bean.Yellow<br>person<br>bier<br></code></pre></td></tr></table></figure></p><p>发现：Blue、Yellow也被注册到容器中了。</p><hr><h4 id="三、ImportBeanDefinitionRegistrar"><a href="#三、ImportBeanDefinitionRegistrar" class="headerlink" title="三、ImportBeanDefinitionRegistrar"></a>三、ImportBeanDefinitionRegistrar</h4><p>ImportBeanDefinitionRegistrar ：手动注册Bean。</p><p>使用的形式与ImportSelect类似。</p><p>1）在com.liuzhuo.condition包下，创建MyImportBeanDefinitionRegistrar类实现ImportBeanDefinitionRegistrar接口。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;<br>    /*<br>    *<br>    * importingClassMetadata:注解类的信息<br>    * registry：注册组件，使用register.registerBeanDefinition()方法，手动注册Bean。<br>    * */<br>    @Override<br>    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2)在com.liuzhuo.bean包下，创建RainBow类。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class RainBow &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 修改registerBeanDefinitions方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;<br><br>    /*<br>     * 这里，我们根据是否有Bule和Yellow组件来注册RainBow组件。<br>     * */<br><br>    //注意这里传入的是Bean的id。<br>    boolean b = registry.containsBeanDefinition(&quot;com.liuzhuo.bean.Blue&quot;);<br>    boolean y = registry.containsBeanDefinition(&quot;com.liuzhuo.bean.Yellow&quot;);<br>    if (b &amp;&amp; y) &#123;<br>        //两个参数：String beanName<br>        //         BeanDefinition beanDefinition<br>        // beanName：要注册的Bean的id<br>        //beanDefinition:Bean的定义。是一个接口，我们需要传入一个实现类。<br>        RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(RainBow.class);<br>        registry.registerBeanDefinition(&quot;rainBow&quot;, rootBeanDefinition);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 修改配置类MainConfig2：(MyImportBeanDefinitionRegistrar.class)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@Import(&#123;Color.class, Red.class, MyImportSelect.class, MyImportBeanDefinitionRegistrar.class&#125;)<br>public class MainConfig2<br></code></pre></td></tr></table></figure></p><p>5) 运行测试方法testImport:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig2<br>com.liuzhuo.bean.Color<br>com.liuzhuo.bean.Red<br>com.liuzhuo.bean.Blue<br>com.liuzhuo.bean.Yellow<br>person<br>bier<br>rainBow<br></code></pre></td></tr></table></figure></p><p>结果：发现rainBow已经被注册到容器中了。</p><hr><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>第四种方法给容器注册Bean.</p><p>使用Spring提供的FactoryBean（工厂Bean）<br> &nbsp;&nbsp;&nbsp;&nbsp;1）默认获取的是工厂bean调用getObject创建的对象<br> &nbsp;&nbsp;&nbsp;&nbsp;2）要想获取工厂Bean本身，需要给id前面加一个&amp;</p><hr><p>1) 在com.liuzhuo.bean包下，创建ColorFactoryBean类，实现FactoryBean接口：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class ColorFactoryBean implements FactoryBean&lt;Color&gt; &#123;<br><br>    //返回的Bean对象<br>    @Override<br>    public Color getObject() throws Exception &#123;<br>        return new Color();<br>    &#125;<br><br>    //Bean的类型<br>    @Override<br>    public Class&lt;?&gt; getObjectType() &#123;<br>        return Color.class;<br>    &#125;<br><br>    //是否是单例：<br>    //true:单例<br>    //false:多例<br>    @Override<br>    public boolean isSingleton() &#123;<br>        return true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 注册ColorFactoryBean到容器中，在配置文件MainConfig2中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean<br>public ColorFactoryBean colorFactoryBean() &#123;<br>    return new ColorFactoryBean();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 修改testImport方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void testImport() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>    printBeanName(applicationContext);<br><br><br>    Object colorFactoryBean = applicationContext.getBean(&quot;colorFactoryBean&quot;);<br>    System.out.println(colorFactoryBean);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig2<br>com.liuzhuo.bean.Color<br>com.liuzhuo.bean.Red<br>com.liuzhuo.bean.Blue<br>com.liuzhuo.bean.Yellow<br>person<br>bier<br>colorFactoryBean<br>rainBow<br>com.liuzhuo.bean.Color@6107227e<br></code></pre></td></tr></table></figure></p><p>发现：com.liuzhuo.bean.Color@6107227e 已经注册到容器中了。<br><strong>注意：我们注册到容器中的是ColorFactoryBean，但是获取Bean的时候，却是Color。</strong></p><p>底层是调用ColorFactoryBean的getObject()来获取的。</p><p>如果就是想要获取ColorFactoryBean本身的话，在id前面加一个&amp;：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Object colorFactoryBean = applicationContext.getBean(&quot;colorFactoryBean&quot;);<br>System.out.println(colorFactoryBean);<br>Object colorFactoryBean2 = applicationContext.getBean(&quot;&amp;colorFactoryBean&quot;);<br>System.out.println(colorFactoryBean2);<br></code></pre></td></tr></table></figure></p><p>结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">com.liuzhuo.bean.Color@6107227e<br>com.liuzhuo.bean.ColorFactoryBean@7c417213<br></code></pre></td></tr></table></figure></p><p>ps:点击BeanFactory：<br>会发现有一个字段：<br><code>String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</code><br>这就是为啥加&amp;会获取FactoryBean本身的原因.</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_04</title>
      <link href="/2018/10/14/spring-annotation-day-04/"/>
      <url>/2018/10/14/spring-annotation-day-04/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h3><p>作用：按照一定的条件进行判断，满足条件给容器中注入bean  </p><p>现在我们的需求的是根据操作系统的类型来，注入给定的bean对象。</p><p>在配置类中，添加两个方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean(&quot;bier&quot;)<br>public Person person01() &#123; //如果是windows系统就注入到容器中<br>    return new Person(&quot;Bier&quot;, 16);<br>&#125;<br><br>@Bean(&quot;linux&quot;)<br>public Person person02() &#123; //如果是Linux系统就注入到容器中<br>    return new Person(&quot;Linux&quot;, 18);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>在测试类中，创建新的test03方法:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test03() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>    //根据Bean类来获取所有的Bean类的id名字<br>    String[] beanNamesForType = applicationContext.getBeanNamesForType(Person.class);<br>    for (String name : beanNamesForType) &#123;<br>        System.out.println(name);<br>    &#125;<br>    //根据Bean类来获取Map结构<br>    Map&lt;String, Person&gt; beansOfType = applicationContext.getBeansOfType(Person.class);<br>    System.out.println(beansOfType);<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">D:\Java1.8\bin\java  <br>person<br>bier<br>linux<br>加载person类到容器中~~~<br>&#123;person=Person&#123;name=&apos;dengjie&apos;, age=18&#125;, bier=Person&#123;name=&apos;Bier&apos;, age=16&#125;, linux=Person&#123;name=&apos;Linux&apos;, age=18&#125;&#125;<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>此时：获取了所有的person类的Bean的id的名字。</p><hr><p>现在，我们创建com.liuzhuo.conditaion包，并创建两个实现了condition接口的类。如下：</p><p><img src="/images/20181014203017.png" style="width:50%">  </p><p>WinCondition类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class WinCondition implements Condition &#123;<br>    /*<br>     * conditionContext：     条件上下文（获取我们需要的资源）<br>     * annotatedTypeMetadata：注解类型的信息<br>     * */<br>    @Override<br>    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123;<br><br>        //获取beanFactory工厂<br>        ConfigurableListableBeanFactory beanFactory = conditionContext.getBeanFactory();<br>        //获取加载类<br>        ClassLoader classLoader = conditionContext.getClassLoader();<br>        //获取注解类<br>        BeanDefinitionRegistry registry = conditionContext.getRegistry();<br>        //获取环境变量<br>        Environment environment = conditionContext.getEnvironment();<br>        //获取资源加载类<br>        ResourceLoader resourceLoader = conditionContext.getResourceLoader();<br><br>        /*<br>        * 创建如果是windows系统的话，就注入到容器中<br>        * */<br>        String property = environment.getProperty(&quot;os.name&quot;);<br>        if (property.contains(&quot;Windows&quot;)) return true;<br>        return false;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>LinuxCondition类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class LinuxCondition implements Condition &#123;<br>    @Override<br>    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123;<br><br>        Environment environment = conditionContext.getEnvironment();<br>        String property = environment.getProperty(&quot;os.name&quot;);<br>        if (property.contains(&quot;Linux&quot;)) return true;<br>        return false;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>修改配置类：给刚刚创建的两个方法添加@Conditional注解</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Conditional(&#123;WinCondition.class&#125;)<br>@Bean(&quot;bier&quot;)<br>public Person person01() &#123; //如果是windows系统就注入到容器中<br>    return new Person(&quot;Bier&quot;, 16);<br>&#125;<br><br>@Conditional(&#123;LinuxCondition.class&#125;)<br>@Bean(&quot;linux&quot;)<br>public Person person02() &#123; //如果是Linux系统就注入到容器中<br>    return new Person(&quot;Linux&quot;, 18);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">person<br>bier<br>加载person类到容器中~~~<br>&#123;person=Person&#123;name=&apos;dengjie&apos;, age=18&#125;, bier=Person&#123;name=&apos;Bier&apos;, age=16&#125;&#125;<br>Windows 10<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>看到结果：现在作者的操作系统是windows系统，所以现在是bier给注入到容器中了。</p><p>现在修改操作系统的类型。</p><p>修改test03的运行环境，在idea的右上角点击”Edit Configrations···”:</p><p><img src="/images/20181014204146.png" style="width:50%"></p><p>编辑里面的 VM options: -Dos.name=Linux </p><p>然后运行test03.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">person<br>linux<br>加载person类到容器中~~~<br>&#123;person=Person&#123;name=&apos;dengjie&apos;, age=18&#125;, linux=Person&#123;name=&apos;Linux&apos;, age=18&#125;&#125;<br>Linux<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>此时，注入到容器中的是linux。</p><hr><p>总结：@Conditional注解是用来按照一定的条件进行判断，满足条件给容器中注入bean。<br>点击@Conditional：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>public @interface Conditional &#123;<br>    Class&lt;? extends Condition&gt;[] value();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>说明@Conditional里面是Condition&gt;[] value()数组。我们需要在@Conditional的value中写入数组。数组需要使用｛｝来写。传入的是实现了Condition接口的类。比如这里的WinCondition、LinuxCondition类。<br>实例：@Conditional({WinCondition.class})、@Conditional({LinuxCondition.class})。</p><p>@Conditional，不仅可以放在方法上面，还可以是类上面。<br>放在类上面，就是对这个类统一设置。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_03</title>
      <link href="/2018/10/14/spring-annotation-day-03/"/>
      <url>/2018/10/14/spring-annotation-day-03/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><h3 id="Scope注解"><a href="#Scope注解" class="headerlink" title="@Scope注解"></a>@Scope注解</h3><p>@Scope注解：是用来控制创建对象的作用域的，这里的作用域是我们平时所说的作用域。<br>这里是：单例模式、多例模式等。  </p><p>现在创建新的配置类com.liuzhuo.config.MainConfig2:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig2 &#123;<br><br>    @Bean(&quot;person&quot;)<br>    public Person person() &#123;<br>        return new Person(&quot;dengjie&quot;, 18);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在测试类IocTest中创建新的测试方法，test02：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test02() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>    //获取所有已经注入到容器中的Bean的id.<br>    String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();<br>    for (String name : beanDefinitionNames) &#123;<br>        System.out.println(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig2<br>person<br></code></pre></td></tr></table></figure><hr><p>现在我们修改配置类MainConfig2：<br>使用@Scope注解（作用域的功能）</p><p>@Scope可以使用四个值：<br>1.singleton：单例模式（<strong>默认值</strong>）<br>2.prototype：多例模式<br>3.request  ：一个request请求，创建一个新的实例<br>4.session  ：一个session请求，创建一个新的实例 </p><p>在配置类下的person方法上加入@Scope注解：   </p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig2 &#123;<br><br>    @Scope<br>    @Bean(&quot;person&quot;)<br>    public Person person() &#123;<br>        return new Person(&quot;dengjie&quot;, 18);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>现在修改test02测试方法，测试person是否是单例：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test02() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>    //获取所有已经注入到容器中的Bean的id.<br>    /*String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();<br>    for (String name : beanDefinitionNames) &#123;<br>        System.out.println(name);<br>    &#125;*/<br><br>    Object person = applicationContext.getBean(&quot;person&quot;);<br>    Object person2 = applicationContext.getBean(&quot;person&quot;);<br>    System.out.println(person == person2);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：true。注意：<strong>此时已经加载的是配置文件2了！！！</strong><br>说明@Scope默认是单例模式。</p><hr><p>现在修改成多例模式：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig2 &#123;<br><br>    @Scope(value = &quot;prototype&quot;)<br>    @Bean(&quot;person&quot;)<br>    public Person person() &#123;<br>        return new Person(&quot;dengjie&quot;, 18);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行测试方法test02：输出false。<br>说明：现在是多例模式。</p><hr><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>修改配置类，在person方法中加入一句输出语句。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig2 &#123;<br><br>    @Scope(value = &quot;singleton&quot;)<br>    @Bean(&quot;person&quot;)<br>    public Person person() &#123;<br>        System.out.println(&quot;加载person类到容器中~~~&quot;);<br>        return new Person(&quot;dengjie&quot;, 18);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>修改测试类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test02() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行测试方法：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">D:\Java1.8\bin\java -ea -Didea.test.cyclic.buffer.size=1048576 <br>加载person类到容器中~~~<br>true<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure><p>此时虽然只加载了容器类，但是person还是被加载到了容器中。<br>说明单例模式下，注入到容器中的类是立即注入的。不用到使用person类才注入到容器中来。</p><hr><p>现在讲单例变成多例模式，不改测试方法。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig2 &#123;<br><br>    @Scope(value = &quot;prototype&quot;)<br>    @Bean(&quot;person&quot;)<br>    public Person person() &#123;<br>        System.out.println(&quot;加载person类到容器中~~~&quot;);<br>        return new Person(&quot;dengjie&quot;, 18);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>此时啥也不输出！！!</strong></p><p>现在修改测试方法：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test02() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>  <br>    Object person = applicationContext.getBean(&quot;person&quot;);<br>    Object person2 = applicationContext.getBean(&quot;person&quot;);<br>    System.out.println(person == person2);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">加载person类到容器中~~~<br>加载person类到容器中~~~<br>false<br></code></pre></td></tr></table></figure></p><p>说明：多例是懒加载，只有等到获取person对象时，才会将person注入到容器中。</p><hr><h3 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h3><p>使用@Lazy注解来控制是否是懒加载。</p><p>修改配置类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig2 &#123;<br><br>    @Scope<br>    @Lazy<br>    @Bean(&quot;person&quot;)<br>    public Person person() &#123;<br>        System.out.println(&quot;加载person类到容器中~~~&quot;);<br>        return new Person(&quot;dengjie&quot;, 18);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>修改测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test02() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行测试方法：啥也不输出，说明此时已经是懒加载了。</p><hr><p>修改测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test02() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br><br>    Object person = applicationContext.getBean(&quot;person&quot;);<br>    Object person2 = applicationContext.getBean(&quot;person&quot;);<br>    System.out.println(person == person2);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">加载person类到容器中~~~<br>true<br></code></pre></td></tr></table></figure></p><p>此时是到使用person对象时，才会加载。并且只是加载了一次，因为是单例模式。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_02</title>
      <link href="/2018/10/13/spring-annotation-day-02/"/>
      <url>/2018/10/13/spring-annotation-day-02/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>接着day01天的内容，我们知道怎么使用java配置来初始化容器，使用@Configuration注解来标记一个java类就等同于了bean.xml文件了。</p><p>接下来，我们看看包扫描怎么配置，因为我们不可能给每个类都配置，那样太花时间和精力，所以我们需要包扫描的配置，来自动帮我们把需要的bean对象注入到容器中。</p><h3 id="一：xml版的包扫描"><a href="#一：xml版的包扫描" class="headerlink" title="一：xml版的包扫描"></a>一：xml版的包扫描</h3><hr><p>注意：这里在Bean.xml文件中需要配置命名空间,加上context的命名空间.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>       xsi:schemaLocation=&quot;<br>         http://www.springframework.org/schema/beans<br>         http://www.springframework.org/schema/beans/spring-beans.xsd<br>         http://www.springframework.org/schema/context<br>         http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;<br></code></pre></td></tr></table></figure></p><p>主要加入了xmlns:context=····和xsi:中的两个context(看结尾).</p><p>bean.xml配置文件加入了：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!--包扫描、只要标注了@Controller、@Service、@Repository、@Component都会自动注入到容器中--&gt;<br>&lt;!-- base-package包名，在该包下的子包也会被扫描--&gt;<br>&lt;context:component-scan base-package=&quot;com.liuzhuo&quot;/&gt;<br></code></pre></td></tr></table></figure></p><p>现在将bean.xml中的person配置注解掉。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!--以前的开发模式，使用配置文件--&gt;<br>&lt;!--&lt;bean id=&quot;person&quot; class=&quot;com.liuzhuo.bean.Person&quot;&gt;<br>    &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;<br>    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;<br>&lt;/bean&gt;--&gt;<br></code></pre></td></tr></table></figure></p><p>在Person类上面加入@Component注解。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Person<br></code></pre></td></tr></table></figure></p><p>运行MainTest测试类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);<br>Person person = (Person) applicationContext.getBean(&quot;person&quot;);<br>System.out.println(person);<br></code></pre></td></tr></table></figure></p><p>输出:</p><p><code>Person{name=&#39;null&#39;, age=null}</code>  </p><p>说明包扫描成功!</p><hr><h3 id="二：java类版的包扫描"><a href="#二：java类版的包扫描" class="headerlink" title="二：java类版的包扫描"></a>二：java类版的包扫描</h3><hr><p>首先将xml版本中的包扫描注解掉。</p><p>在java配置类上加入@ComponentScan(value = “com.liuzhuo”)<br>value：就是扫描的具体包的路径。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@ComponentScan(value = &quot;com.liuzhuo&quot;) //包扫描<br>public class MainConfig &#123;<br>   ·····<br>&#125;<br></code></pre></td></tr></table></figure><p>创建com.liuzhuo.controller、com.liuzhuo.service包、com.liuzhuo.dao<br>并创建相应的java类，BookController，BookService，BookDao。如下：</p><p><img src="/images/20181013170247.png" style="width:50%;">  </p><p>并在相应的类上面标注相应的注解。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Controller<br>public class BookController &#123;<br>&#125;<br>-----------------------------<br>@Service<br>public class BookService &#123;<br>&#125;<br>-----------------------------<br>@Repository<br>public class BookDao &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要是@Controller、@Service、@Repository三个注解。  </p><p>现在在test文件夹下面的jave包下创建测试类。</p><p>com.liuzhuo.test.IocTest类。</p><p>并在pom.xml文件中加入依赖<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependency&gt;<br>    &lt;groupId&gt;junit&lt;/groupId&gt;<br>    &lt;artifactId&gt;junit&lt;/artifactId&gt;<br>    &lt;version&gt;4.12&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>在IocTest类中写入一下代码:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocTest &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);<br>        //获取所有已经注入到容器中的Bean的id.<br>        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();<br>        for (String name : beanDefinitionNames) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>执行test01，结果：<br>除了spring内置的Bean对象外，主要有以下我们自己定义的Bean对象的id名<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>bookController<br>bookDao<br>bookService<br>person01<br></code></pre></td></tr></table></figure></p><hr><h3 id="三、-ComponentScan的用法"><a href="#三、-ComponentScan的用法" class="headerlink" title="三、@ComponentScan的用法"></a>三、@ComponentScan的用法</h3><p>上面，我们已经初步了解了@ComponentScan包扫描的基本用法了。<br>点击@ComponentScan注解。我们会看到<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Retention(RetentionPolicy.RUNTIME)<br>@Target(&#123;ElementType.TYPE&#125;)<br>@Documented<br>@Repeatable(ComponentScans.class)<br>public @interface ComponentScan &#123;<br>    @AliasFor(&quot;basePackages&quot;)<br>    String[] value() default &#123;&#125;;<br>    ····<br>&#125;<br></code></pre></td></tr></table></figure></p><p>value这个字段，说明是一个字符串类型的数组。说明value值，我们可以填写多个值，数组的话，用大花括号来表示，{}.每个值用逗号，来隔开。</p><p>ps:提一个小技巧，在idea中，Alt+7可以查看这个类中所有的字段和方法。</p><p>我们可以看到其中有一个includeFilters()的字段。<br><img src="/images/20181013173018.png" style="width:50%"></p><p>ComponentScan.Filter[] includeFilters() default {};</p><p>看到includeFilters也是一个数组，类型是ComponentScan的内部类Filter。<br>点击Filter，发现也是一个注解.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Retention(RetentionPolicy.RUNTIME)<br>    @Target(&#123;&#125;)<br>    public @interface Filter &#123;<br>        FilterType type() default FilterType.ANNOTATION;<br><br>        @AliasFor(&quot;classes&quot;)<br>        Class&lt;?&gt;[] value() default &#123;&#125;;<br><br>        @AliasFor(&quot;value&quot;)<br>        Class&lt;?&gt;[] classes() default &#123;&#125;;<br><br>        String[] pattern() default &#123;&#125;;<br>    &#125;<br></code></pre></td></tr></table></figure></p><p>发现有一个类型和字节码类的字段。</p><p><strong>1.includeFilters</strong></p><p>现在我们来使用这个includeFilters来在包扫描的时候，只扫描我们相要的类。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = &#123;<br>        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)<br>&#125;) //包扫描<br></code></pre></td></tr></table></figure></p><p>type是来说明过滤的类型的，这里的类型是注解(FilterType.ANNOTATION)。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public enum FilterType &#123;<br>    ANNOTATION,<br>    ASSIGNABLE_TYPE,<br>    ASPECTJ,<br>    REGEX,<br>    CUSTOM;<br><br>    private FilterType() &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总共有以上五个类型。<br>ANNOTATION：注解类型<br>ASSIGNABLE_TYPE：赋值类型</p><hr><p>运行test01类，发现结果还是<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>bookController<br>bookDao<br>bookService<br>person01<br></code></pre></td></tr></table></figure></p><p>是配置出现问题了嘛？不是，是因为我们忘记了，包扫描，默认是配置是扫描所有，所以，我们只需要将默认的配置设置为false就好了。<br>useDefaultFilters = false</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = &#123;<br>        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)<br>&#125;,useDefaultFilters = false) //包扫描<br>public class MainConfig<br></code></pre></td></tr></table></figure><p>结果为：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>bookController<br>person01<br></code></pre></td></tr></table></figure></p><p><strong>2.excludeFilters</strong></p><p>excludeFilters：是和includeFilters对着来的，是排除哪些类不扫描。</p><p>具体的配置情况如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@ComponentScan(value = &quot;com.liuzhuo&quot;, excludeFilters = &#123;<br>        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)<br>&#125;) //包扫描<br>public class MainConfig<br></code></pre></td></tr></table></figure></p><p>输出结果为：将@Controller注解的类就没有扫描。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>bookDao<br>bookService<br>person01<br></code></pre></td></tr></table></figure></p><p>总结：<br>@ComponentScan value:指定要扫描的包<br>jdk1.8中@ComponentScan是可重复的，所以可以写两个@ComponentScan<br>不过，可以使用@ComponentScans来配置多个@ComponentScan<br>excludeFilters = Filter[]: 指定扫描的时候按照什么规则排除哪些组件<br>includeFilters = Filter[]: 指定扫描的时候只需要包含哪些组件<br>ps:includeFilters,需要将默认的配置设置为false。(useDefaultFilters = false)</p><hr><h3 id="四、详解Filter的类型"><a href="#四、详解Filter的类型" class="headerlink" title="四、详解Filter的类型"></a>四、详解Filter的类型</h3><p>FilterType.ANNOTATION        按照注解<br>FilterType.ASSIGNABLE_TYPE   按照给定的类型<br>FilterType.ASPECTJ           使用ASPECTJ表达式<br>FilterType.REGEX             使用正则表达式<br>FilterType.CUSTOM            使用自定义的规则</p><p>更新MainConfig类:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@ComponentScans(value = &#123;<br>        @ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = &#123;<br>                @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)<br>        &#125;, useDefaultFilters = false)<br>&#125;)<br>public class MainConfig<br></code></pre></td></tr></table></figure><p>现在的输出结果为：(包含有@Controller注解的类)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>bookController<br>person01<br></code></pre></td></tr></table></figure></p><p>现在我们使用FilterType.ASSIGNABLE_TYPE 类型(给定类的类型)</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@ComponentScans(value = &#123;<br>        @ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = &#123;<br>                @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = &#123;BookService.class&#125;)<br>        &#125;, useDefaultFilters = false)<br>&#125;)<br>public class MainConfig<br></code></pre></td></tr></table></figure><p>输出结果是只要BookService类型的就行，他的子类也行。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>bookService<br>person01<br></code></pre></td></tr></table></figure></p><p>现在我们使用自定义规则，FilterType.CUSTOM。</p><p>需要自己创建一个类并实现TypeFilter接口。(我放在com.liuzhuo.config包)</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyTypeFilter implements TypeFilter &#123;<br>    @Override<br>    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123;<br>        return false;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释一下：<br>1.metadataReader  读取到当前正在扫描的类的信息<br>2.metadataReaderFactory  可以获取到其他任何类信息</p><p>我们通过这两个参数可以获取很多当前扫描类的信息。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyTypeFilter implements TypeFilter &#123;<br>    @Override<br>    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123;<br><br>        //获取当前类的注解信息<br>        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();<br>        //获取当前正在扫描的类信息<br>        ClassMetadata classMetadata = metadataReader.getClassMetadata();<br>        //获取当前类的资源(类的路径)<br>        Resource resource = metadataReader.getResource();<br><br>        String className = classMetadata.getClassName();<br>        System.out.println(&quot;---&gt;&quot; + className);<br><br>        return false;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述的方法，我们可以打印出被扫描的类的名字；<br>在此之前，我们还需要修改MainConfig配置类：<br>将Filter类型改为自定义类型。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@ComponentScans(value = &#123;<br>        @ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = &#123;<br>                @ComponentScan.Filter(type = FilterType.CUSTOM, classes = &#123;MyTypeFilter.class&#125;)<br>        &#125;, useDefaultFilters = false)<br>&#125;)<br>public class MainConfig<br></code></pre></td></tr></table></figure></p><p>运行test01测试类：<br>结果如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">---&gt;com.liuzhuo.test.IocTest<br>---&gt;com.liuzhuo.bean.Person<br>---&gt;com.liuzhuo.config.MyTypeFilter<br>---&gt;com.liuzhuo.controller.BookController<br>---&gt;com.liuzhuo.dao.BookDao<br>---&gt;com.liuzhuo.MainTest<br>---&gt;com.liuzhuo.service.BookService<br></code></pre></td></tr></table></figure></p><p>现在我们的MyTypeFilter返回都是false，所以被注入到容器的是<br>mainConfig<br>person01</p><p>现在，我们来更改MyTypeFilter类，我们只注入类名包含‘er’的类。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyTypeFilter implements TypeFilter &#123;<br>    @Override<br>    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123;<br><br>        //获取当前类的注解信息<br>        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();<br>        //获取当前正在扫描的类信息<br>        ClassMetadata classMetadata = metadataReader.getClassMetadata();<br>        //获取当前类的资源(类的路径)<br>        Resource resource = metadataReader.getResource();<br><br>        String className = classMetadata.getClassName();<br>        System.out.println(&quot;---&gt;&quot; + className);<br><br>        if (className.contains(&quot;er&quot;)) return true;<br>        return false;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>其实就是加了一句代码：<br><code>if (className.contains(&quot;er&quot;)) return true;</code></p><p>运动test01测试类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>person<br>myTypeFilter<br>bookController<br>bookService<br>person01<br></code></pre></td></tr></table></figure></p><p>除了本来的mainConfig、person01是配置文件帮我注入的。<br>其他的注入的类都是类名包含‘er’的。</p><p><strong>ps：都是在包扫描@ComponentScan(value = “com.liuzhuo”)</strong><br><strong>com.liuzhuo包下的’er’.</strong></p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_01</title>
      <link href="/2018/10/12/spring-annotation-01/"/>
      <url>/2018/10/12/spring-annotation-01/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong><br>开发流程：主要是使用idea来完成的，此教程是针对有spring开发经验的人看的。用来对比以前的配置文件来注入依赖和java类配置来注入依赖的区别。  </p><p>打开idea创建Maven工程，输入三个坐标，groupId，artifactId，version。<br>我们这里的三个坐标是:  </p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;groupId&gt;com.liuzhuo&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-annotation&lt;/artifactId&gt;<br>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;<br></code></pre></td></tr></table></figure><p>创建后的工程如下：<br><img src="/images/20181012212912.png" style="width:300px; heigh:300px"></p><hr><p>现在打开pom.xml文件:添加依赖如下<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;<br>            &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;<br>        &lt;/dependency&gt;<br>&lt;/dependencies&gt;<br></code></pre></td></tr></table></figure></p><p>更新pom文件，会自动导入jar包。 </p><hr><p>在src下的main下的java中创建Person类。我的包名是com.liuzhuo.bean<br>Person类中主要是两个字段，一个name，一个age，如图:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Person &#123;<br>    private String name;<br>    private Integer age;<br><br>    ···中间省略了无参、有参的构造函数和getter、setter方法以及toString方法.    <br>&#125;<br></code></pre></td></tr></table></figure></p><p>现在在main下的resources下创建bean.xml文件  </p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;<br><br>    &lt;!--以前的开发模式，使用配置文件--&gt;<br>    &lt;bean id=&quot;person&quot; class=&quot;com.liuzhuo.bean.Person&quot;&gt;<br>        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;<br>        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;<br>    &lt;/bean&gt;<br><br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><hr><p>现在在com.liuzhuo包下创建MainTest类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MainTest &#123;<br><br>    public static void main(String[] args) &#123;<br><br>        //以前的开发模式，使用xml来配置bean<br>        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);<br>        Person person = (Person) applicationContext.getBean(&quot;person&quot;);<br>        System.out.println(person);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><p>输出结果:就是在配置文件中的配置的person类。</p><p><code>Person{name=&#39;zhangsan&#39;, age=18}</code></p><hr><p>现在创建com.liuzhuo.config包，并创建MainConfig类:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig &#123;<br><br>    //给容器中注册一个Bean；类型为返回值的类型，id默认为方法名<br>    @Bean<br>    public Person person() &#123;<br>        return new Person(&quot;lisi&quot;, 16);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><p>修改MainTest类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MainTest &#123;<br><br>    public static void main(String[] args) &#123;<br><br>        //以前的开发模式，使用xml来配置bean<br>        /*ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);<br>        Person person = (Person) applicationContext.getBean(&quot;person&quot;);<br>        System.out.println(person);*/<br><br>        //现在使用java类来配置上下文容器<br>        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig.class);<br>        Person person = context.getBean(Person.class);<br>        System.out.println(person);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><p>输出结果：是MainConfig类中配置Person类(@Bean注解的类) </p><p><code>Person{name=&#39;lisi&#39;, age=16}</code></p><p>在配置文件类必须使用@Configuration注解，然后再注入自己想要的Bean对象<br>创建一个方法，使用@Bean注解，返回值就是注入到容器中的Bean类型，默认情况下方法名就是注入到容器中的id。  </p><p>@Bean注解()中，可以输入参数，其中就有value来修改Bean的id名，如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MainConfig &#123;<br><br>    //给容器中注册一个Bean；类型为返回值的类型，id默认为方法名<br>    @Bean(value = &quot;person01&quot;) //修改了Bean的id为person01<br>    public Person person() &#123;<br>        return new Person(&quot;lisi&quot;, 16);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>在MainTest文件中输入获取Person类的名字：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//现在使用java类来配置上下文容器<br>AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig.class);<br>Person person = context.getBean(Person.class);<br>System.out.println(person);<br><br>String[] beanNames = context.getBeanNamesForType(Person.class);<br>for(String name:beanNames)&#123;<br>   System.out.println(name);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果： </p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Person&#123;name=&apos;lisi&apos;, age=16&#125;<br>person01<br></code></pre></td></tr></table></figure><p>说明此时，Bean的id名字是被@Bean(value=”person01”)给替换了，不再是方法名person了。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown</title>
      <link href="/2018/10/12/markdown/"/>
      <url>/2018/10/12/markdown/</url>
      
        <content type="html"><![CDATA[<p> <strong>序言</strong>:<br></p><p></p><p>很久没有写日记了，以前只是在QQ空间写，现在觉得在自己的平台写日记还是感觉不错的，还是要多写博客来加强自己学习的知识，学的知识点感觉还是记不住，渐渐地让我明白，看的越多，懂的越少（你这话不是有毛病吗？应该是看的越多，懂的越多才对），此话怎讲，当你在茫茫的知识库里面东看西看的时候，很快就被海量的知识给淹没了，根本就不知道哪些是对的，哪些是错的，感觉好像这个也懂了，那个也懂了，但是真正写起来，脑子又一片空白，又好像什么都不懂，这种状态时有发生，这就叫不懂装懂，最根本的原因就是看的太多，写的太少，所以为了改掉这样毛病，把被动学习变成主动学习，接下来的日子，多写写，即使是写一些学习工作中遇到的坑也是好的，没事翻出来看看，还可以加深印象，好了，废话到处！<br></p><br>正文：<br><br><strong>一、标题的几种写法</strong>：<p></p><p><strong>第一种</strong>：<br></p><p>#一级标题<br></p><p>##二级标题<br></p><p>###三级级标题<br></p><p>####四级标题<br></p><p>#####五级标题<br></p><p>######六级标题<br><br><strong>说明：真正使用的时候，需要在#后加空格!!!!!</strong><br><br>效果:<br>   </p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级级标题"><a href="#三级级标题" class="headerlink" title="三级级标题"></a>三级级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p><strong>第二种</strong>：<br><br>  这是一级标题<br><br>  ======<br><br>  这是二级标题<br><br>  ———<br><br>这种只能表示一级和二级标题,==和–的数量个数没有限制，多少都行!!!<br>效果：<br></p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><p><strong>第三种</strong>：<br></p><p>#一级标题#<br></p><p>##二级标题##<br><br>其他几级标题类似，就是一个封闭的意思，也是注意#后面需要有空格!!!</p><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><p>那既然3种都可以使用，可不可以混合使用呢？我试了一下，是可以的，但是为了让页面标签的统一性，不建议混合使用，推荐使用第一种，比较简洁，全面</p><p>为了搞清楚原理，我特意在网上搜一下在线编写markdown的工具，发现实际上是把这些标签最后转化为html标签，如图：<br><br><img src="https://i.imgur.com/QSo6UUP.png" alt=""><br>在线地址请看这里:<a href="http://tool.oschina.net/markdown/" title="markdown在线编辑器" target="_blank" rel="noopener">markdown在线编辑器</a><br></p><hr><p><strong>二：列表</strong><br><br>1.无序列表：<br><br>*1<br><br>*2<br><br>*3<br><br>+1<br><br>+2<br><br>+3<br><br>-1<br><br>-2<br><br>-3<br><br>效果:<br></p><ul><li>1</li><li>2</li><li>3</li></ul><ul><li>1</li><li>2</li><li>3</li></ul><ul><li>1</li><li>2</li><li>3<br></li></ul><p>可以看到，无序列表可以用 * ， + ， - 来创建，用在线编辑器看，实际上是转换成了ul&gt;li ，所以使用哪个都可以，推荐使用*吧.<br><br><br>2.有序列表:<br><br>1.列表1<br>2.列表2<br>3.列表3</p><ol><li>列表1</li><li>列表2</li><li>列表3</li></ol><p>有序列表就相对简单一点，只有这一种方式，注意，数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的。</p><hr><p><strong>三：区块引用</strong><br>比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语句。使用&gt;  </p><ul><li>犯我帝国者，虽远必诛!  <blockquote><p>这是嘉文四世说的</p></blockquote></li></ul><p><strong>四：华丽的分割线</strong><br>分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以</p><hr><p><strong>五:图片</strong><br>图片也有2种方式：行内式和参数式.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">![我是图片](https://www.fdfdfdf.jpg)<br>[我是图片]: (https://www.fdfdfdf.jpg)<br>参数式图片，这里是[我是图片]<br></code></pre></td></tr></table></figure></p><p>用法跟链接的基本一样，唯一的不同就是，图片前面要写一个！（这是必须的），没什么好说的。</p><hr><p><strong>六：代码块</strong></p><p>这个就比较重要了，很多时候都需要展示出一些代码</p><p>如果代码量比较少，只有单行的话，可以用单反引号包起来，如下： </p><p>第一种：单行（两个）: ``</p><p><code>var js = new object();</code>  </p><p>要是多行这个就不行了，多行可以用3个 `</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">int a = 10;  <br>int b = 20;  <br>int sum = a + b;  <br>printf(&quot;%d&quot;,sum);<br></code></pre></td></tr></table></figure><hr><p><strong>七：强调</strong>  </p><p>*字体倾斜*<br>_字体倾斜_<br>**字体加粗**<br>__字体加粗__  </p><p>一个星号或者是一个下划线包起来，会转换为<code>&lt;em&gt;</code>倾斜，如果是2个，会转换为<code>&lt;strong&gt;</code>加粗</p><hr><p><strong>八：转义</strong>  </p><p> \：转义符号，和js一样。</p><hr><p><strong>九：删除线</strong>  </p><p>~~请删除我~~:</p><p><del>请删除我</del>  </p><hr><p><strong>十：html原始码</strong> </p><p>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理.</p><hr><p>常用的基本上就这些了，如果还有一些常用的，可以跟我留言，我补充上去. </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>新文章</title>
      <link href="/2018/10/11/my-new-post/"/>
      <url>/2018/10/11/my-new-post/</url>
      
        <content type="html"><![CDATA[<p>这是作者的第一篇文章，主要是为了纪念自己的博客!!</p><hr><p>欢迎大家在此篇文章下面评论，我会尽量回复大家的问题。</p><p>不管是生活上面的，还是学习上面的疑惑都可以提</p><p>一段故事温柔人心，爱分享爱解忧，么么哒~~</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>  <img src="/images/gakki.png"></p><p>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;本人只是一个即将毕业的程序猿小哥哥，由于秋招结束，闲暇时间搭建了这个平台，只为给自己的生活增添一点乐趣。</p><p></p><p>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;本人也是Gakki酱的脑残粉，非常喜欢她的微笑，看了好多她的电视剧，比如：父女七日变、恋空、花水木、逃避虽可耻但有用、Legal High、全开女孩等，欢迎大家关注我的<a href="https://weibo.com/p/1005053310889015/home/" target="_blank" rel="noopener">微博</a>，比心~~~</p><p></p><p>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;平时喜欢的娱乐是打篮球和逛B站，对二次元有着一定的情怀，B站也给我机会，为了生活放弃了机会，不知道是对还是错，只能一路走到黑了。游戏的话，英雄联盟也陪伴了我的大学生活，现在都不怎么玩了，最多玩玩荣耀和吃鸡，但是还是少了当初那种在网吧5连坐开黑的感觉，我觉得人生最大的乐趣莫过于回忆，等老了，和老伴坐在板凳上面，说着过去的回忆，想想就很幸福。</p><p></p><p>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;作为一个程序员对技术不感兴趣，说来也惭愧，平时我也会更新自己的技术博客的，为了生活，不容易，fighting~</p><p></p><p>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;最后放一段爱豆的视频让大家欣赏一下，萨拉拉~</p><p></p>  <iframe src="//player.bilibili.com/player.html?aid=23675732&cid=39547539&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="80%" height="500px" style="margin-left:30px"><br>  </iframe>]]></content>
      
    </entry>
    
  
</search>
