<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Git初级入门</title>
      <link href="/2018/10/25/Git%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8/"/>
      <url>/2018/10/25/Git%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>git的初级用法</strong></p><h3 id="Git的下载"><a href="#Git的下载" class="headerlink" title="Git的下载"></a>Git的下载</h3><p>git的官网：<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><p>点击右下角的：Downloade xxxx for Windows</p><p>由于是国外的网站，下载速度或许会很慢，请耐心等待~~</p><p>下载完后，直接安装就行。</p><p>安装完成，在桌面会创建Git Bash快捷方式。</p><p><strong>在任意目录下右击鼠标：会看到Git GUI Here 和 Git Bash Here 两个命令</strong></p><h3 id="Git的初步设置"><a href="#Git的初步设置" class="headerlink" title="Git的初步设置"></a>Git的初步设置</h3><ol><li>首先复制git的安装路径，追加到高级环境变量的PATH之后。确定保存退出。</li><li><p>打开cmd命令窗口（可用win+r,输入cmd确定即可）,输入git –vision命令（version前是两杠),显示版本号：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">C:\Users\liuzhuo&gt;git --version<br>git version 2.15.0.windows.1<br><br>C:\Users\liuzhuo&gt;<br></code></pre></td></tr></table></figure></li><li><p>进入Git界面，就是在任意目录下，右键，点击Git Bash Here<br><img src="/images/20181025091705.png"></p></li><li><p>配置全局的用户名和密码：</p></li></ol><p>git config –global user.name 你的用户名 #用户名<br>git config –global user.email 你的邮箱 #邮箱 </p><p>这里加了 –global的选项，说明是全局配置，意思是在当前windows下，使用的git都是在这个用户下，也可以给一个项目配置单独的用户名和密码。</p><ol start="5"><li>查看配置信息</li></ol><p>使用 git config –list<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 ~/Desktop<br>$ git config --list<br>core.symlinks=false<br>core.autocrlf=true<br>core.fscache=true<br>color.diff=auto<br>color.status=auto<br>color.branch=auto<br>color.interactive=true<br>help.format=html<br>rebase.autosquash=true<br>http.sslcainfo=D:/Git/mingw64/ssl/certs/ca-bundle.crt<br>http.sslbackend=openssl<br>diff.astextplain.textconv=astextplain<br>filter.lfs.clean=git-lfs clean -- %f<br>filter.lfs.smudge=git-lfs smudge -- %f<br>filter.lfs.process=git-lfs filter-process<br>filter.lfs.required=true<br>credential.helper=manager<br>user.name=liuzhuo<br>user.email=575920824@qq.com<br></code></pre></td></tr></table></figure></p><p>使用git config –global –list:查看全局配置信息<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 ~/Desktop<br>$ git config --global --list<br>user.name=liuzhuo<br>user.email=575920824@qq.com<br></code></pre></td></tr></table></figure></p><ol start="6"><li><p>常用的配置命令</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//查<br>git config --global --list<br> <br>git config --global user.name<br> <br>//增<br>git config  --global --add user.name jianan<br> <br>//删<br>git config  --global --unset user.name<br> <br>//改<br>git config --global user.name zhangsan<br></code></pre></td></tr></table></figure></li><li><p>全局配置文件的地方</p></li></ol><p><code>~/.gitconfig</code></p><p>例如Windows下，则是</p><p><code>C:\Users\用户名\.gitconfig</code></p><ol start="8"><li>各个仓库的配置</li></ol><p><code>.git/config</code></p><p>例如orange仓库目录下</p><p><code>/home/lanyang/orange/.git/config</code></p><h3 id="Git的GUI界面"><a href="#Git的GUI界面" class="headerlink" title="Git的GUI界面"></a>Git的GUI界面</h3><p>这里，我们使用SourceTree</p><p>官网：<a href="https://www.sourcetreeapp.com" target="_blank" rel="noopener">https://www.sourcetreeapp.com</a></p><p>点击：Downloade for Windows</p><h3 id="Git-仓库"><a href="#Git-仓库" class="headerlink" title="Git 仓库"></a>Git 仓库</h3><p>1) 初始化版本库</p><p>git init</p><p>2) 添加文件到版本库</p><p>git add</p><p>git commit</p><p>3) 查看仓库状态</p><p>git status</p><hr><p>首先，使用SourceTree来创建本地仓库：</p><p>1）打开SourceTree<br><img src="/images/20181025103910.png"></p><p>左上角：</p><p>Local： 代表本地仓库</p><p>Remote：代表远程仓库</p><p>右边：</p><p>Clone：代表克隆其他人的仓库</p><p>Add： 在原有仓库的基础上添加新的仓库</p><p>Create：创建新的仓库</p><p>2）点击Local和Create来创建本地仓库<br><img src="/images/20181025104307.png"></p><p>第一行：仓库的路径</p><p>第二行：仓库的名字<br><img src="/images/20181025104441.png"></p><p>这里：选择了E盘下的gitdemo\demo1目录。</p><p>点击创建</p><p>3）在demo1目录下，创建一个新的文件(.txt)，并随便写入几句话。</p><p>demo test······</p><p>4）观察SourceTree界面：<br><img src="/images/20181025104851.png"></p><p>此时，在未暂存区域出现了我们刚刚创建的文件。</p><p>说明，刚刚创建的文件现在只是在我们的工作目录下，还没有提交到本地仓库中。</p><p><strong>ps：此时，有三个区域，第一个是我们的工作目录，第二个是暂存区域，第三个是本地仓库区域</strong></p><p>我们一般在自己的工作目录下，编写自己的代码，然后提加到暂存区域，最后没有问题后，再提交到本地仓库保存起来。</p><p>5）点击text.txt，然后点击暂存所选<br><img src="/images/20181025105356.png"></p><p>此时，我们的文件就保存到暂存区域了。</p><p>6）提交到本地仓库中</p><p>在最下面，填写我们的提交信息，然后点击提交。<br><img src="/images/20181025105612.png"></p><p>7) 提交成功后，查看仓库的状态</p><p>第一次添加都是在主分支下面的，即master分支。</p><p>点击master分支<br><img src="/images/20181025105822.png"></p><p>我们，就看到了，自己刚刚提交到本地仓库中的记录了。</p><hr><p>现在，使用命令行界面来操作：</p><p>在一个目录下，右键，点击Git Bush：</p><p>我选择的是：E:\gitdemo<br><img src="/images/20181025110804.png"></p><p>1) git init demo2<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo<br>$ git init demo2<br>Initialized empty Git repository in E:/gitdemo/demo2/.git/<br></code></pre></td></tr></table></figure></p><p>2) 进入仓库的目录<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo<br>$ cd demo2<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$<br></code></pre></td></tr></table></figure></p><p><strong>ps:上面的右边的括号(master)，代表现在是主分支。</strong></p><p>3) 创建新的文件</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ echo &quot;demo2 text~~~~&quot; &gt;&gt; text2.txt<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$<br></code></pre></td></tr></table></figure><p>此时，在demo2工作目录下，就会出现一个新的文件，text2.txt文件。</p><p>4）查看状态</p><p>git status<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br><br>No commits yet<br><br>Untracked files:<br>  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)<br><br>        text2.txt<br><br>nothing added to commit but untracked files present (use &quot;git add&quot; to track)<br></code></pre></td></tr></table></figure></p><p>说明，当前是在主分支下，新建的text2.txt文件还没有提交。</p><p>5）先添加到暂存区</p><p>git add text2.txt</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git add text2.txt<br>warning: LF will be replaced by CRLF in text2.txt.<br>The file will have its original line endings in your working directory.<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br><br>No commits yet<br><br>Changes to be committed:<br>  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)<br><br>        new file:   text2.txt<br></code></pre></td></tr></table></figure><p>此时，文件已经加入到暂存区域了，最后，需要提交到本地仓库中</p><p>6）提交到本地仓库</p><p>git commit -m “repo2 first commit”<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git commit -m &quot;repo2 first commit&quot;<br>[master (root-commit) 8f22147] repo2 first commit<br> 1 file changed, 1 insertion(+)<br> create mode 100644 text2.txt<br></code></pre></td></tr></table></figure></p><p>7) 查看本地仓库的状态</p><p>git status<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure></p><hr><h3 id="Git-工作流"><a href="#Git-工作流" class="headerlink" title="Git 工作流"></a>Git 工作流</h3><p>现在，模拟一下，你上班的情况。第一天上班，创建自己的本地仓库，提交自己的完成的代码需求。</p><h4 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a>SourceTree</h4><p>1）新建一个本地仓库</p><p>这里，我选择的是 E:\gitdemo\demo3，大家可以根据自己的喜好自由创建。<br><img src="/images/20181025113245.png"></p><p>2) 添加新的文件</p><p>点击中间的：在文件管理器中打开</p><p>然后，创建demo3.txt文件，并输入：第一天的需要，已经完成</p><p>再回到SourceTree中：</p><p><img src="/images/20181025113527.png"></p><p>3）add + commit<br><img src="/images/20181025114112.png"></p><p>4) 提交成功<br><img src="/images/20181025114212.png"></p><hr><p>现在，快到下班了，产品经理提了一个临时的需求，所以，我们快马加鞭的写完，但是还没有自测，就只将先写的代码，保存到暂存区域中，不提交到本地仓库中。</p><p>1）打开，demo3.txt 文件，先加入一句话：临时需求已做完！<br><img src="/images/20181025114518.png"></p><p>2) 在SourceTree中，将先修改的demo3文件，保存到暂存区域中：</p><p><img src="/images/20181025114641.png"></p><p><img src="/images/20181025114717.png"></p><p>此时，拿起我们的背包，下班回家。</p><p>第二天，上班，那个该死的产品经理，说昨天的临时需求不要了，内心一万个曹尼玛~~~</p><p>所以，我们需要将暂存区域的代码和工作区域的代码，回滚到上一个阶段。</p><p>3）点击demo3.text，右键：丢弃<br><img src="/images/20181025115021.png"></p><p>4) 点击确定丢弃<br><img src="/images/20181025115425.png"></p><p>5) 点击demo3.txt文件<br><img src="/images/QQ截图20181025115532.png"></p><p><strong>发现，demo3.txt文件中，回滚到了上一次提交的状态。</strong></p><p><strong>删除了：临时需求已做完</strong></p><hr><p>第二天，继续codeing，编写产品经理提出的新需求。</p><p>1）打开demo3.txt文件</p><p>添加：第二天的需要已经完成！<br><img src="/images/QQ截图20181025115902.png"></p><p>2) add + commit<br><img src="/images/QQ截图20181025120045.png"></p><p><img src="/images/QQ截图20181025120147.png"></p><p>能看到，有两次的提交记录。</p><p>3）突然，产品经理说，这个需要不要了。内心无话可说</p><p>所以，我们需要回滚到上一次提交的状态。</p><p>点击 first commit ，<strong>右键：重置当前分支到此次提交</strong></p><p><img src="/images/QQ截图20181025124253.png"></p><p>要回到哪个状态，就点击哪个状态，然后右键重置当前分支到此次提交：</p><p><img src="/images/QQ截图20181025124921.png"></p><p>点击确定。</p><p>4）现在在工作区域下，能看到，上次修改后的没有提交的代码。<br><img src="/images/QQ截图20181025125125.png"></p><p>5) 丢弃修改的demo3.txt<br><img src="/images/QQ截图20181025125317.png"></p><p>6）打开demo3.txt文件：<br><img src="/images/QQ截图20181025125416.png"></p><p>回滚到第一次提交成功的状态了。</p><hr><p>现在，产品经理，说第一次提交的需求，也不需要了，需要删除这个文件。</p><p>1）直接在工作目录下，直接删除demo3.txt文件<br><img src="/images/QQ截图20181025125817.png"></p><p>2）add + commit<br><img src="/images/QQ截图20181025125922.png"></p><p><img src="/images/QQ截图20181025125959.png"></p><p>3) 此时，工作目录，暂存区域，本地仓库都删除了demo3.txt文件了。</p><hr><h4 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h4><p>现在使用命令行来操作：</p><p>1）打开命令行<br><img src="/images/QQ截图20181025130301.png"></p><p>2）在demo2下，创建bash_demo.txt文件</p><p>在文件中，输入：bash_demo 第一次提交成功.<br><img src="/images/QQ截图20181025130624.png"></p><p>3) 在命令行查看状态</p><p> git status<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>Untracked files:<br>  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)<br><br>        bash_demo.txt<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br></code></pre></td></tr></table></figure></p><p>4) 报存到暂存区：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git add bash_demo.txt<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>        new file:   bash_demo.txt<br></code></pre></td></tr></table></figure></p><p>5) 提交到本地仓库中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git commit -m &quot;bash_demo first commit&quot;<br>[master 136ecd0] bash_demo first commit<br> 1 file changed, 1 insertion(+)<br> create mode 100644 bash_demo.txt<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure></p><hr><p>6) 产品经理提出了临时的需要</p><p>打开bash_demo.txt文件，添加：产品经理临时变更需要。<br><img src="/images/QQ截图20181025131337.png"></p><p>7) 查看 + add到暂存区域中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>        modified:   bash_demo.txt<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br><br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git add bash_demo.txt<br></code></pre></td></tr></table></figure></p><p>下班走人。</p><p>8）产品经理说，临时需要不要了</p><p>使用 git reset head xxx.txt （重置）<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git reset head bash_demo.txt<br>Unstaged changes after reset:<br>M       bash_demo.txt<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>        modified:   bash_demo.txt<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br></code></pre></td></tr></table></figure></p><p>此时，只是将本地仓库的文件替换了暂存区域中的bash_demo文件。我们工作区域的文件还没有替换。</p><p>需要使用：git checkout – bash_demo.txt<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git checkout -- bash_demo.txt<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br></code></pre></td></tr></table></figure></p><p>打开bash_demo.txt文件。发现：产品经理临时变更需要。删除了</p><p>9）第二天继续开发</p><p>修改bash_demo.txt 文件。</p><p>添加：第二天的需要已经完成<br><img src="/images/QQ截图20181025132555.png"></p><p>10) 将修改后的文件，add + commit<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git add bash_demo.txt<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>        modified:   bash_demo.txt<br><br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git commit -m &quot;second commit&quot;<br>[master b8412ec] second commit<br> 1 file changed, 3 insertions(+), 1 deletion(-)<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure></p><p>不幸的是，产品经理说，第二天的需要不需要了。</p><p>11）查看提交日志</p><p>git log</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git log<br>commit b8412ec81784d6be4a5097fca881a811fe1b1a58 (HEAD -&gt; master)<br>Author: liuzhuo &lt;575920824@qq.com&gt;<br>Date:   Thu Oct 25 13:27:36 2018 +0800<br><br>    second commit<br><br><br>commit 136ecd07ab2b0742dff45dcdcfbde1d51da2df42<br>Author: liuzhuo &lt;575920824@qq.com&gt;<br>Date:   Thu Oct 25 13:10:32 2018 +0800<br><br>    bash_demo first commit<br></code></pre></td></tr></table></figure><p>找到：bash_demo第一次提交的序列号：</p><p>commit 136ecd07ab2b0742dff45dcdcfbde1d51da2df42<br>Author: liuzhuo <a href="mailto:&#53;&#55;&#53;&#x39;&#50;&#x30;&#x38;&#50;&#x34;&#64;&#113;&#x71;&#46;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#53;&#55;&#53;&#x39;&#50;&#x30;&#x38;&#50;&#x34;&#64;&#113;&#x71;&#46;&#x63;&#111;&#109;</a><br>Date:   Thu Oct 25 13:10:32 2018 +0800</p><p>bash_demo first commit</p><p>这里，就是：136ecd07ab2b0742dff45dcdcfbde1d51da2df42</p><p>12）回滚</p><p>git reset –hard 136ecd07ab2b0742dff45dcdcfbde1d51da2df42<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git reset --hard 136ecd07ab2b0742dff45dcdcfbde1d51da2df42<br>HEAD is now at 136ecd0 bash_demo first commit<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure></p><p>查看，bash_demo.txt文件：<br><img src="/images/QQ截图20181025133411.png"></p><p>bash_demo文件就回滚到第一次提交的状态了。</p><p>13）现在产品经理说，所做的工作都不需要了。</p><p>删除bash_demo文件</p><p>git rm bash_demo<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git rm bash_demo.txt<br>rm &apos;bash_demo.txt&apos;<br></code></pre></td></tr></table></figure></p><p>git commit -m “delete bash demo”<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git commit -m &quot;delete bash demo&quot;<br>[master 6d7eacc] delete bash demo<br> 1 file changed, 1 deletion(-)<br> delete mode 100644 bash_demo.txt<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure></p><p>这样工作目录和本地仓库都删除了bash_demo文件了。</p><hr><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><img src="/images/QQ截图20181025134253.png"></p><p>1) 在工作区，先创建的文件，使用add，添加到暂存区，然后commit提交到本地仓库中。</p><p>2）reset head命令：head是指向本地仓库的指针。<br>reset head file 就是重置本地仓库中版本文件到暂存区中。<br>然后使用checkout – file 命令，将暂存区中的版本文件，重写到工作区中。</p><p>3）rm – file: 直接删除暂存区中的文件。然后commit提交，就更新到本地仓库中了。</p><p>4）checkout head file: 一般不用，比较危险，因为使用这个命令，会把本地仓库中的版本文件，直接覆写到暂存区和工作区中。</p><hr><p>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage/index），标记为 “master” 的是 master 分支所代表的目录树。</p><p>图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个“指针”。所以，图示的命令中出现 HEAD 的地方可以用 master 来替换。</p><p>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下。</p><p>当对工作区新增或修改的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区新增或修改的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。（如上图）</p><p>当执行提交操作 “git commit” 时，暂存区的目录树写到版本库的对象库（objects）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。（如上图）</p><p>当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 “git rm –cached <file>“ 命令时，会直接从暂存区删除文件，工作区则不做出改变。</file></p><p>当执行 “git checkout “ 或者 “git checkout – <file>“ 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</file></p><p>当执行 “git checkout HEAD .” 或者 “git checkout HEAD <file>“ 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</file></p><hr><h3 id="创建ssh-key"><a href="#创建ssh-key" class="headerlink" title="创建ssh key"></a>创建ssh key</h3><p>1）我们如果需要使用ssh来连接远程仓库的话，这里使用github当做远程仓库。</p><p>首先，生成我们的ssh的公钥：<br>ssh-keygen -t rsa -C “<a href="mailto:youremail@exmple.com" target="_blank" rel="noopener">youremail@exmple.com</a>“</p><p>在github上面，创建我们的账号。在setting里面，找到 SSH and GPG keys<br><img src="/images/QQ截图20181025144339.png"></p><p>点击右上角的：New SSH key<br><img src="/images/QQ截图20181025144438.png"></p><p>填写title，自己定义。key，需要使用命令来生成。</p><p>在Git bash界面下，输入生成ssh的命令：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ ssh-keygen -t rsa -C &quot;575920824@qq.com&quot;<br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/c/Users/liuzhuo/.ssh/id_rsa):<br></code></pre></td></tr></table></figure></p><p>直接回车，覆盖以前的就好了。</p><p>这样就会在c盘的用户目录生成一个.ssh文件夹</p><p>C:\Users\liuzhuo.ssh</p><p>打开<strong>id_rsa.pub</strong>文件，将里面的key复制到github的ssh中key中：<br><img src="/images/QQ截图20181025145015.png"></p><p>2) 测试是否连接github成功：</p><p>使用命令：ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ ssh -T git@github.com<br>Hi liuzhuo19940206! You&apos;ve successfully authenticated, but GitHub does not provide shell access.<br></code></pre></td></tr></table></figure></p><p>连接成功！！</p><hr><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><h4 id="使用命令行的方式"><a href="#使用命令行的方式" class="headerlink" title="使用命令行的方式"></a>使用命令行的方式</h4><p>在自己的github上面的，添加新的远程仓库<br><img src="/images/QQ截图20181025145915.png" style="width:50%"></p><p>点击 New repository<br><img src="/images/QQ截图20181025150029.png"></p><p>填写  </p><p>Repository name:仓库的名字</p><p>Description：仓库的描述信息</p><p>public：公共的仓库</p><p>private：私有的仓库<br><img src="/images/QQ截图20181025150238.png"></p><p>点击：Create repository<br><img src="/images/QQ截图20181025150341.png"></p><p>上面的两块部分，描述了，将本地仓库和这个远程仓库连接起来的方法！</p><p>第一种：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">…or create a new repository on the command line<br>echo &quot;# gitDemo&quot; &gt;&gt; README.md<br>git init<br>git add README.md<br>git commit -m &quot;first commit&quot;<br>git remote add origin https://github.com/liuzhuo19940206/gitDemo.git<br>git push -u origin master<br></code></pre></td></tr></table></figure></p><p>按照上面的步骤来，就行了。</p><p>在E:\gitdemo\demo4目录下，启动git的命令行界面<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4<br>$ echo &quot;# gitDemo&quot; &gt;&gt; README.md      //创建一个文件<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4<br>$ git init                          //创建一个本地仓库<br>Initialized empty Git repository in E:/gitdemo/demo4/.git/<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)<br>$ git add README.md                 //添加文件到暂存区<br>warning: LF will be replaced by CRLF in README.md.<br>The file will have its original line endings in your working directory.<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)<br>$ git commit -m &quot;first commit&quot;      //提交信息到本地仓库<br>[master (root-commit) e1e56e5] first commit<br> 1 file changed, 1 insertion(+)<br> create mode 100644 README.md<br></code></pre></td></tr></table></figure></p><p>接下来，连接本地仓库和远程仓库：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)<br>$ git remote add origin https://github.com/liuzhuo19940206/gitDemo.git<br></code></pre></td></tr></table></figure></p><p>最后，将本地仓库的提交到远程仓库中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)<br>$ git push -u origin master<br></code></pre></td></tr></table></figure></p><p>第一次提交会出现验证信息的弹窗：<br><img src="/images/QQ截图20181025151356.png" style="width:50%"></p><p>输入用户名和密码即可。</p><p>出现了 fatal: HttpRequestException encountered.</p><p>解决：Github 禁用了TLS v1.0 and v1.1，必须更新Windows的git凭证管理器 </p><p>通过此网址 <a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/" target="_blank" rel="noopener">https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/</a><br><img src="/images/QQ截图20181025152916.png"></p><p>点击GCMW-1.14.0.exe，下载并安装。</p><p>重启git窗口：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)<br>$ git push -u origin master<br>Counting objects: 3, done.<br>Writing objects: 100% (3/3), 217 bytes | 217.00 KiB/s, done.<br>Total 3 (delta 0), reused 0 (delta 0)<br>remote:<br>remote: Create a pull request for &apos;master&apos; on GitHub by visiting:<br>remote:      https://github.com/liuzhuo19940206/gitDemo/pull/new/master<br>remote:<br>To https://github.com/liuzhuo19940206/gitDemo.git<br> * [new branch]      master -&gt; master<br>Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;.<br></code></pre></td></tr></table></figure></p><p>就可以了，说明你的git和github已经可以同步了</p><p>在github上面，刷新你刚刚创建的项目：<br><img src="/images/QQ截图20181025154108.png"></p><hr><p>现在，修改README.md文件<br><img src="/images/QQ截图20181025154259.png"></p><p>然后  </p><p>git add README.md</p><p>git commit -m “second commit”</p><p>最后</p><p>将本地仓库同步到远程仓库</p><p>git push</p><p>这里不用指明远程仓库的名字，因为第一次同步后，就不需要了。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)<br>$ git push<br>Counting objects: 3, done.<br>Writing objects: 100% (3/3), 277 bytes | 277.00 KiB/s, done.<br>Total 3 (delta 0), reused 0 (delta 0)<br>To https://github.com/liuzhuo19940206/gitDemo.git<br>   e1e56e5..39e3593  master -&gt; master<br></code></pre></td></tr></table></figure><p>刷新远程仓库：<br><img src="/images/QQ截图20181025154719.png"></p><p>说明，本地仓库和远程仓库同步成功!!!!</p><hr><h4 id="使用SourceTree"><a href="#使用SourceTree" class="headerlink" title="使用SourceTree"></a>使用SourceTree</h4><p>1）创建新的远程仓库<br><img src="/images/QQ截图20181025155615.png"><br><img src="/images/QQ截图20181025155703.png"></p><p>2) 打开SourceTree创建本地仓库<br><img src="/images/QQ截图20181025155817.png"></p><p>在本地仓库中，新建文件sourcetree.txt文件<br><img src="/images/QQ截图20181025160003.png"></p><p>3）使用SourceTree添加到本地仓库中<br><img src="/images/QQ截图20181025160104.png"><br><img src="/images/QQ截图20181025160120.png"><br><img src="/images/QQ截图20181025160210.png"></p><p>4）将本地仓库和远程仓库连接起来</p><p>点击master，然后点击右上角的设置<br><img src="/images/QQ截图20181025160348.png"></p><p>点击添加远程仓库：<br><img src="/images/QQ截图20181025160430.png"></p><p>填写信息：</p><p>远程仓库名称：origin（自定义）</p><p>URL：在github中远程仓库复制。<br>这里是：<a href="https://github.com/liuzhuo19940206/gitDemo_SourceTree.git" target="_blank" rel="noopener">https://github.com/liuzhuo19940206/gitDemo_SourceTree.git</a></p><p>用户名：提交的用户名<br><img src="/images/QQ截图20181025160716.png"></p><p>点击确认。</p><p>在SourceTree中的左边的远程中：出现origin。<br><img src="/images/QQ截图20181025160844.png"></p><p>到此，我们就将远程仓库和本地仓库连接起来了。还没有同步！</p><p>5) 将本地仓库和远程仓库同步</p><p>点击菜单栏的推送<br><img src="/images/QQ截图20181025161056.png"></p><p>选好推送的远程仓库，添上加号，点击推送！</p><p>6）刷新远程仓库<br><img src="/images/QQ截图20181025161257.png"></p><p>发现，同步成功，点击sourcetree.txt文件<br><img src="/images/QQ截图20181025161359.png"></p><p>7）修改本地仓库中的sourcetree.txt文件<br><img src="/images/QQ截图20181025161447.png"></p><p>8）使用SourceTree提交<br><img src="/images/QQ截图20181025161550.png"><br><img src="/images/QQ截图20181025174045.png"><br><img src="/images/QQ截图20181025174124.png"></p><p>9）推送到远程仓库</p><p>此时，会发现推送上面会出现一个 1<br><img src="/images/QQ截图20181025174248.png"></p><p>点击推送<br><img src="/images/QQ截图20181025174319.png"></p><p>10）刷新远程仓库<br><img src="/images/QQ截图20181025174433.png"></p><p>这里出现了乱码，不影响我们的操作。</p><hr><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><p>克隆仓库：将远程的仓库克隆到本地当中。</p><p>使用的命令是：<br>git clone htt或ssh地址<br>git clone <a href="https://github.com/liuzhuo19940206/clone_repo_demo.git" target="_blank" rel="noopener">https://github.com/liuzhuo19940206/clone_repo_demo.git</a></p><p>1）在github上创建一个新的仓库<br><img src="/images/QQ截图20181025175600.png"></p><p>2) 直接在github上面创建一个README.md文件<br><img src="/images/QQ截图20181025175832.png"></p><p>上面两个步骤，就是假设刚刚创建的项目是别人的远程仓库，我们需要克隆别人的远程仓库，来进行多人开发。</p><h4 id="使用命令行来克隆"><a href="#使用命令行来克隆" class="headerlink" title="使用命令行来克隆"></a>使用命令行来克隆</h4><p>1）在E:\gitdemo\demo6下，启动git窗口<br><img src="/images/QQ截图20181025180055.png"></p><p>使用 ls -a<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo6<br>$ ls -a<br>./  ../<br></code></pre></td></tr></table></figure></p><p>如果没有出现.git文件，说明此目录才能克隆仓库。不能在已经是本地仓库下的情况下克隆远程仓库</p><p>2）执行克隆命令</p><p>git clone <a href="https://github.com/liuzhuo19940206/clone_repo_demo.git" target="_blank" rel="noopener">https://github.com/liuzhuo19940206/clone_repo_demo.git</a><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo6<br>$ git clone https://github.com/liuzhuo19940206/clone_repo_demo.git<br>Cloning into &apos;clone_repo_demo&apos;...<br>remote: Enumerating objects: 3, done.<br>remote: Counting objects: 100% (3/3), done.<br>remote: Compressing objects: 100% (2/2), done.<br>remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0<br>Unpacking objects: 100% (3/3), done.<br></code></pre></td></tr></table></figure></p><p>此时，打开demo6目录：在该目录下面会出远程仓库的名称和README.md文件<br><img src="/images/QQ截图20181025183824.png"><br><img src="/images/QQ截图20181025183908.png"><br><img src="/images/QQ截图20181025183938.png"></p><p>到此，克隆成功。</p><hr><h4 id="使用SourceTree来克隆"><a href="#使用SourceTree来克隆" class="headerlink" title="使用SourceTree来克隆"></a>使用SourceTree来克隆</h4><p>1）打开SourceTree，新建窗口<br><img src="/images/QQ截图20181025184546.png"></p><p>2）点击Clone按钮<br><img src="/images/QQ截图20181025184631.png"></p><p>第一行：远程仓库的地址<br><a href="https://github.com/liuzhuo19940206/clone_repo_demo.git" target="_blank" rel="noopener">https://github.com/liuzhuo19940206/clone_repo_demo.git</a></p><p>第二行：本地仓库的地址<br>E:\gitdemo\demo7</p><p><img src="/images/QQ截图20181025184839.png"></p><p>点击克隆<br><img src="/images/QQ截图20181025184925.png"></p><p>3）打开E:\gitdemo\demo7目录<br><img src="/images/QQ截图20181025185035.png"></p><hr><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>标签的作用是，给某个时刻的版本加上一个标签，然后，可以回滚到指定的标签。</p><p>标签的命令：</p><p>1) 查看所有标签 　　　　 git tag</p><p>2) 创建标签 　　　　　　 git tag name</p><p>3) 指定提交信息 　　　　 git tag -a name -m “comment”</p><p>4) 删除标签 　　　　　　 git tag -d neam</p><p>5) 标签发布 　　　　　 　git push origin name</p><p><strong>ps:markdown中使用空格</strong></p><p><strong>1) 手动输入空格 （&amp;nbsp；）。注意！此时的分号为英文分号，但是不推荐使用此方法，太麻烦！</strong></p><p><strong>2) 使用全角空格。即：在全角输入状态下直接使用空格键就ok了</strong></p><h4 id="使用命令行创建标签"><a href="#使用命令行创建标签" class="headerlink" title="使用命令行创建标签"></a>使用命令行创建标签</h4><p>现在是在E:\gitdemo\demo7目录下。<br><img src="/images/QQ截图20181025192253.png"></p><p>1）git tag 查看标签<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)<br>$ git tag<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)<br>$<br></code></pre></td></tr></table></figure></p><p>发现，没有标签</p><p>2）创建标签<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)<br>$ git tag v1.0.1<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)<br>$ git tag<br>v1.0.1<br></code></pre></td></tr></table></figure></p><p>3) push标签<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)<br>$ git push origin v1.0.1<br>Total 0 (delta 0), reused 0 (delta 0)<br>To https://github.com/liuzhuo19940206/clone_repo_demo.git<br> * [new tag]         v1.0.1 -&gt; v1.0.1<br></code></pre></td></tr></table></figure></p><p>4) 在远程仓库中验证标签是否推送成功<br><img src="/images/QQ截图20181025192912.png"></p><hr><h4 id="使用SourceTree创建标签"><a href="#使用SourceTree创建标签" class="headerlink" title="使用SourceTree创建标签"></a>使用SourceTree创建标签</h4><p>1) 现在修改一下E:\gitdemo\demo7下的README.md文件，为了和命令行创建的标签形成对比.<br><img src="/images/QQ截图20181025193635.png"></p><p>使用SourceTree，add + commit + push<br><img src="/images/QQ截图20181025193833.png"><br><img src="/images/QQ截图20181025193850.png"><br><img src="/images/QQ截图20181025193916.png"><br><img src="/images/QQ截图20181025194050.png"></p><p>2) 在SourceTree下创建新的标签</p><p>在SourceTree的菜单栏上面有一个标签的按钮，点击<br><img src="/images/QQ截图20181025194223.png"></p><p>第一行：标签的名称</p><p>提交：点击指定的提交<br><img src="/images/QQ截图20181025194327.png"></p><p>此时，可以选择在哪个提交的版本上面，创建新的标签，因为first commit上面有一个v1.0.1的标签了，为了区别，现在选择second commit的提交。点击确认</p><p>点击推送标签前面的方格，会将本地的标签推送到远程仓库上面。<br><img src="/images/QQ截图20181025194613.png"></p><p>3）点击添加标签<br><img src="/images/QQ截图20181025194731.png"><br><img src="/images/QQ截图20181025194804.png"></p><p>4）在远程仓库上面验证<br><img src="/images/QQ截图20181025194853.png"></p><p>5）切换标签</p><p>点击v1.0.1标签：<br><img src="/images/QQ截图20181025195005.png"><br><strong>下面的README.md文件中，没有second commit。</strong></p><p>点击v2.0.1标签：<br><img src="/images/QQ截图20181025195110.png"><br><strong>下面的README.md文件中，有second commit。</strong></p><font color="red"><strong>以后，就可以切换标签，来回滚到自己想要的版本。</strong></font><hr><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p><img src="/images/QQ截图20181025200337.png"></p><p>一般是，在我们开发的过程中，在主分支master上面写。但是，每个人都有自己的任务，这个任务，不能短时间内完成，不能只完成一部分就提交到master主分支上面，这样会使的其他人无法使用master主分支了。我们也不能等到我们开发完后，一次性提交代码到master主分支上面。因为我们想记录我们的每一个开发流程。</p><p>所以，需要创建子分支来记录我们的开发流程。最后与主分支合并。</p><h4 id="使用命令行的方式-1"><a href="#使用命令行的方式-1" class="headerlink" title="使用命令行的方式"></a>使用命令行的方式</h4><p>1）新建一个目录：E:\gitdemo\branch_demo</p><p>2）在该目录下，打开git窗口<br><img src="/images/QQ截图20181025201915.png"></p><p>3) 添加一个新的文件，模拟开发流程。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo<br>$ echo &quot;branch first&quot; &gt;&gt; branch_demo.txt            //创建新的文件<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo <br>$ git init                                         //创建本地仓库<br>Initialized empty Git repository in E:/gitdemo/branch_demo/.git/<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git status<br>On branch master<br><br>No commits yet<br><br>Untracked files:<br>  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)<br><br>        branch_demo.txt<br><br>nothing added to commit but untracked files present (use &quot;git add&quot; to track)<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git add branch_demo.txt                         //添加到暂存区<br>warning: LF will be replaced by CRLF in branch_demo.txt.<br>The file will have its original line endings in your working directory.<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git status<br>On branch master<br><br>No commits yet<br><br>Changes to be committed:<br>  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)<br><br>        new file:   branch_demo.txt<br><br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git commit -m &quot;branch first commit&quot;           //提交到本地仓库中<br>[master (root-commit) ac97673] branch first commit<br> 1 file changed, 1 insertion(+)<br> create mode 100644 branch_demo.txt<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure><p>4）开启新的分支<br>git brach  : 查看所有分支<br>git brach 分支名称 ：创建新的分支<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git branch<br>* master<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git branch new_branch<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git branch<br>* master<br>  new_branch<br></code></pre></td></tr></table></figure></p><p>5）切换分支<br>git checkout 分支名称<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git checkout new_branch<br>Switched to branch &apos;new_branch&apos;<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br></code></pre></td></tr></table></figure></p><p>切换成功后，右边的括号内就是分支的名称。</p><p>6）在新分支继续开发<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ echo &quot; new_branch&quot; &gt;&gt; branch_demo.txt<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git status<br>On branch new_branch<br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>        modified:   branch_demo.txt<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git add branch_demo.txt<br>warning: LF will be replaced by CRLF in branch_demo.txt.<br>The file will have its original line endings in your working directory.<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git status<br>On branch new_branch<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>        modified:   branch_demo.txt<br><br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git commit -m &quot;new_branch commit&quot;<br>[new_branch 25fe8ff] new_branch commit<br> 1 file changed, 2 insertions(+), 1 deletion(-)<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git status<br>On branch new_branch<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure></p><p>7) 分别在每个分支查看branch_demo.txt文件</p><p>在新的分支下查看：<br>cat branch_demo.txt<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git branch<br>  master<br>* new_branch<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ cat branch_demo.txt<br>branch first<br>new_branch<br></code></pre></td></tr></table></figure></p><p>切换到主分支查看：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git checkout master<br>Switched to branch &apos;master&apos;<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ cat branch_demo.txt<br>branch first<br></code></pre></td></tr></table></figure></p><p>8) 合并分支</p><p>git merge 子分支的名字</p><font color="red">在主分支(master)下，执行该命令</font><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git merge new_branch<br>Updating ac97673..25fe8ff<br>Fast-forward<br> branch_demo.txt | 3 ++-<br> 1 file changed, 2 insertions(+), 1 deletion(-)<br></code></pre></td></tr></table></figure><p>9）查看主分支中的文件<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ cat branch_demo.txt<br>branch first<br>new_branch<br></code></pre></td></tr></table></figure></p><p><strong>现在，主分支与子分支合并成功，文件中出现了new_branch的信息。</strong></p><p>10）删除分支</p><p>当我们的项目接着开发，之前的new_brach分子不需要，浪费空间，所有需要删除。</p><p>git branch -d 分支的名称</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git branch -d new_branch<br>Deleted branch new_branch (was 25fe8ff).<br><br>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git branch<br>* master<br></code></pre></td></tr></table></figure><p>此时，new_branch分支删除成功。</p><h4 id="使用SourceTree的方式"><a href="#使用SourceTree的方式" class="headerlink" title="使用SourceTree的方式"></a>使用SourceTree的方式</h4><p>1）打开SourceTree</p><p>在E:\gitdemo\branch_sourcetree_demo下创建本地仓库<br><img src="/images/QQ截图20181025205416.png"></p><p>2）在E:\gitdemo\branch_sourcetree_demo下创建branch_demo.txt文件：<br><img src="/images/QQ截图20181025205522.png"></p><p>3）add + commit<br><img src="/images/QQ截图20181025205642.png"><br><img src="/images/QQ截图20181025205658.png"><br><img src="/images/QQ截图20181025205724.png"><br><img src="/images/QQ截图20181025205758.png"></p><p>4) 创建新的分支</p><p>在SourceTree的菜单栏上面有一个分支的按钮<br><img src="/images/QQ截图20181025205849.png"><br><img src="/images/QQ截图20181025205950.png"></p><p>创建分支成功后，在SourceTree左边，会出现新的分支<br><img src="/images/QQ截图20181025210021.png"></p><p><strong>选中的分支前面会有一个圆圈</strong></p><p>5）在新的分支下，修改branch_demo.txt文件<br><img src="/images/QQ截图20181025210235.png"></p><p>6) 在新的分支下，add + commit<br><img src="/images/QQ截图20181025210332.png"><br><img src="/images/QQ截图20181025210426.png"><br><img src="/images/QQ截图20181025210509.png"></p><p>7）切换到master分支下</p><p>双击master主分支，就切换成功了。<br><img src="/images/QQ截图20181025210659.png"></p><p>8）打开E:\gitdemo\branch_sourcetree_demo下的branch_demo.txt文件<br><img src="/images/QQ截图20181025210750.png"></p><p>发现文件里面，没有new_branch second信息。</p><p>9）将子分支合并到主分支中</p><p>在主分支的情况下，点击菜单栏下的合并按钮<br><img src="/images/QQ截图20181025211021.png"></p><p>点击我们要合并的分支。然后点击确定。<br><img src="/images/QQ截图20181025211223.png"></p><p>现在，再打开E:\gitdemo\branch_sourcetree_demo下的branch_demo.txt文件。<br><img src="/images/QQ截图20181025211400.png"></p><p>现在，合并成功了。</p><p>10）删除分支</p><p>直接在要删除的分支上面右键<br><img src="/images/QQ截图20181025211604.png"><br><img src="/images/QQ截图20181025211636.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC注解</title>
      <link href="/2018/10/24/SpringMVC%E6%B3%A8%E8%A7%A3/"/>
      <url>/2018/10/24/SpringMVC%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><strong>SpringMVC注解</strong></p><h3 id="注解概观"><a href="#注解概观" class="headerlink" title="注解概观"></a>注解概观</h3><p><strong>Spring2.5 引入注解式处理器</strong></p><p>@Controller：用于标识是处理器类；</p><p>@RequestMapping：请求到处理器功能方法的映射规则；</p><p>@RequestParam：请求参数到处理器功能处理方法的方法参数上的绑定；</p><p>@ModelAttribute：请求参数到命令对象的绑定；</p><p>@SessionAttributes：用于声明session级别存储的属性，放置在处理器类上，通常列出模型属性（如@ModelAttribute）对应的名称，则这些属性会透明的保存到session中；</p><p>@InitBinder：自定义数据绑定注册支持，用于将请求参数转换到命令对象属性的对应类型；</p><hr><p><strong>Spring3.0 引入RESTful架构风格支持(通过@PathVariable注解和一些其他特性支持),且又引入了更多的注解支持</strong></p><p>@CookieValue：cookie数据到处理器功能处理方法的方法参数上的绑定；</p><p>@RequestHeader：请求头（header）数据到处理器功能处理方法的方法参数上的绑定；</p><p>@RequestBody：请求的body体的绑定（通过HttpMessageConverter进行类型转换）；</p><p>@ResponseBody：处理器功能处理方法的返回值作为响应体（通过HttpMessageConverter进行类型转换）；</p><p>@ResponseStatus：定义处理器功能处理方法/异常处理器返回的状态码和原因；</p><p>@ExceptionHandler：注解式声明异常处理器；</p><p>@PathVariable：请求URI中的模板变量部分到处理器功能处理方法的方法参数上的绑定</p><h3 id="类与方法注解"><a href="#类与方法注解" class="headerlink" title="类与方法注解"></a>类与方法注解</h3><p>@Controller @RestController</p><p>@RestContrller注解相当于@ResponseBody和@Controller的结合 :</p><h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h4><p>通过HttpMessageConverter接口转换为指定格式的数据</p><h4 id="InitBinder-局部转换器"><a href="#InitBinder-局部转换器" class="headerlink" title="@InitBinder-局部转换器"></a>@InitBinder-局部转换器</h4><p>如果希望某个属性编辑器仅作用于特定的 Controller ，</p><p>可以在 Controller 中定义一个标注 @InitBinder 注解的方法，</p><p>可以在该方法中向 Controller 了注册若干个属性编辑器</p><p>例如:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@InitBinder<br>public void initBinder(WebDataBinder binder) &#123;<br>SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);<br>dateFormat.setLenient(false);<br>binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="RequestMapping-请求路径映射"><a href="#RequestMapping-请求路径映射" class="headerlink" title="@RequestMapping-请求路径映射"></a>@RequestMapping-请求路径映射</h4><p>RequestMapping是一个用来处理请求地址映射的注解（将请求映射到对应的控制器方法中），可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>RequestMapping请求路径映射，如果标注在某个controller的类级别上，则表明访问此类路径下的方法都要加上其配置的路径；最常用是标注在方法上，表明哪个具体的方法来接受处理某次请求。</p><p>属性:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。<br>1、 value， method；<br>value：   指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；<br>method：  指定请求的method类型， GET、POST、PUT、DELETE等；<br>2、consumes，produces<br>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;<br>produces:  指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；<br>3、params，headers<br>params：  指定request中必须包含某些参数值是，才让该方法处理。<br>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。<br></code></pre></td></tr></table></figure></p><p>派生的子类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Ø  @GetMapping<br><br>Ø  @PostMapping<br><br>Ø  @PutMapping<br><br>Ø  @DeleteMapping<br><br>Ø  @PatchMapping<br></code></pre></td></tr></table></figure></p><p>属性详解：</p><h5 id="value"><a href="#value" class="headerlink" title="value"></a><font size="4">value</font></h5><p>用法</p><p>(1)普通的具体值。如前面的 value=”/book”。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RequestMapping(value=&quot;/get/&#123;bookId&#125;&quot;)<br>public String getBookById(@PathVariable String bookId,Model model)&#123;<br>  model.addAttribute(&quot;bookId&quot;, bookId);<br>  return &quot;book&quot;;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>(2)含某变量的一类值。</p><p>(3)ant风格<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RequestMapping(value=&quot;/get/id?&quot;)：可匹配“/get/id1”或“/get/ida”，但不匹配“/get/id”或“/get/idaa”;<br>@RequestMapping(value=&quot;/get/id*&quot;)：可匹配“/get/idabc”或“/get/id”，但不匹配“/get/idabc/abc”;<br>@RequestMapping(value=&quot;/get/id/*&quot;)：可匹配“/get/id/abc”，但不匹配“/get/idabc”;<br>@RequestMapping(value=&quot;/get/id/**/&#123;id&#125;&quot;)：可匹配“/get/id/abc/abc/123”或“/get/id/123”，也就是Ant风格和URI模板变量风格可混用。<br></code></pre></td></tr></table></figure></p><p>(4)含正则表达式的一类值<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RequestMapping(value=&quot;/get/&#123;idPre:\d+&#125;-&#123;idNum:\d+&#125;&quot;)：<br>可以匹配“/get/123-1”，但不能匹配“/get/abc-1”，这样可以设计更加严格的规则。<br>可以通过@PathVariable 注解提取路径中的变量(idPre,idNum)<br></code></pre></td></tr></table></figure></p><p>(5)或关系<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RequestMapping(value=&#123;&quot;/get&quot;,&quot;/fetch&quot;&#125; ) 即 /get或/fetch都会映射到该方法上。<br></code></pre></td></tr></table></figure></p><h5 id="method"><a href="#method" class="headerlink" title="method"></a><font size="4">method</font></h5><p>指定请求的method类型， GET、POST、PUT、DELETE等；</p><p>用法:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RequestMapping(value=&quot;/get/&#123;bookid&#125;&quot;,method=&#123;RequestMethod.GET,RequestMethod.POST&#125;)<br></code></pre></td></tr></table></figure></p><h5 id="params："><a href="#params：" class="headerlink" title="params："></a><font size="4">params：</font></h5><p><strong>指定request中必须包含某些参数值是，才让该方法处理。</strong></p><p>@RequestMapping(params=”action=del”)，请求参数包含”action=del”,如：</p><p><code>http://localhost:8080/book?action=del</code></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Controller<br>@RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)<br>public class RelativePathUriTemplateController &#123;<br>@RequestMapping(value = &quot;/pets/&#123;petId&#125;&quot;, method = RequestMethod.GET, params=&quot;myParam=myValue&quot;)<br>public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) &#123;    <br>  // implementation omitted<br>&#125;<br>&#125;<br>仅处理请求中包含了名为“myParam”，值为“myValue”的请求<br></code></pre></td></tr></table></figure><h5 id="headers："><a href="#headers：" class="headerlink" title="headers："></a><font size="4">headers：</font></h5><p>指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><p>@RequestMapping(value=”/header/id”, headers = “Accept=application/json”)：</p><p>表示请求的URL必须为“/header/id 且请求头中必须有“Accept =application/json”参数即可匹配。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Controller<br>@RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)<br>public class RelativePathUriTemplateController &#123;<br><br>@RequestMapping(value = &quot;/pets&quot;, method = RequestMethod.GET, headers=&quot;Referer=http://www.ifeng.com/&quot;)<br>public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) &#123;    <br>  // implementation omitted<br>&#125;<br><br>&#125;<br>    仅处理request的header中包含了指定“Refer”请求头和对应值为“http://www.ifeng.com/”的请求。<br></code></pre></td></tr></table></figure></p><h5 id="consumes："><a href="#consumes：" class="headerlink" title="consumes："></a><font size="4">consumes：</font></h5><p>指定处理请求的提交内容类型（Content-Type），例如application/json, text/html。</p><p>用法:</p><p>@RequestMapping(value = “/pets”, method = RequestMethod.POST, consumes=”application/json”)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Controller<br>@RequestMapping(value = &quot;/pets&quot;, method = RequestMethod.POST, consumes=&quot;application/json&quot;)<br>public void addPet(@RequestBody Pet pet, Model model) &#123;    <br>  // implementation omitted<br>&#125;<br>          方法仅处理request Content-Type为“application/json”类型的请求。<br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC-参数绑定</title>
      <link href="/2018/10/24/SpringMVC-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/"/>
      <url>/2018/10/24/SpringMVC-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p><strong>SpringMVC-参数绑定</strong></p><h4 id="Model-ModelMap-ModelAndView"><a href="#Model-ModelMap-ModelAndView" class="headerlink" title="Model/ModelMap/ModelAndView"></a>Model/ModelMap/ModelAndView</h4><p>ModelMap是Model接口的实现类，通过Model或ModelMap向页面传递数据，如下<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RequestMapping(&quot;/itemEdit&quot;)<br>    public String itemEdit(Integer id, Model model) &#123;<br>        Items items = itemService.getItemById(id);<br>        //向jsp传递数据<br>        model.addAttribute(&quot;item&quot;, items);<br>        //设置跳转的jsp页面<br>        return &quot;editItem&quot;;<br>    &#125;<br>    /*@RequestMapping(&quot;/itemEdit&quot;)<br>    public String editItem(HttpServletRequest request, <br>            HttpServletResponse response, HttpSession session, Model model) &#123;<br>        //从request中取参数<br>        String strId = request.getParameter(&quot;id&quot;);<br>        int id = new Integer(strId);<br>        //调用服务<br>        Items items = itemService.getItemById(id);<br>        //把结果传递给页面<br>        //ModelAndView modelAndView = new ModelAndView();<br>        //modelAndView.addObject(&quot;item&quot;, items);<br>        //设置逻辑视图<br>        //modelAndView.setViewName(&quot;editItem&quot;);<br>        //return modelAndView;<br>        //设置返回结果<br>        model.addAttribute(&quot;item&quot;, items);<br>        //返回逻辑视图<br>        return &quot;editItem&quot;;<br>    &#125;<br>    */<br></code></pre></td></tr></table></figure></p><h4 id="Any-other-argument原始参数"><a href="#Any-other-argument原始参数" class="headerlink" title="Any other argument原始参数"></a>Any other argument原始参数</h4><p>当请求的参数名称和处理器形参<strong>名称一致时</strong>会将请求参数与形参进行绑定。从Request取参数的方法可以进一步简化。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RequestMapping(&quot;/itemEdit&quot;)<br>    public String itemEdit(Integer id, Model model) &#123;<br>        Items items = itemService.getItemById(id);<br>        //向jsp传递数据<br>        model.addAttribute(&quot;item&quot;, items);<br>        //设置跳转的jsp页面<br>        return &quot;editItem&quot;;<br>    &#125;<br>参数类型推荐使用包装数据类型，因为基础数据类型不可以为null<br>整形：  Integer、int<br>字符串：String<br>单精度：Float、float<br>双精度：Double、double<br>布尔型：Boolean、boolean<br>说明：对于布尔类型的参数，请求的参数值为true或false。<br>处理方法：<br>public String editItem(Model model,Integer id,Boolean status) throws Exception<br>请求url：<br>http://localhost:8080/xxx.action?id=2&amp;status=false<br>处理器形参中添加如下类型的参数处理适配器会默认识别并进行赋值。<br></code></pre></td></tr></table></figure></p><h3 id="注解形式："><a href="#注解形式：" class="headerlink" title="注解形式："></a>注解形式：</h3><p>下面是具体使用说明，几乎都是下面这种格式：Public String (@RequestParam int id){..}</p><h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h4><p>@RequestParam用来接收路径后面的参数<br><code>http:www.lifeibai.com?petId = 1.</code><br> 一般用来处理接收的参数和形参的参数不一致的情况<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RequestParam(value = &quot;id&quot;,defaultValue = &quot;10&quot;,required = false)<br>defaultValue 表示设置默认值，<br>required     通过boolean设置是否是必须要传入的参数，<br>value        值表示接受的传入的参数名称<br>使用@RequestParam常用于处理简单类型的绑定。<br></code></pre></td></tr></table></figure></p><p>例子：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Controller<br>@RequestMapping(&quot;/pets&quot;)<br>public class EditPetForm &#123;<br>  // ...<br>  @GetMapping<br>  public String setupForm(@RequestParam(&quot;petId&quot;) int Id, Model model) &#123;<br>      Pet pet = this.clinic.loadPet(petId);<br>      model.addAttribute(&quot;pet&quot;, pet);<br>      return &quot;petForm&quot;;<br>  &#125;<br>  // ...<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h4><p>@RequestHeader用来接收指定参数的请求头信息<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@GetMapping(&quot;/demo&quot;)<br>public void handle(<br>      @RequestHeader(&quot;Accept-Encoding&quot;) String encoding,<br>      @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive) &#123;<br>  //...<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h4><p>用来接收指定名称的cookie的值<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public void handle(@CookieValue(&quot;JSESSIONID&quot;) String cookie) &#123;<br>  //...<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a><font color="red">@ModelAttribute</font></h4><p>ModelAttribute可以应用在<strong>方法参数上</strong>或<strong>方法上</strong>，他的作用主要是当注解在方法参数上时会将注解的参数对象添加到Model中；</p><p>当注解在请求处理方法Action上时会将该方法变成一个非请求处理的方法，但其它Action被调用时会<strong>首先</strong>调用该方法。</p><p><font color="#FF3E96">被@ModelAttribute注释的方法会在此controller每个方法执行前被执行，下面访问 http:localhost:8080/test_project/test.action</font><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RestController<br>@SessionAttributes(&quot;user&quot;)<br>public class TestController &#123;<br>    @ModelAttribute(&quot;age2&quot;)<br>    public String mdoeltest1()&#123;<br>        System.out.println(&quot;This is ModelAttribute1 !&quot;);<br>        return &quot;33&quot;;<br>    &#125;<br>    @ModelAttribute(&quot;age1&quot;)<br>    public String mdoeltestrrr()&#123;<br>        System.out.println(&quot;This is ModelAttributee1 !&quot;);<br>        return &quot;22&quot;;<br>    &#125;<br>    @RequestMapping(&quot;/test.action&quot;)<br>    public String test(User user , <br>                       @ModelAttribute(&quot;age1&quot;) String age1 ,<br>                       @ModelAttribute(&quot;age2&quot;) String age2 ,<br>                       HttpSession session)&#123;<br>        Object user2 = session.getAttribute(&quot;user&quot;);<br>        System.out.println(user2);<br>        System.out.println(user);<br>        System.out.println(&quot;age1:&quot;+age1);<br>        System.out.println(&quot;age2:&quot;+age2);<br>        return &quot;test&quot;;<br>    &#125;<br>&#125;<br>结果：<br>This is ModelAttributee1 !<br>This is ModelAttribute1 !<br>User&#123;name=&apos;李四&apos;, age=22&#125;<br>User&#123;name=&apos;李四&apos;, age=22&#125;<br>age1:22<br>age2:33<br></code></pre></td></tr></table></figure></p><h4 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a>@SessionAttributes</h4><p>Value={“name”,“age”} 取出name或者value、或者把model中的name，age扔到session中<br>Type=User.Class   将一个实体类扔到session中<br>这个玩意加在 类上面，然后所有的方法的参数都可以在sesssion中找，找到了就赋值。<br>@SessionAttributes需要清除时，使用SessionStatus.setComplete();来清除。</p><p>1、  将model中的值，扔到session中</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Controller<br>@SessionAttributes(types = User.class)<br>public class LoginController &#123;<br>  @RequestMapping(&quot;/login&quot;)<br>  public String login(HttpServletRequest req,Model model,SessionStatus status)&#123;<br>      User user = new User();<br>      user.setName(&quot;李四&quot;);<br>      user.setAge(22);<br>      model.addAttribute(&quot;user&quot; , user);<br>      return &quot;forward:test.action&quot;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、  从session取出来<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RestController<br>@SessionAttributes(&quot;user&quot;)<br>public class TestController &#123;<br>  @RequestMapping(&quot;/test.action&quot;)<br>  public String  test(User user, HttpSession session)&#123;<br>      Object user2 = session.getAttribute(&quot;user&quot;);<br>      System.out.println(user2);<br>      System.out.println(user);<br>      return &quot;test&quot;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="@SessionAttribute"></a>@SessionAttribute</h4><p>这玩意是加在方法上的参数的，将session中的数据赋值给参数 。但是4.3以后的版本才支持<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RequestMapping(&quot;/&quot;)<br>public String handle(@SessionAttribute User user) &#123;<br>    // ...<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h4><p>@RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容转换为json、xml等格式的数据并绑定到controller方法的参数上<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">List.action?id=1&amp;name=zhangsan&amp;age=12<br>本例子应用：<br>@RequestBody注解实现接收http请求的json数据，将json数据转换为java对象<br>// 商品修改提交json信息，响应json信息<br>  @RequestMapping(&quot;/editItemSubmit_RequestJson&quot;)<br>  public @ResponseBody Items editItemSubmit_RequestJson(@RequestBody Items items) throws Exception &#123;<br>      System.out.println(items);<br>      //itemService.saveItem(items);<br>      return items;<br>  &#125;<br></code></pre></td></tr></table></figure></p><h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h4><p>该注解用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端</p><p>@ResponseBody注解实现将controller方法返回对象转换为json响应给客户端</p><p><strong><font color="red">使用这个注解 ，sessionAttributes注解将会失效</font></strong></p><h4 id="PathVariable（RESTful）"><a href="#PathVariable（RESTful）" class="headerlink" title="@PathVariable（RESTful）"></a>@PathVariable（RESTful）</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">用法<br>     @RequestMapping(value=&quot;/users/&#123;userId&#125;/topics/&#123;topicId&#125;&quot;)<br>     public String test(<br>     @PathVariable(value=&quot;userId&quot;) int userId, <br>     @PathVariable(value=&quot;topicId&quot;) int topicId) <br>     如请求的URL为“控制器URL/users/123/topics/456”，<br>     则自动将URL中模板变量&#123;userId&#125;和&#123;topicId&#125;绑定到<br>     通过@PathVariable注解的同名参数上，即入参后userId=123、topicId=456。<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC-Return Values返回值</title>
      <link href="/2018/10/24/Values%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
      <url>/2018/10/24/Values%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p><strong>SpringMVC-Return Values返回值</strong></p><hr><h3 id="Handler-Return-Values返回值"><a href="#Handler-Return-Values返回值" class="headerlink" title="Handler-Return Values返回值"></a>Handler-Return Values返回值</h3><h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h4><p> 返回值通过HttpMessageConverters转换并写入响应。   请参阅@ResponseBody。<br> 处理器功能处理方法的返回值作为响应体（通过HttpMessageConverter进行类型转换）；<br> 作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。<br> 使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p><h4 id="HttpEntity-ResponseEntity"><a href="#HttpEntity-ResponseEntity" class="headerlink" title="HttpEntity,ResponseEntity"></a>HttpEntity,ResponseEntity</h4><p>返回值:指定完整响应，包括HTTP标头和正文通过HttpMessageConverters转换并写入响应。 请参阅ResponseEntity。</p><h4 id="HttpHeaders"><a href="#HttpHeaders" class="headerlink" title="HttpHeaders"></a>HttpHeaders</h4><p>为了返回一个响应头和没有正文。</p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>一个视图名称，用ViewResolver解决，并与隐式模型一起使用 - 通过命令对象和@ModelAttribute方法确定。 处理程序方法也可以通过声明一个Model参数来以编程方式丰富模型。</p><h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><p>用于与隐式模型一起渲染的View实例 - 通过命令对象和@ModelAttribute方法确定。 处理程序方法也可以通过声明一个Model参数来以编程方式丰富模型。</p><h4 id="java-util-Map-org-springframework-ui-Model"><a href="#java-util-Map-org-springframework-ui-Model" class="headerlink" title="java.util.Map,org.springframework.ui.Model"></a>java.util.Map,org.springframework.ui.Model</h4><p>要通过RequestToViewNameTranslator隐式确定的视图名称添加到隐式模型的属性。</p><h4 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h4><p>要通过RequestToViewNameTranslator隐式确定的视图名称添加到模型的属性。   请注意@ModelAttribute是可选的。</p><h4 id="ModelAndView-，object"><a href="#ModelAndView-，object" class="headerlink" title="ModelAndView ，object"></a>ModelAndView ，object</h4><p>要使用的视图和模型属性，以及可选的响应状态。</p><h4 id="void"><a href="#void" class="headerlink" title="void"></a>void</h4><p>具有void返回类型（或返回值为null）的方法如果还有ServletResponse，OutputStream参数或@ResponseStatus注释，则认为它已完全处理响应。<br>如果控制器进行了积极的ETag或lastModified时间戳检查（请参阅@Controller缓存了解详细信息），情况也是如此。<br>如果以上都不是这样，那么void返回类型也可能指示REST控制器的“无响应主体”，或HTML控制器的默认视图名称选择。</p><h4 id="DeferredResult"><a href="#DeferredResult" class="headerlink" title="DeferredResult"></a><font color="red">DeferredResult</font></h4><p>从任何线程异步生成任何上述返回值 - 例如 可能是由于某些事件或回调。</p><h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a><font color="red">Callable</font></h4><p>Produce any of the above return values asynchronously in a Spring MVC managed thread. See Async Requests and Callable.使用异步线程来执行请求，然后返回给handler。</p><h4 id="ListenableFuture-java-util-concurrent-CompletionStage-java-util-concurrent-CompletableFuture"><a href="#ListenableFuture-java-util-concurrent-CompletionStage-java-util-concurrent-CompletableFuture" class="headerlink" title="ListenableFuture, java.util.concurrent.CompletionStage,   java.util.concurrent.CompletableFuture"></a>ListenableFuture, java.util.concurrent.CompletionStage,   java.util.concurrent.CompletableFuture</h4><p>在Spring MVC托管线程中异步生成上述任何返回值。</p><h4 id="ResponseBodyEmitter-SseEmitter"><a href="#ResponseBodyEmitter-SseEmitter" class="headerlink" title="ResponseBodyEmitter,   SseEmitter"></a>ResponseBodyEmitter,   SseEmitter</h4><p>用HttpMessageConverter’s异步发出一个对象流写入响应; 也支持作为ResponseEntity的主体。</p><h4 id="StreamingResponseBody"><a href="#StreamingResponseBody" class="headerlink" title="StreamingResponseBody"></a>StreamingResponseBody</h4><p>异步写入响应的OutputStream; 也支持作为ResponseEntity的主体。</p><h4 id="Reactive-types-—-Reactor-RxJava-or-others-via-ReactiveAdapterRegistry"><a href="#Reactive-types-—-Reactor-RxJava-or-others-via-ReactiveAdapterRegistry" class="headerlink" title="Reactive   types — Reactor, RxJava, or others via ReactiveAdapterRegistry"></a>Reactive   types — Reactor, RxJava, or others via ReactiveAdapterRegistry</h4><p>具有多值流的DeferredResult（例如Flux，Observable）的替代方法被收集到列表中。<br>对于流式场景 - 例如 text / event-stream，application / json +   stream - 使用SseEmitter和ResponseBodyEmitter，而在Spring MVC托管线程上执行ServletOutputStream阻塞I / O，并在每次写入完成时施加背压。</p><h4 id="Any-other-return-value"><a href="#Any-other-return-value" class="headerlink" title="Any other return  value"></a>Any other return  value</h4><p> 如果返回值与以上任何一个不匹配，默认情况下它被视为视图名称，如果它是String或void（通过RequestToViewNameTranslator应用的默认视图名称选择）; 或者作为要添加到模型的模型属性，除非它是一个简单的类型，由BeanUtils＃isSimpleProperty确定，在这种情况下，它仍然未解决。</p><hr><h3 id="返回ModelAndView-Model"><a href="#返回ModelAndView-Model" class="headerlink" title="返回ModelAndView/Model"></a>返回ModelAndView/Model</h3><p>controller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view。</p><p>Model与ModelAndView的传递效果是一样的，且传递是数据不能是引用类型。<br>重定向时，会把数据拼接到Url后面</p><p>@返回void </p><p>啥也不做 - -</p><hr><p>返回字符串</p><p>这玩意需要用到@ResponseBody注解</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@RestController<br>public class TestController &#123;<br>  @RequestMapping(&quot;/test.action&quot;)<br>  public String  test( int ids)&#123;<br>      System.out.println(&quot;id:&quot;+ids);<br>      return &quot;this is test&quot;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑视图名</p><p>这玩意需要你配置视图解析器</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">INF/jsp/item/editItem.jsp<br>return &quot;item/editItem&quot;;<br></code></pre></td></tr></table></figure><p>Redirect重定向</p><p>Contrller方法返回结果重定向到一个url地址，如下商品修改提交后重定向到商品查询方法，参数无法带到商品查询方法中.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//重定向到queryItem.action地址,request无法带过去<br>return &quot;redirect:queryItem.action&quot;;<br></code></pre></td></tr></table></figure></p><p>redirect方式相当于“response.sendRedirect()”，转发后浏览器的地址栏变为转发后的地址，因为转发即执行了一个新的request和response。</p><p>由于新发起一个request原来的参数在转发时就不能传递到下一个url，如果要传参数可以/item/queryItem.action后边加参数，如下：</p><p>/item/queryItem?…&amp;…..</p><p>对于model设置的值，重定向会拼接到？key=value…. 版本4.3以后好像改了，记不太清了，你们可以自己去玩一下</p><hr><p>forward转发</p><p>跟Redirect一样的用法，不同的是 转发可以传递参数<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//结果转发到editItem.action，request可以带过去<br>return &quot;forward:editItem.action&quot;;<br>forward方式相当于“request.getRequestDispatcher().forward(request,response)”，转发后浏览器地址栏还是原来的地址。转发并没有执行新的request和response，而是和转发前的请求共用一个request和response。所以转发前请求的参数在转发后仍然可以读取到。<br>带域的返回<br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC架构与流程</title>
      <link href="/2018/10/24/SpringMVC%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/10/24/SpringMVC%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>SpringMVC架构与流程</strong></p><p>前言：</p><p>顾名思义SpringMVC是一个基于MVC设计思想的框架。</p><p>什么是mvc？MVC是模型(model)－视图(view)－控制器(controller)的缩写 ，是一种软件设计思想，主要的作用就是解决应用开发的耦合性，将应用的输入、控制、输出进行强制解耦。</p><p>mvc中的模型、视图、控制器分别担负着不同的角色：</p><p>模型：页数的数据和业务的处理。我们平常用的service和dao层就属于这一层面</p><p>视图：只用于用户的显示，不进行任何的业务处理。主要用来获取和显示数据</p><p>控制器：控制视图层与用户的交互，将对应的操作调用对应的模型。简单的说，就是管理交互的</p><p>理解了mvc，我们就来说一说mvc的执行过程：用户通过view层向服务器发出请求，controller接收请求后，调用对应的model后获取数据，控制器在将数据返回给view。</p><p><strong>好了，我们可以进入正题了，既然SpringMVC是基于MVC的软件设计思想的框架，我们就先看一下SpringMVC的M、V、C分别是什么</strong></p><p><img src="/images/20181024152707.png"></p><p>上图里的东西我们不用细看，只需要大概晓得对应的mvc是啥的就行</p><p>M:这里的模型指定是具体执行的Handler(Controller)。</p><p>V:就是试图View</p><p>C:指的的前端控制器</p><p><strong>了解的springMVC的架构思想（mvc），我就开始继续深入的学习springmvc的执行流程吧。</strong></p><p>下面的顺序并不代表图中的顺序：</p><p>用户将请求发送给前端控制器（DispatcherServlet）也就是SpringMVC的控制器</p><p>然后 前端控制器 请求调用HandlerMapper（处理器映射器）</p><p>处理器映射器 根据请求的url返回 Handler和处理器拦截器（如果有）给前端控制器（DispatcherServlet）</p><p>前端控制器（DispatcherServlet）找到合适的 处理器适配器(HanderAdatper)，由处理器适配器调用Handler</p><p>Handler（以后统称为Controller）执行操作，Handler通常就是我们定义的controller(这里的controller是springmvc的model层),执行完后返回ModelAndView</p><p>处理器映射器(HanderAdatper)将ModelAndView返回给 前端控制器</p><p>然后 前端控制器将ModelAndView 传递给 视图解析器（ViewReslover )</p><p>视图解析器解析（ViewReslover )后 返回具体view，给前端控制器（DispatcherServlet）</p><p>前端控制器（DispatcherServlet）对视图进行渲染（将数据填充到视图中）</p><p>前端控制器（DispatcherServlet）将视图返回给用户。</p><hr><p>了解了流程，我们在详细了解一下里面讲到的部件：</p><p>前端控制器（DispatcherServlet）：这玩意是 SpringMVC的入口（实际上呢就是一个Servlet对象），所有的请求都要通过它，因为是个Servlet所以不可避免的你要在web.xml进行配置(Servlet3.0以后，可以不使用web.xml配置文件了)。</p><p>处理器映射器(HandlerMapper)，这个玩意就是根据不同的方式找到处理器（Handler），它支持的有配置文件形式，接口形式，注解形式等等</p><p>处理器适配器（HandlAdapter ）这玩意就是 分析处理器是那种方式的处理器（配置文件，接口、注解等形式）然后执行Handler</p><p>ModelAndView 封装了数据和视图信息，如果想进行页面的数据交互，可以选择这玩意进行传输，数据的存放位置，默认的是Request域</p><p>视图解析器（ViewResolver ），负责将处理结果生成View视图。</p><p>视图（View ） SpringMVC提供了很多视图，比如jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp</p><hr><p><strong>在spring-mvc.xml文件中配置：</strong><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!-- 配置处理器映射器 --&gt;<br>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;<br>&lt;!-- 配置处理器适配器 --&gt;<br>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt; <br>为什么这么配置spring就能用呢？因为spring对bean的加载有一个顺序，同名称的spring只会认第一次加载的bean，也就是配置文件最先配置的bean<br></code></pre></td></tr></table></figure></p><p><strong>当然了还有更简洁的配置，添加这个配置即可 mvc:annotation-driven</strong><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;<br>       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;<br>       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd<br>        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd<br>        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;<br>    &lt;context:component-scan base-package=&quot;com.lifeibai&quot;/&gt;<br>    &lt;mvc:annotation-driven/&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_16</title>
      <link href="/2018/10/23/spring-annotation-day-16/"/>
      <url>/2018/10/23/spring-annotation-day-16/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring容器的创建过程</strong></p><p>今天，我们来统一学习一下，Spring容器的整个创建过程。</p><hr><p><strong>Spring容器的refresh()[创建刷新]</strong></p><h3 id="prepareRefresh-【刷新前的预处理】"><a href="#prepareRefresh-【刷新前的预处理】" class="headerlink" title="prepareRefresh();【刷新前的预处理】"></a>prepareRefresh();【刷新前的预处理】</h3><p>1）initPropertySources();初始化一些属性设置；子类自定义个性化的属性设置方法；<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined"> protected void initPropertySources() &#123;<br> // For subclasses: do nothing by default.<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2)  getEnvironment().validateRequiredProperties();检验属性的合法性等</p><p>3）earlyApplicationEvents = new LinkedHashSet<applicationevent>();保存容器的一些早期的事件；</applicationevent></p><h3 id="obtainFreshBeanFactory；【获取BeanFactory】"><a href="#obtainFreshBeanFactory；【获取BeanFactory】" class="headerlink" title="obtainFreshBeanFactory；【获取BeanFactory】"></a>obtainFreshBeanFactory；【获取BeanFactory】</h3><p>1）refreshBeanFactory();刷新BeanFactory<br>创建 this.beanFactory = new DefaultListableBeanFactory();<br>设置id。</p><p>2）getBeanFactory();<br>返回GenericApplicationContext创建的beanFactory对象;return this.beanFactory;</p><p>3)将创建好的BeanFactory【GenericApplicationContext】对象返回；</p><h3 id="prepareBeanFactory-beanFactory"><a href="#prepareBeanFactory-beanFactory" class="headerlink" title="prepareBeanFactory(beanFactory);"></a>prepareBeanFactory(beanFactory);</h3><p>BeanFactory的预准备工作（BeanFactory进行一些设置）</p><p>1）设置BeanFactory的类加载、支持表达式解析器····</p><p>2）添加部分BeanPostProcessor【ApplicationContextAwareProcessor】</p><p>3）设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、ResourceLoaderAware等</p><p>4）注册可以解析的自动装配：我们能直接在任何组件中自动注入：BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext。</p><p>5）添加BeanPostProcessor【ApplicationListenerDetector】</p><p>6）添加编译时Aspectj<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined"> // Detect a LoadTimeWeaver and prepare for weaving, if found.<br>if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;<br>beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));<br>// Set a temporary ClassLoader for type matching.<br>beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));<br>&#125;<br></code></pre></td></tr></table></figure></p><p>7) 给BeanFactory中注册一些能用的组件</p><p>environment【ConfigurableEnvironment】</p><p>systemProperties【Map&lt;String, Object&gt;】</p><p>systemEnvironment【Map&lt;String, Object&gt;】</p><h3 id="postProcessBeanFactory-beanFactory"><a href="#postProcessBeanFactory-beanFactory" class="headerlink" title="postProcessBeanFactory(beanFactory);"></a>postProcessBeanFactory(beanFactory);</h3><p>BeanFactory准备工作完成后进行的后置处理工作<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>子类通过覆写这个方法来在BeanFactory创建并准备完成以后做进一步的设置。</p><div style="text-align: center;"><font color="#00ffff" size="4">以上是BeanFactory的创建以及准备工作</font></div><hr><h3 id="invokeBeanFactoryPostProcessors-beanFactory"><a href="#invokeBeanFactoryPostProcessors-beanFactory" class="headerlink" title="invokeBeanFactoryPostProcessors(beanFactory);"></a>invokeBeanFactoryPostProcessors(beanFactory);</h3><p>执行BeanFactoryPostProcessor</p><p>BeanFactoryPostProcessor：BeanFactory的后置处理器。在BeanFactory标准化初始化之后执行。</p><p>两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor。</p><p>一、执行BeanFactoryPostProcessor的方法：</p><p><strong>先执行BeanDefinitionRegistryPostProcessor</strong></p><p>1）获取所有的BeanDefinitionRegistryPostProcessor  </p><p>2）先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor<br>postProcessor.postProcessBeanDefinitionRegistry(registry);</p><p>3）再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor<br>postProcessor.postProcessBeanDefinitionRegistry(registry);</p><p>4）最后执行没有实现任何优先级或者顺序接口的BeanDefinitionRegistryPostProcessor<br>postProcessor.postProcessBeanDefinitionRegistry(registry);</p><p><strong>后执行BeanFactoryPostProcessor的方法</strong></p><p>1）获取所有的BeanFactoryPostProcessor</p><p>2）先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor<br>postProcessor.postProcessBeanFactory();</p><p>3）再执行实现了Ordered顺序接口的BeanFactoryPostProcessor<br>postProcessor.postProcessBeanFactory();</p><p>4）最后执行没有实现任何优先级或者顺序接口的BeanFactoryPostProcessor<br>postProcessor.postProcessBeanFactory();</p><h3 id="registerBeanPostProcessors（BeanFactory）"><a href="#registerBeanPostProcessors（BeanFactory）" class="headerlink" title="registerBeanPostProcessors（BeanFactory）"></a>registerBeanPostProcessors（BeanFactory）</h3><p>注册BeanPostProcessor（Bean的后置处理器）【Intercept bean creation.】</p><p>不同类型的BeanPostProcessor：在Bean的创建前后的执行顺序是不同的</p><p>DestructionAwareBeanPostProcessor</p><p>InstantiationAwareBeanPostProcessor</p><p>MergedBeanDefinitionPostProcessor【internalPostProcessor】</p><p>SmartInstantiationAwareBeanPostProcessor</p><p>1）获取所有的BeanPostProcessor；后置处理器默认都可以通过PriorityOrdered、Ordered接口来执行优先级</p><p>2）先注册PriorityOrdered优先级接口的BeanPostProcessor；把每一个BeanPostProcessor添加到BeanFactory中</p><p>3）再注册Ordered</p><p>4）注册其他的没有实现任何接口的BeanPostProcessor</p><p>5）最终注册MergedBeanDefinitionPostProcessor</p><p>6）注册一个ApplicationListenerDetector；来在Bean创建后检查是否是ApplicationListener，如果是，就添加到容器中：applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</p><h3 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource();"></a>initMessageSource();</h3><p>初始化MessageSource组件，做国家化功能；消息绑定；消息解析。</p><p>1）获取BeanFactory</p><p>2）看容器中是否有id=messageSource，类型是MessageSource的组件。如果有就赋值给messageSource，如果没有就自己创建一个DelegatingMessageSource组件。</p><p>MessageSource：取出国际化配置文件中的某个key的值；能按照区域信息获取。</p><p>3）把创建好的messageSource注册到容器中，以后获取国际化配置文件时，可以自动注入MessageSource</p><h3 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster();"></a>initApplicationEventMulticaster();</h3><p>初始化事件派发器</p><p>1）获取BeanFactory</p><p>2）从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster</p><p>3）如果上一步没有配置，就创建一个SimpleApplicationEventMulticaster</p><p>4）将创建好的ApplicationEventMulticaster添加到容器中，以后其他组件直接自动注入</p><h3 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh();"></a>onRefresh();</h3><p>留给子类，重写onRefresh()方法.在容器刷新的时候自定义逻辑。</p><h3 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners();"></a>registerListeners();</h3><p>给容器中将所有项目里面的ApplicationListener注册进来</p><p>1）从容器中拿到所有的ApplicationListener组件</p><p>2）将每个监听器添加到事件派发器中：getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</p><p>3）派发之前步骤中产生的事件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;<br>this.earlyApplicationEvents = null;<br>if (earlyEventsToProcess != null) &#123;<br>for (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;<br>getApplicationEventMulticaster().multicastEvent(earlyEvent);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="finishBeanFactoryInitialization-beanFactory"><a href="#finishBeanFactoryInitialization-beanFactory" class="headerlink" title="finishBeanFactoryInitialization(beanFactory);"></a>finishBeanFactoryInitialization(beanFactory);</h3><p>初始化所有的剩下的单实例Bean对象</p><p>1）beanFactory.preInstantiateSingletons();初始化剩下的单实例Bean</p><p>1.1 获取容器中的所有Bean，依次初始化和创建对象</p><p>1.2 获取Bean的定义信息：RootBeanDefinition</p><p>1.3 Bean不是抽象的、是单实例、是懒加载<br>1.3.1 判断是不是FactoryBean；是否是实现FactoryBean接口的Bean<br>1.3.2 不是工厂Bean，就利用getBean()获取Bean对象。 </p><hr><p>1.3.2.1）getBean(beanName);ioc.getBean();</p><p>1.3.2.2) doGetBean(name,null,null,false);</p><p>1.3.2.3) 先获取缓存中保存的单实例bean。如果能获取说明这个Bean之前创建过（所有创建过的单实例Bean都会被保存起来）</p><p>1.3.2.4）缓存中获取不到，开始Bean的创建对象流程</p><p>1.3.2.5）标记当前Bean已经被创建，防止多线程下创建多个单实例Bean</p><p>1.3.2.6）获取Bean的定义信息</p><p>1.3.2.7）获取当前Bean依赖的其他Bean；如果有按照getBean()把依赖的Bean先创建出来；</p><p>1.3.2.8）启动单实例Bean的创建过程：</p><hr><p>1.3.2.8.1) createBean(beanName,mbd,args)</p><p>1.3.2.8.2) resolveBeforeInstantiation(beanName, mbdToUse);让BeanPostProcessor在Bean的创建之前执行，是InstantiationAwareBeanPostProcessor类型的后置处理器。看是否是需要创建代理对象。</p><p>先触发applyBeanPostProcessorsBeforeInstantiation：postProcessBeforeInstantiation()</p><p>如果有返回值：applyBeanPostProcessorsAfterInitialization：postProcessAfterInitialization()</p><p>1.3.2.8.3)如果前面InstantiationAwareBeanPostProcessor没有返回值，说明不需要创建代理对象。</p><p>1.3.2.8.4)Object beanInstance = doCreateBean(beanName, mbdToUse, args);创建Bean</p><hr><p>1.3.2.8.4.1) instanceWrapper = createBeanInstance(beanName, mbd, args);创建Bean对象；利用工厂方法或者构造器创建出Bean对象</p><p>1.3.2.8.4.2) applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);</p><p>1.3.2.8.4.3) 【属性赋值】populateBean(beanName, mbd, instanceWrapper);</p><hr><p>赋值之前：<br>1.3.2.8.4.3.1) InstantiationAwareBeanPostProcessor后置处理器；<br>postProcessAfterInstrantiation();</p><p>1.3.2.8.4.3.2) InstantiationAwareBeanPostProcessor后置处理器；<br>postProcessPropertyValues();</p><p>赋值之后：<br>1.3.2.8.4.3.3) 应用Bean属性的值：为属性利用setter方法等进行赋值<br>applyPropertyValues(beanName, mbd, bw, pvs);</p><p>1.3.2.8.4.4) 【Bean初始化】initializeBean(beanName, exposedObject, mbd)；</p><hr><p>1.3.2.8.4.4.1) 【执行Aware接口方法】invokeAwareMethods(beanName, bean);<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">   if (bean instanceof Aware) &#123;<br>if (bean instanceof BeanNameAware) &#123;<br>((BeanNameAware) bean).setBeanName(beanName);<br>&#125;<br>if (bean instanceof BeanClassLoaderAware) &#123;<br>((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());<br>&#125;<br>if (bean instanceof BeanFactoryAware) &#123;<br>((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>1.3.2.8.4.4.2) 【执行后置处理器初始化之前】 </p><p>applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>beanProcessor.postProcessBeforeInitialization(result, beanName);</p><p>1.3.2.8.4.4.3)【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);</p><hr><p>1.3.2.8.4.4.3.1) 是否是InitializingBean接口的实现；执行接口规定的初始化</p><p>1.3.2.8.4.4.3.2) 是否自定义初始化方法：invokeCustomInitMethod(beanName, bean, mbd);</p><hr><p>1.3.2.8.4.4.4)【执行后置处理器初始化之后】  </p><p>applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>beanProcessor.postProcessAfterInitialization(result, beanName);</p><p>1.3.2.8.4.5)【注册Bean的销毁方法】：DisposableBeanAdapter</p><p>1.3.2.8.5）将创建的Bean添加到缓存中singletonObjects；<br>ioc容器就是这些Map：很多的Map里面保存了单实例Bean，环境信息····</p><p>所有的Bean都利用getBean()创建完后：<br> 检查所有的Bean是否是SmartInitializingSingleton接口类型；如果是，就执行afterSingletonsInstantion()方法</p><h3 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh();"></a>finishRefresh();</h3><p>完成BeanFactory的初始化创建工作；IoC容器就创建完了。</p><p>1）initLifecycleProcessor();初始化和生命周期有关的后置处理器：LifecycleProcessor</p><p>默认从容器中找是否是lifecycleProcessor的组件；如果没有，创建一个默认的 new DefaultLifecycleProcessor()；并加入到容器中。</p><p>2）getLifecycleProcessor().onRefresh();</p><p>拿到前面定义的生命周期处理器，并回调onRefresh()方法。</p><p>3）publishEvent(new ContextRefreshedEvent(this));发布容器刷新完成事件。</p><p>4）LiveBeansView.registerApplicationContext(this);</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1）<strong>Spring容器在启动的时候，先会保存所有注册进来的Bean定义信息。</strong></p><p>1.1 xml注册的bean；<bean></bean></p><p>1.2 注解注册Bean:@Bean、@Service、@Component、XXX</p><p>2）<strong>Spring容器会在合适的时候创建这些Bean</strong></p><p>2.1 用到这个bean的时候，利用getBean创建bean；创建好以后保存在容器中；</p><p>2.2 统一创建剩下的所有单实例bean；finishBeanFactoryInitialization(beanFactory);</p><p>3）<strong>后置处理器</strong></p><p>每个bean创建完后，都会使用各种后置处理器进行处理；来增强bean的功能；  </p><p>AutowiredAnnotationBeanPostProcessor：处理自动注入</p><p>AnnotationAwareAspectJAutoProxyCreator：来做AOP功能</p><p>XXX····</p><p>增强的功能注解：</p><p>AsyncAnnotationBeanPostProcessor</p><p>4）<strong>事件驱动模型：</strong></p><p>ApplicationListener：事件监听器</p><p>ApplicationEventMulticaster：事件派发</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_15</title>
      <link href="/2018/10/22/spring-annotation-day-15/"/>
      <url>/2018/10/22/spring-annotation-day-15/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong> </p><p>今天，来讲解其他的扩展原理，帮助大家学习其他的小知识点</p><h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>BeanPostProcessor：bean的后置处理器，bean创建对象初始化前后进行拦截工作的。  </p><p>BeanFactoryPostProcessor：BeanFactory的后置处理器，在BeanFactory标准初始化之后调用，来定制和修改BeanFactory的内容，所有的Bean的定义已经保存加载到BeanFactory，<strong>但是bean的实例还没有创建</strong>。</p><h4 id="创建ExConfig配置类："><a href="#创建ExConfig配置类：" class="headerlink" title="创建ExConfig配置类："></a>创建ExConfig配置类：</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(&quot;com.liuzhuo.ext&quot;)<br>public class ExtConfig &#123;<br><br>    @Bean<br>    public Blue blue() &#123;<br>        return new Blue();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建自定义的BeanFactoryPostProcessor："><a href="#创建自定义的BeanFactoryPostProcessor：" class="headerlink" title="创建自定义的BeanFactoryPostProcessor："></a>创建自定义的BeanFactoryPostProcessor：</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;<br>    /**<br>     * @param beanFactory<br>     * @throws BeansException<br>     * 在BeanFactory标准初始化之后调用，来定制和修改BeanFactory的内容，<br>     * 此时，所有的bean的定义信息已经保存到BeanFactory，但是Bean还没有创建<br>     */<br>    @Override<br>    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;<br><br>        System.out.println(&quot;postProcessBeanFactory·······&quot;);<br><br>        int count = beanFactory.getBeanDefinitionCount();<br>        String[] names = beanFactory.getBeanDefinitionNames();<br>        for (String name : names) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建新的测试类："><a href="#创建新的测试类：" class="headerlink" title="创建新的测试类："></a>创建新的测试类：</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IoCTest_EXT &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ExtConfig.class);<br>        applicationContext.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运行："><a href="#运行：" class="headerlink" title="运行："></a>运行：</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">postProcessBeanFactory·······<br>org.springframework.context.annotation.internalConfigurationAnnotationProcessor<br>org.springframework.context.annotation.internalAutowiredAnnotationProcessor<br>org.springframework.context.annotation.internalRequiredAnnotationProcessor<br>org.springframework.context.annotation.internalCommonAnnotationProcessor<br>org.springframework.context.event.internalEventListenerProcessor<br>org.springframework.context.event.internalEventListenerFactory<br>extConfig<br>myBeanFactoryPostProcessor<br>blue<br></code></pre></td></tr></table></figure><p><strong>能看到，我们获取了所有的BeanFactory中定义的bean了，但是还没有创建bean的实例对象</strong>。</p><h4 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h4><p>给MyBeanFactoryPostProcessor中的postProcessBeanFactory方法加上断点，并运行。</p><p>过程：<br>1）加载容器。<br>2）refresh();刷新容器<br>3）invokeBeanFactoryPostProcessors(beanFactory);<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>public void refresh() throws BeansException, IllegalStateException &#123;<br>    <br>    try &#123;<br>// Allows post-processing of the bean factory in context subclasses.<br>postProcessBeanFactory(beanFactory);<br><br>// Invoke factory processors registered as beans in the context.<br>invokeBeanFactoryPostProcessors(beanFactory);<br><br>// Register bean processors that intercept bean creation.<br>registerBeanPostProcessors(beanFactory);<br><br>// Initialize message source for this context.<br>initMessageSource();<br><br>// Initialize event multicaster for this context.<br>initApplicationEventMulticaster();<br><br>// Initialize other special beans in specific context subclasses.<br>onRefresh();<br><br>// Check for listener beans and register them.<br>registerListeners();<br><br>// Instantiate all remaining (non-lazy-init) singletons.<br>finishBeanFactoryInitialization(beanFactory);<br><br>// Last step: publish corresponding event.<br>finishRefresh();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>能发现，invokeBeanFactoryPostProcessors(beanFactory);是在finishBeanFactoryInitialization(beanFactory);方法之前的，就说明了BeanFactoryPostProcessor是在bean的实例化之前的，是在BeanFactory实例化之后的。</p><hr><h3 id="BeanDefinitionRegisterPostProcessor"><a href="#BeanDefinitionRegisterPostProcessor" class="headerlink" title="BeanDefinitionRegisterPostProcessor"></a>BeanDefinitionRegisterPostProcessor</h3><p>BeanDefinitionRegisterPostProcessor extends BeanFactoryPostProcessor</p><p>在所有bean定义信息将要被加载，bean实例还未创建。</p><p>优先于BeanFactoryPostProcessor执行<br>利用BeanDefinitionRegisterPostProcessor给容器中再额外添加一些组件。</p><p>原理：<br>1）ioc创建对象<br>2）refresh() -&gt; invokeBeanFactoryPostProcessors(beanFactory);<br>3) 从容器中获取所有的BeanDefinitionRegisterPostProcessor组件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1)依次触发所有的postProcessorBeanDefinitionRegistry()方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)再次触发postProcessorBeanFactory()方法的BeanFactoryPostProcessor；<br>4）再来从容器中找到BeanFactoryPostProcessor组件；然后依次触发postProcessorBeanFactory()方法</p><h4 id="创建MyBeanDefinitionRegisterPostProcessor类："><a href="#创建MyBeanDefinitionRegisterPostProcessor类：" class="headerlink" title="创建MyBeanDefinitionRegisterPostProcessor类："></a>创建MyBeanDefinitionRegisterPostProcessor类：</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class MyBeanDefinitionRegisterPostProcessor implements BeanDefinitionRegistryPostProcessor &#123;<br><br>    //先执行<br>    @Override<br>    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;<br>        System.out.println(&quot;postProcessBeanDefinitionRegistry······&quot;);<br><br>        int count = registry.getBeanDefinitionCount();<br>        System.out.println(&quot;容器中注册的bean的个数(1)：&quot; + count);<br><br>        //还能注册新的bean组件<br>        RootBeanDefinition beanDefinition = new RootBeanDefinition(Blue.class);<br>        registry.registerBeanDefinition(&quot;hello&quot;, beanDefinition);<br>    &#125;<br><br>    //后执行<br>    @Override<br>    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;<br><br>        System.out.println(&quot;postProcessBeanFactory··········&quot;);<br>        int count = beanFactory.getBeanDefinitionCount();<br>        System.out.println(&quot;容器中注册的bean的个数(2)：&quot; + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运行测试类"><a href="#运行测试类" class="headerlink" title="运行测试类:"></a>运行测试类:</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 22, 2018 11:32:15 上午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 11:32:15 CST 2018]; root of context hierarchy<br>postProcessBeanDefinitionRegistry······<br>容器中注册的bean的个数(1)：10<br>postProcessBeanFactory··········<br>容器中注册的bean的个数(2)：11<br><br>十月 22, 2018 11:32:15 上午 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &lt;init&gt;<br>信息: JSR-330 &apos;javax.inject.Inject&apos; annotation found and supported for autowiring<br>postProcessBeanFactory·······<br>org.springframework.context.annotation.internalConfigurationAnnotationProcessor<br>org.springframework.context.annotation.internalAutowiredAnnotationProcessor<br>org.springframework.context.annotation.internalRequiredAnnotationProcessor<br>org.springframework.context.annotation.internalCommonAnnotationProcessor<br>org.springframework.context.event.internalEventListenerProcessor<br>org.springframework.context.event.internalEventListenerFactory<br>extConfig<br>myBeanDefinitionRegisterPostProcessor<br>myBeanFactoryPostProcessor<br>blue<br>hello<br><br>十月 22, 2018 11:32:15 上午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 11:32:15 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure><p>能发现<br>1）首先执行BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法<br>2）再执行BeanDefinitionRegistryPostProcessor的postProcessBeanFactory()方法<br>3）最后执行BeanFactoryPostProcessor的postProcessBeanFactory()方法</p><h4 id="调试-原理"><a href="#调试-原理" class="headerlink" title="调试(原理)"></a>调试(原理)</h4><p>给MyBeanDefinitionRegisterPostProcessor的postProcessBeanDefinitionRegistry()方法打上断点，并debug。</p><p>1）加载容器<br>2）refresh();刷新容器<br>3）invokeBeanFactoryPostProcessors(beanFactory);和BeanFactoryPostProcessor的流程一样<br>4）invokeBeanFactoryPostProcessors()</p><p>在invokeBeanFactoryPostProcessors()方法中，可以看到<br>1）首先获取所有的BeanDefinitionRegistryPostProcessor的定义信息<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">String[] postProcessorNames =<br>beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);<br>for (String ppName : postProcessorNames) &#123;<br>if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br>currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br>processedBeans.add(ppName);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2）然后调用invokeBeanDefinitionRegistryPostProcessors()方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">private static void invokeBeanDefinitionRegistryPostProcessors(<br>Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry) &#123;<br><br>for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;<br>postProcessor.postProcessBeanDefinitionRegistry(registry);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 再调用invokeBeanFactoryPostProcessors：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">private static void invokeBeanFactoryPostProcessors(<br>Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory) &#123;<br><br>for (BeanFactoryPostProcessor postProcessor : postProcessors) &#123;<br>postProcessor.postProcessBeanFactory(beanFactory);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 获取所有的BeanFactoryPostProcessor的定义信息<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">String[] postProcessorNames =<br>beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);<br></code></pre></td></tr></table></figure></p><p>5）调用invokeBeanFactoryPostProcessors：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">private static void invokeBeanFactoryPostProcessors(<br>Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory) &#123;<br><br>for (BeanFactoryPostProcessor postProcessor : postProcessors) &#123;<br>postProcessor.postProcessBeanFactory(beanFactory);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><h3 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener:"></a>ApplicationListener:</h3><p>监听容器中发布的事件。事件驱动模型开发。</p><p>步骤：</p><p>1）写一个监听器(ApplicationListener实现类)来监听某个事件(ApplicationEvent及其子类)</p><p>2) 把监听器加入到容器中</p><p>3）只要容器中有相关事件的发布，我们就能监听到这个事件</p><p>4）发布一个事件: applicationContext.publishEvent();</p><h4 id="编写一个MyApplicationListener"><a href="#编写一个MyApplicationListener" class="headerlink" title="编写一个MyApplicationListener"></a>编写一个MyApplicationListener</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class MyApplicationListener implements ApplicationListener&lt;ApplicationEvent&gt; &#123;<br>    @Override<br>    public void onApplicationEvent(ApplicationEvent event) &#123;<br>        System.out.println(&quot;监听:&quot; + event);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运行测试类："><a href="#运行测试类：" class="headerlink" title="运行测试类："></a>运行测试类：</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 22, 2018 8:42:11 下午 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &lt;init&gt;<br>信息: JSR-330 &apos;javax.inject.Inject&apos; annotation found and supported for autowiring<br>监听:org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:42:11 CST 2018]; root of context hierarchy]<br><br>十月 22, 2018 8:42:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:42:11 CST 2018]; root of context hierarchy<br>监听:org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:42:11 CST 2018]; root of context hierarchy]<br></code></pre></td></tr></table></figure><p>说明容器，为我们发布了两个事件：ContextRefreshedEvent 和 ContextClosedEvent</p><h4 id="发布自己的事件"><a href="#发布自己的事件" class="headerlink" title="发布自己的事件"></a>发布自己的事件</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ExtConfig.class);<br><br>        applicationContext.publishEvent(new ApplicationEvent(new String(&quot;自定义事件&quot;)) &#123;<br>        &#125;);<br><br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">监听:org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:47:38 CST 2018]; root of context hierarchy]<br>监听:com.liuzhuo.test.IoCTest_EXT$1[source=自定义事件]<br>监听:org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:47:38 CST 2018]; root of context hierarchy]<br></code></pre></td></tr></table></figure></p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>1）初始化容器；refresh();</p><p>2）finishRefresh();  // Last step: publish corresponding event.</p><p>3）publishEvent(new ContextRefreshedEvent(this));发布事件</p><p>4）getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);获取派发器</p><p>5）获取所有的ApplicationListener：for (final ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type))</p><p>6）如果有Executor，可以支持使用Executor进行异步派发，否则，使用同步方式直接执行invokeListener(listener, event);</p><p>7）doInvokeListener(listener, event);回调listener.onApplicationEvent(event);</p><p>我们这里的三个事件：  </p><p>1）finishRefresh();容器刷新完成后，执行ContextRefreshedEvent事件。</p><p>2）自己发布的事件</p><p>3）容器关闭会发布ContextClosedEvent事件</p><hr><p>事件派发器(EventMulticaster)：</p><p>1）容器创建对象；refresh();</p><p>2）initApplicationEventMulticaster();初始化事件派发器</p><p>3）先去查看容器中是否有id=“applicationEventMulticaster”组件，如果有直接使用，没有的话，new SimpleApplicationEventMulticaster()组件。并且加入到容器中。我们就可以在其他组件要派发事件时，自动注入这个applicationEventMulticaster组件。</p><hr><p>容器中有哪些监听器：</p><p>1）容器创建对象；refresh();</p><p>2）registerListeners(); //注册监听器<br>从容器中拿到所有的监听器，把它们注册到applicationEventMulticaster中。<br>String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);<br>getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</p><h3 id="EventListener"><a href="#EventListener" class="headerlink" title="@EventListener"></a>@EventListener</h3><p>@EventListener注解，可以使普通类的普通方法来监听事件，不用去实现ApplicationEvent接口。</p><p>1）在com.liuzhuo.ext包下，创建UserService类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class UserService &#123;<br><br>    @EventListener(value = &#123;ApplicationEvent.class&#125;)<br>    public void listen(ApplicationEvent event) &#123;<br>        System.out.println(&quot;UserService监听:&quot; + event);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 运行IoCTest_EXT测试类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">UserService监听:org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Tue Oct 23 09:52:08 CST 2018]; root of context hierarchy]<br>监听:org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Tue Oct 23 09:52:08 CST 2018]; root of context hierarchy]<br>UserService监听:com.liuzhuo.test.IoCTest_EXT$1[source=自定义事件]<br>监听:com.liuzhuo.test.IoCTest_EXT$1[source=自定义事件]<br>UserService监听:org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Tue Oct 23 09:52:08 CST 2018]; root of context hierarchy]<br>监听:org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Tue Oct 23 09:52:08 CST 2018]; root of context hierarchy]<br></code></pre></td></tr></table></figure></p><p>3) 原理：</p><p>@EventListener使用EventListenerMethodProcessor处理器来完成的<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">* @author Stephane Nicoll<br> * @since 4.2<br> * @see EventListenerMethodProcessor<br> */<br>@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>public @interface EventListener<br></code></pre></td></tr></table></figure></p><p>点击EventListenerMethodProcessor处理器：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class EventListenerMethodProcessor implements SmartInitializingSingleton, ApplicationContextAware<br></code></pre></td></tr></table></figure></p><p>实现了SmartInitializingSingleton接口，所有重点是SmartInitializingSingleton接口。</p><p>点击SmartInitializingSingleton接口：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public interface SmartInitializingSingleton &#123;<br><br>/**<br> * Invoked right at the end of the singleton pre-instantiation phase,<br> * with a guarantee that all regular singleton beans have been created<br> * already. &#123;@link ListableBeanFactory#getBeansOfType&#125; calls within<br> * this method won&apos;t trigger accidental side effects during bootstrap.<br> * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; This callback won&apos;t be triggered for singleton beans<br> * lazily initialized on demand after &#123;@link BeanFactory&#125; bootstrap,<br> * and not for any other bean scope either. Carefully use it for beans<br> * with the intended bootstrap semantics only.<br> */<br>void afterSingletonsInstantiated();<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>其中有一个方法：afterSingletonsInstantiated(); 该方法是在所有的单实例初始化完成后才调用的。</p><p>调试：<br>给UserService类打上断点，并debug。</p><p>1）ioc容器创建对象；refresh();刷新容器</p><p>2）finishBeanFactoryInitialization(beanFactory)；初始化剩下的单实例bean</p><p>3）先创建所有的单实例bean；getBean();</p><p>4) 获取所有创建好的单实例bean，判断是否是SmartInitializingSingleton类型的，如果是就调用afterSingletonsInstantiated()方法</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_14</title>
      <link href="/2018/10/20/spring-annotation-day-14/"/>
      <url>/2018/10/20/spring-annotation-day-14/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong> </p><p>今天来学习Spring的声明式事务。</p><h3 id="不使用事务"><a href="#不使用事务" class="headerlink" title="不使用事务"></a>不使用事务</h3><p>环境搭建</p><p>1）导入相关依赖</p><p>数据源、数据驱动、Spring-jdbc模块.<br>数据源、数据驱动之前已经导入过，现在只需要Spring-jdbc模块.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;<br>    &lt;version&gt;5.1.1.RELEASE&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>2）创建com.liuzhuo.tx包，并创建TxConfig类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(&quot;com.liuzhuo.tx&quot;)<br>public class TxConfig &#123;<br><br>    //c3p0的数据源<br>    @Bean<br>    public DataSource dataSource() throws Exception &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(&quot;root&quot;);<br>        dataSource.setPassword(&quot;123456&quot;);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8&quot;);<br>        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);<br>        return dataSource;<br>    &#125;<br><br>    //注入jdbcTemplate模板<br>    @Bean<br>    public JdbcTemplate jdbcTemplate() throws Exception &#123;<br>        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource());<br>        return jdbcTemplate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>注意，这里的数据链接url，必须加上?serverTimezone=GMT%2B8，这是在使用MySQL 8.0以上版本时候必须加上的，否则会出现时区问题！！！！</strong></p><p>3）在com.liuzhuo.tx包下，创建UserService和UserDao类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class UserService &#123;<br><br>    @Autowired<br>    private UserDao userDao;<br><br>    public void insertUser()&#123;<br>        userDao.insert();<br>        System.out.println(&quot;插入成功!!!!&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Repository<br>public class UserDao &#123;<br><br>    @Autowired<br>    private JdbcTemplate jdbcTemplate;<br><br>    public void insert() &#123;<br>        String sql = &quot;insert into tbl_user(username,age) VALUES(?,?);&quot;;<br>        String username = UUID.randomUUID().toString().substring(0, 4);<br>        int age = 16;<br>        jdbcTemplate.update(sql, username, age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4) 创建新的测试类IoCTest_TX：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IoCTest_TX &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(TxConfig.class);<br><br>        UserService userService = applicationContext.getBean(UserService.class);<br>        userService.insertUser();<br><br>        applicationContext.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5) 运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 20, 2018 10:42:43 上午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Sat Oct 20 10:42:43 CST 2018]; root of context hierarchy<br>十月 20, 2018 10:42:43 上午 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &lt;init&gt;<br>信息: JSR-330 &apos;javax.inject.Inject&apos; annotation found and supported for autowiring<br>十月 20, 2018 10:42:43 上午 com.mchange.v2.log.MLog <br>信息: MLog clients using java 1.4+ standard logging.<br>十月 20, 2018 10:42:44 上午 com.mchange.v2.c3p0.C3P0Registry <br>信息: Initializing c3p0-0.9.5.2 [built 08-December-2015 22:06:04 -0800; debug? true; trace: 10]<br>十月 20, 2018 10:42:44 上午 com.mchange.v2.c3p0.impl.AbstractPoolBackedDataSource <br>信息: Initializing c3p0 pool... com.mchange.v2.c3p0.ComboPooledDataSource [ acquireIncrement -&gt; 3, acquireRetryAttempts -&gt; 30, acquireRetryDelay -&gt; 1000, autoCommitOnClose -&gt; false, automaticTestTable -&gt; null, breakAfterAcquireFailure -&gt; false, checkoutTimeout -&gt; 0, connectionCustomizerClassName -&gt; null, connectionTesterClassName -&gt; com.mchange.v2.c3p0.impl.DefaultConnectionTester, contextClassLoaderSource -&gt; caller, dataSourceName -&gt; 2s4fkk9y13rx1eqqia0s|69b2283a, debugUnreturnedConnectionStackTraces -&gt; false, description -&gt; null, driverClass -&gt; com.mysql.jdbc.Driver, extensions -&gt; &#123;&#125;, factoryClassLocation -&gt; null, forceIgnoreUnresolvedTransactions -&gt; false, forceSynchronousCheckins -&gt; false, forceUseNamedDriverClass -&gt; false, identityToken -&gt; 2s4fkk9y13rx1eqqia0s|69b2283a, idleConnectionTestPeriod -&gt; 0, initialPoolSize -&gt; 3, jdbcUrl -&gt; jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8, maxAdministrativeTaskTime -&gt; 0, maxConnectionAge -&gt; 0, maxIdleTime -&gt; 0, maxIdleTimeExcessConnections -&gt; 0, maxPoolSize -&gt; 15, maxStatements -&gt; 0, maxStatementsPerConnection -&gt; 0, minPoolSize -&gt; 3, numHelperThreads -&gt; 3, preferredTestQuery -&gt; null, privilegeSpawnedThreads -&gt; false, properties -&gt; &#123;user=******, password=******&#125;, propertyCycle -&gt; 0, statementCacheNumDeferredCloseThreads -&gt; 0, testConnectionOnCheckin -&gt; false, testConnectionOnCheckout -&gt; false, unreturnedConnectionTimeout -&gt; 0, userOverrides -&gt; &#123;&#125;, usesTraditionalReflectiveProxies -&gt; false ]<br>Loading class `com.mysql.jdbc.Driver&apos;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&apos;. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.<br>Sat Oct 20 10:42:45 CST 2018 WARN: Establishing SSL connection without server&apos;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&apos;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &apos;false&apos;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.<br>Sat Oct 20 10:42:45 CST 2018 WARN: Establishing SSL connection without server&apos;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&apos;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &apos;false&apos;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.<br>Sat Oct 20 10:42:45 CST 2018 WARN: Establishing SSL connection without server&apos;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&apos;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &apos;false&apos;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.<br>插入成功!!!!<br>十月 20, 2018 10:42:45 上午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Sat Oct 20 10:42:43 CST 2018]; root of context hierarchy<br></code></pre></td></tr></table></figure></p><p>看到插入成功，打开数据库也能发现数据库中多了一条新的记录。</p><p>ps：以上操作是建立在本地存在数据库test，和一个表，表的字段有id自增，username用户名，age用户的年龄，这里就不详细描述数据库的创建过程了。</p><hr><p>6）修改UserService类：<br>添加 int res = 1 / 0;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class UserService &#123;<br><br>    @Autowired<br>    private UserDao userDao;<br><br>    public void insertUser() &#123;<br>        userDao.insert();<br>        System.out.println(&quot;插入成功!!!!&quot;);<br>        int res = 1 / 0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>7）再次运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">插入成功!!!!<br><br>java.lang.ArithmeticException: / by zero<br><br>at com.liuzhuo.tx.UserService.insertUser(UserService.java:21)<br>at com.liuzhuo.test.IoCTest_TX.test01(IoCTest_TX.java:23)<br></code></pre></td></tr></table></figure></p><p><strong>会出现异常。打开数据库，发现还是会添加一条新的记录，这是因为没有添加事务的原因。</strong></p><h3 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h3><p>1）修改UserService类：<br>添加@Transactional注解<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class UserService &#123;<br><br>    @Autowired<br>    private UserDao userDao;<br><br>    @Transactional<br>    public void insertUser() &#123;<br>        userDao.insert();<br>        System.out.println(&quot;插入成功!!!!&quot;);<br>        int res = 1 / 0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">插入成功!!!!<br><br>java.lang.ArithmeticException: / by zero<br></code></pre></td></tr></table></figure></p><p>出现ArithmeticException异常，打开数据库，发现还是会添加一条数据，说明事务还没有添加上去，<strong>因为没有开启注解时事务</strong>。</p><p>3）修改配置类<br>添加@EnableTransactionManagement注解<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(&quot;com.liuzhuo.tx&quot;)<br>@EnableTransactionManagement<br>public class TxConfig<br></code></pre></td></tr></table></figure></p><p>4) 运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">No qualifying bean of type &apos;org.springframework.transaction.PlatformTransactionManager&apos; available<br></code></pre></td></tr></table></figure></p><p>发现出现没有PlatformTransactionManager这个组件的异常，此时虽然数据库没有添加一条数据，但是是出现了其他异常，而不是出现ArithmeticException异常。</p><p>出现没有PlatformTransactionManager这个组件异常，说明我们还需要配置事务管理器。</p><p>5) 添加事务管理器<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//添加事务管理器<br> @Bean<br> public PlatformTransactionManager transactionManager() throws Exception &#123;<br>     return new DataSourceTransactionManager(dataSource());<br> &#125;<br></code></pre></td></tr></table></figure></p><p>6) 运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">插入成功!!!!<br><br>java.lang.ArithmeticException: / by zero<br></code></pre></td></tr></table></figure></p><p>出现了ArithmeticException异常，打开数据库，发现也没有添加新的一条记录，说明事务起作用了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用事务的步骤：</p><ol><li>添加相关的依赖(Spring-jdbc)</li><li>配置数据源、事务管理器(PlatformTransactionManager)</li><li>开始注解式事务(@EnableTransactionManagement)</li><li>给相关的方法添加@Transactional注解</li></ol><hr><h3 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h3><p>点击@EnableTransactionManagement注解：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Target(&#123;ElementType.TYPE&#125;)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>@Import(&#123;TransactionManagementConfigurationSelector.class&#125;)<br>public @interface EnableTransactionManagement &#123;<br>    boolean proxyTargetClass() default false;<br><br>    AdviceMode mode() default AdviceMode.PROXY;<br><br>    int order() default 2147483647;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>@Import({TransactionManagementConfigurationSelector.class})<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>protected String[] selectImports(AdviceMode adviceMode) &#123;<br>switch (adviceMode) &#123;<br>case PROXY:<br>return new String[] &#123;AutoProxyRegistrar.class.getName(),<br>ProxyTransactionManagementConfiguration.class.getName()&#125;;<br>case ASPECTJ:<br>return new String[] &#123;determineTransactionAspectClass()&#125;;<br>default:<br>return null;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>会导入AutoProxyRegistrar和ProxyTransactionManagementConfiguration两个组件。</p><p>1）AutoProxyRegistrar会给容器注入InfrastructureAdvisorAutoProxyCreator组件（也是一个后置处理器）。</p><p>InfrastructureAdvisorAutoProxyCreator组件利用后置处理器机制在对象创建时，包装对象，返回一个代理对象（增强器），代理对象执行方法利用拦截器链执行。</p><p>2）ProxyTransactionManagementConfiguration</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给容器注入事务增强器<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务增强器要用事务注解的信息<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务拦截器：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TransactionInterceptor：保存了事务属性信息，事务管理器<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是一个MethodInterceptor<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在目标方法执行的时候：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行拦截器链：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务拦截器：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先获取事务相关的属性<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再获取事务管理器<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行目标方法：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果异常，获取事务管理器，回滚<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果正常，利用事务管理器，提交事务</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring4配置文件详解</title>
      <link href="/2018/10/19/Spring4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/10/19/Spring4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>这里，总结了Spring4中的各种配置文件的信息。</p><p>欢迎大家补充，完善各种配置信息。</p><p>好的习惯，将会伴随你的一生。</p><p>开始今天的主题！！！</p><h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><hr><p>基本的加载properties配置文件</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;context:property-placeholder location=&quot;classpath*:/appConfig.properties&quot; /&gt;<br></code></pre></td></tr></table></figure><h4 id="JNDI方式"><a href="#JNDI方式" class="headerlink" title="JNDI方式"></a>JNDI方式</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;/jdbc/mysqlDS&quot; resource-ref=&quot;true&quot;/&gt;<br></code></pre></td></tr></table></figure><p>jndi-name：指定JNDI中资源名称</p><p>resource-ref：如果应用程序运行在java应用程序服务器中，值设为true，这样jndi-name会自动加上java:comp/env/前缀</p><h4 id="数据连接池方式"><a href="#数据连接池方式" class="headerlink" title="数据连接池方式"></a>数据连接池方式</h4><h5 id="DBCP连接池："><a href="#DBCP连接池：" class="headerlink" title="DBCP连接池："></a>DBCP连接池：</h5><p>使用：org.apache.commons.dbcp.BasicDataSource进行配置<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;<br><br>  &lt;!-- 【必须】  数据库驱动--&gt;<br>  &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;<br><br>  &lt;!-- 【必须】 数据库连接地址 --&gt;<br>  &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;<br><br>  &lt;!-- 【必须】 数据库用户名 --&gt;<br>  &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;<br><br>  &lt;!-- 【必须】 数据库密码 --&gt;<br>  &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;<br><br>  &lt;!-- 可选 启动时创建的连接数 --&gt;<br>  &lt;property name=&quot;initialSize&quot; value=&quot;5&quot;/&gt;<br><br>  &lt;!-- 可选 同时可从池中分配的最多连接数，0无限制 --&gt;<br>  &lt;property name=&quot;maxActive&quot; value=&quot;10&quot;/&gt;<br><br>  &lt;!-- 可选 池中不会被释放的最多空闲连接数 0无限制 --&gt;<br>  &lt;property name=&quot;maxIdle&quot; value=&quot;&quot;/&gt;<br><br>  &lt;!-- 可选 同时能从语句池中分配的预处理语句最大值，0无限制 --&gt;<br>  &lt;property name=&quot;maxOpenPreparedStatement&quot; value=&quot;100&quot;/&gt;<br><br>  &lt;!-- 可选 抛异常前池等待连接回收最大时间（当无可用连接），-1无限等待 --&gt;<br>  &lt;property name=&quot;maxWait&quot; value=&quot;1000&quot;/&gt;<br><br>  &lt;!-- 可选 连接在池中保持空闲而不被回收的最大时间 --&gt;<br>  &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;2000&quot;/&gt;<br><br>  &lt;!-- 可选 不创建新连接情况下池中保持空闲的最小连接数 --&gt;<br>  &lt;property name=&quot;minIdle&quot; value=&quot;2&quot;/&gt;<br><br>  &lt;!-- 可选 布尔值，是否对预处理语句进行池管理 --&gt;<br>  &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><h5 id="C3P0连接池："><a href="#C3P0连接池：" class="headerlink" title="C3P0连接池："></a>C3P0连接池：</h5><p>使用：com.mchange.v2.c3p0.ComboPooledDataSource进行配置<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; destroy-method=&quot;close&quot;&gt;<br><br>  &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;<br>  &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;<br>  &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;<br>  &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;<br>  <br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><h5 id="alibaba-DRUID连接池："><a href="#alibaba-DRUID连接池：" class="headerlink" title="alibaba DRUID连接池："></a>alibaba DRUID连接池：</h5><p>使用：com.alibaba.druid.pool.DruidDataSource进行配置<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;  <br><br>   &lt;!-- 基本属性 url、user、password --&gt; <br>   &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc_url&#125;&quot; /&gt; <br>   &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc_user&#125;&quot; /&gt; <br>   &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc_password&#125;&quot; /&gt; <br>   &lt;!-- 配置初始化大小、最小、最大 --&gt; <br>   &lt;property name=&quot;initialSize&quot; value=&quot;1&quot; /&gt; <br>   &lt;property name=&quot;minIdle&quot; value=&quot;1&quot; /&gt;  <br>   &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt; <br>   &lt;!-- 配置获取连接等待超时的时间 --&gt; <br>   &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt; <br>   &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; <br>   &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot; /&gt; <br>   &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; <br>   &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;300000&quot; /&gt; <br>   &lt;property name=&quot;validationQuery&quot; value=&quot;SELECT &apos;x&apos;&quot; /&gt; <br>   &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; <br>   &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot; /&gt; <br>   &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot; /&gt; <br>   &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt; <br>   &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot; /&gt; <br>   &lt;property name=&quot;maxPoolPreparedStatementPerConnectionSize&quot; value=&quot;20&quot; /&gt; <br>   &lt;!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 --&gt; <br>   &lt;property name=&quot;filters&quot; value=&quot;stat&quot; /&gt;  <br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><h4 id="JDBC驱动的数据源"><a href="#JDBC驱动的数据源" class="headerlink" title="JDBC驱动的数据源"></a>JDBC驱动的数据源</h4><p>使用：</p><p>org.springframework.jdbc.datasource.SingleConnectionDataSource【每个链接请求会返回同一个连接，不推荐】</p><p>org.springframework.jdbc.datasource.DriverManagerDataSource进行配置<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;<br><br>  &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;<br>  &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;<br>  &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;<br>  &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><hr><h4 id="spring-JDBC模板"><a href="#spring-JDBC模板" class="headerlink" title="spring JDBC模板"></a>spring JDBC模板</h4><p>模板类选择：</p><p>JdbcTemplate：提供最简单的数据访问等功能。</p><p>NamedParameterJdbcTemplate：通过该模板，可以把参数作为查询的条件传入方法中。</p><p>SimpleJdbcTemplate（推荐）：结合了一些自动装箱等功能，2.5以后，整合了NamedParameterJdbcTemplate。</p><p>配置方式：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.simple.SimpleJdbcTemplate&quot;&gt;<br>  &lt;constructor-arg ref=&quot;dataSource&quot;/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><h4 id="与ORM框架集成"><a href="#与ORM框架集成" class="headerlink" title="与ORM框架集成"></a>与ORM框架集成</h4><p>主要是配置spring的Session工厂（sessionFactory），可以使用到诸如延迟加载、预先抓取、级联复杂特性。</p><p>spring对ORM框架的支持提供提供了一些附加服务：</p><p>spring声明式事务集成支持</p><p>透明的异常处理</p><p>线程安全、轻量级的模板类</p><p>DAO支持</p><p>资源管理</p><h5 id="集成Hibernate方式：-hibernate4为例"><a href="#集成Hibernate方式：-hibernate4为例" class="headerlink" title="集成Hibernate方式：[hibernate4为例]"></a>集成Hibernate方式：[hibernate4为例]</h5><p>hibernate的HBM文件配置方式（Xxx.hbm.xml)：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;&gt;<br><br>  &lt;!-- 数据源 --&gt;<br>  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;<br>  &lt;!-- 映射文件形式--&gt;<br>  &lt;property name=&quot;mappingResources&quot;&gt;<br>     &lt;list&gt;<br>        &lt;value&gt;User.hbm.xml&lt;/value&gt;<br>     &lt;/list&gt;<br>  &lt;/property&gt;<br>  &lt;!-- Hibernate属性配置 --&gt;<br>  &lt;property name=&quot;hibernateProperties&quot;&gt;<br>     &lt;props&gt;<br>         &lt;prop key=&quot;dialect&quot;&gt;<br>            org.hibernate.dialect.MySQLDialect &lt;!-- 数据库方言 --&gt;<br>         &lt;/prop&gt;<br>        &lt;!-- ……其他 --&gt;<br>     &lt;/props&gt;<br>  &lt;/property&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>代码中使用注解的方式：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;&gt;<br><br>  &lt;!-- 数据源 --&gt;<br>  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;  <br>  &lt;!-- 自动扫描实体对象 tdxy.bean的包结构中存放实体类  --&gt;<br>  &lt;property name=&quot;packagesToScan&quot; value=&quot;com.test.entity&quot;/&gt;<br>  &lt;!-- hibernate的相关属性配置 --&gt;<br>  &lt;property name=&quot;hibernateProperties&quot;&gt;<br>     &lt;value&gt;<br>        &lt;!-- 设置数据库方言 --&gt;<br>        hibernate.dialect=org.hibernate.dialect.MySQLDialect<br>        &lt;!-- 设置自动创建|更新|验证数据库表结构 --&gt;<br>        hibernate.hbm2ddl.auto=update                 <br>        &lt;!-- 是否在控制台显示sql --&gt;<br>        hibernate.show_sql=true                 <br>        &lt;!-- 是否格式化sql，优化显示 --&gt;<br>        hibernate.format_sql=true                <br>        &lt;!-- 是否开启二级缓存 --&gt;<br>        hibernate.cache.use_second_level_cache=false                <br>        &lt;!-- 是否开启查询缓存 --&gt;<br>        hibernate.cache.use_query_cache=false                <br>        &lt;!-- 数据库批量查询最大数 --&gt;<br>        hibernate.jdbc.fetch_size=50<br>        &lt;!-- 数据库批量更新、添加、删除操作最大数  --&gt;<br>        hibernate.jdbc.batch_size=50                <br>        &lt;!-- 是否自动提交事务  --&gt;<br>        hibernate.connection.autocommit=true<br>        &lt;!-- 指定hibernate在何时释放JDBC连接  --&gt;<br>        hibernate.connection.release_mode=auto<br>        &lt;!-- 创建session方式 hibernate4.x 的方式  --&gt;<br>        hibernate.current_session_context_class=org.springframework.orm.hibernate4.SpringSessionContext<br>        &lt;!-- javax.persistence.validation.mode默认情况下是auto的，就是说如果不设置的话它是会自动去你的classpath下面找一个bean-validation**包，所以把它设置为none即可  --&gt;<br>        javax.persistence.validation.mode=none            <br>     &lt;/value&gt;<br>  &lt;/property&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>针对少量实体类，还可以通过annotatedClasses属性来将应用程序中所有的持久化类以全局定名的方式明确列出：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;property name=&quot;annotatedClasses&quot;&gt;<br>  &lt;list&gt;<br>     &lt;value&gt;com.demo.entity.User&lt;/value&gt;<br>     &lt;value&gt;com.demo.entity.Blog&lt;/value&gt;<br>  &lt;/list&gt;<br>&lt;/property&gt;<br></code></pre></td></tr></table></figure></p><p><strong>推荐使用packagesToScan属性扫描包方式。</strong></p><p>【构建不依赖于spring的Hibernate代码】<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package com.demo.dao;<br><br>import org.hibernate.Session;<br>import org.hibernate.SessionFactory;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.stereotype.Repository;<br>import com.demo.entity.User;<br><br>@Repository<br>public class UserDaoImpl implements IUserDao  &#123;<br><br>  private SessionFactory sessionFactory;<br><br>  // 构造注入<br>  @Autowired<br>  public UserDaoImpl(SessionFactory sessionFactory) &#123;<br>     this.sessionFactory = sessionFactory;<br>  &#125;<br><br>  private Session currentSession()&#123;<br>     return sessionFactory.getCurrentSession();<br>  &#125;<br><br>  @Override<br>  public void addUser(User param) &#123;<br>     Session session = currentSession();<br>     session.save(param);<br>     System.out.println(&quot;Add User&quot;);<br>  &#125;<br><br>  @Override<br>  public User get(Integer id) &#123;<br>     return (User) currentSession().get(User.class, id);<br>  &#125;<br><br>  @Override<br>  public void save(User user) &#123;<br>     currentSession().update(user);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>还需配置：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;context:component-scan base-package=&quot;com.demo.dao&quot;/&gt;<br></code></pre></td></tr></table></figure></p><p>就会像扫描其他注解一样扫描带@Repository注解的类到容器中。</p><h5 id="集成MyBatis方式"><a href="#集成MyBatis方式" class="headerlink" title="集成MyBatis方式"></a>集成MyBatis方式</h5><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;<br>  p:dataSource-ref=&quot;dataSource&quot; p:configLocation=&quot;classpath:mybatis-config.xml&quot;<br>  p:mapperLocations=&quot;classpath:com/demo/dao/*.xml&quot; /&gt;<br><br>&lt;!-- spring与mybatis整合配置，扫描所有dao --&gt;<br>&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;<br>  p:basePackage=&quot;com.demo.dao&quot; p:sqlSessionFactoryBeanName=&quot;sqlSessionFactory&quot; /&gt;<br></code></pre></td></tr></table></figure><h4 id="与其他JPA集成方式"><a href="#与其他JPA集成方式" class="headerlink" title="与其他JPA集成方式"></a>与其他JPA集成方式</h4><p>配置实体管理工厂</p><p>应用程序管理类型的JPA（LocalEntityManagerFactoryBean）：它的EntityManager是由EntityManagerFactory创建的；</p><p>容器管理类型的JPA（LocalContainerEntityManagerFactoryBean）：通过PersistenceProvider的createEntityManagerFactory()方法得到，即它的EntityManagerFactory是通过PersistenceProvider的createContainerEntityManagerFactory()方法得到。</p><p>使用应用程序管理类型的JPA</p><p>绝大部分配置文件来源于名为persistence.xml的配置文件，这个文件位置必须位于类路径下的WETA-INF目录下<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;persistence version=&quot;2.0&quot;<br>     xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot;<br>     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>     xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd&quot;&gt;<br>     <br>  &lt;persistence-unit name=&quot;persistenceUnit&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;<br><br>     &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;<br><br>     &lt;properties&gt;<br>        &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.MySQL5Dialect&quot; /&gt;<br>        &lt;property name=&quot;hibernate.max_fetch_depth&quot; value=&quot;3&quot;/&gt;<br>        &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot;/&gt;<br>        &lt;property name=&quot;hibernate.jdbc.fetch_size&quot; value=&quot;18&quot;/&gt;<br>        &lt;property name=&quot;hibernate.jdbc.batch_size&quot; value=&quot;10&quot;/&gt;<br>        &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;false&quot;/&gt;<br>        &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;false&quot;/&gt;<br>     &lt;/properties&gt;<br><br>     &lt;class&gt;com.demo.entity.User&lt;/class&gt;<br>     &lt;class&gt;com.demo.entity.Blog&lt;/class&gt;<br>     &lt;!-- …… ……--&gt;<br>   &lt;/persistence-unit&gt;<br><br>&lt;/persistence&gt;<br></code></pre></td></tr></table></figure></p><p>这样在spring的配置文件中配置的信息就很少了：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;demo&quot; class=&quot;org.springframework.orm.jpa.LocalEntityManagerFactoryBean&quot;&gt;<br>  &lt;property name=&quot;persistenceUnit&quot; &gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>【TIPS】上面persistence.xml文件中的配置会出现问题：</p><p>如果每次请求EntityManagerFactory时都要定义持久化单元，代码回迅速膨胀</p><p>借助spring对JPA的支持，不再需要直接处理PersistenceProvider了，就是下面的容器管理的JPA！</p><p>使用容器管理类型的JPA</p><p>将数据源信息配置在spring的应用上下文中，而不是在persistence.xml文件中。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;emf&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;<br>  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;<br>   &lt;!-- 指定使用的是哪一个厂商的JPA实现 如Hibernate --&gt;<br>  &lt;property name=&quot;jpaVendorAdapter&quot; ref=&quot;hibernateJpaVendorAdapter&quot;/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>配置JPA实现：</p><p>可选的有：EclipseLinkJpaVendorAdapter、HibernateJpaVendorAdapter、OpenJpaVendorAdapter、TopLinkJpaVendorAdapter</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;hibernateJpaVendorAdapter&quot; class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&gt;<br>  &lt;property name=&quot;database&quot; value=&quot;MYSQL&quot;/&gt;<br>  &lt;property name=&quot;showSql&quot; value=&quot;true&quot;/&gt;<br>  &lt;property name=&quot;generateDdl&quot; value=&quot;true&quot;/&gt;<br>  &lt;property name=&quot;databasePlatform&quot; value=&quot;org.hibernate.dialect.MySQL5Dialect&quot;/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>【TIPS】database属性：属性值表示支持哪种数据库，下面Hibernate的JPA是一些支持的数据库：<br><img src="/images/20181019214107.png"></p><p><strong>【注】JNDI获取实体管理工厂：</strong></p><p>如果spring应用部署在应用服务器中，Spring可能已经创建好EntityManagerFactory并将其置于JNDI中等饭查询使用，这种情况可使用JNDI来获取对EntityManagerFactory的引用：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;jee:jndi-lookup id=&quot;emf&quot; jndi-name=&quot;persistence/testDS&quot;/&gt;<br></code></pre></td></tr></table></figure></p><p>编写基于JPA的DAO<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package com.demo.dao;<br><br>import javax.persistence.EntityManager;<br>import javax.persistence.PersistenceContext;<br>import org.springframework.stereotype.Repository;<br>import org.springframework.transaction.annotation.Transactional;<br>import com.demo.entity.User;<br><br>@Repository<br>@Transactional<br>public class JpaDao implements IUserDao &#123;<br><br>  // 注入EntityManager<br>  @PersistenceContext<br>  private EntityManager em;<br><br>  // 使用EntityManager<br>  @Override<br>  public void addUser(User param) &#123;<br>     em.persist(param);<br>  &#125;<br><br>  @Override<br>  public User get(Integer id) &#123;<br>     return em.find(User.class, id);<br>  &#125;<br><br>  @Override<br>  public void save(User user) &#123;<br>     em.merge(user);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>上面使用到了@PersistenceContext注解将EntityManager注入。</p><p>这样用需要在spring的上下文配置文件中配置一个PersistenceAnnotationBeanPostProcessor：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!-- 使用EntityManager --&gt;<br>&lt;bean class=&quot;org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor&quot;/&gt;<br></code></pre></td></tr></table></figure></p><p>以上，是如何使用JDBC、Hibernate或JPA为spring应用程序构建持久层，至于选择哪种方案完全取决于偏好.</p><h3 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h3><p>通过毁掉机制将实际事务实现从事务性代码中抽象出来。</p><h4 id="选择事务管理器"><a href="#选择事务管理器" class="headerlink" title="选择事务管理器"></a>选择事务管理器</h4><p>事务管理器结构</p><p>事务处理流程：</p><p>开始事务-&gt;绑定资源-&gt;使用资源-&gt;完成事务-&gt;释放资源</p><h5 id="JDBC事务"><a href="#JDBC事务" class="headerlink" title="JDBC事务"></a>JDBC事务</h5><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;<br>     &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>DataSourceTransactionManager通过调用java.sql.Connection来管理事务，由java.sql.Connection对象来提交、回滚事务。</p><h5 id="Hibernate事务"><a href="#Hibernate事务" class="headerlink" title="Hibernate事务"></a>Hibernate事务</h5><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;transactionManager&quot;<br>class=&quot;org.springframework.orm.hibernate4.HibernateTransactionManager&quot;&gt;<br>  &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>HibernateTransactionManager通过将事务管理的职责委托给org.hibernate.Transaction对象，org.hibernate.Transaction对象从Hibernate Session中获取，然后由Transaction对象来提交、回滚事务。</p><h5 id="JPA事务"><a href="#JPA事务" class="headerlink" title="JPA事务"></a>JPA事务</h5><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;<br>  &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>JpaTransactionManager只需要装配一个JPA实体管理工厂（EntityManagerFactory的任意实现），然后与由工厂产生的JPA EntityManager合作构建事务。</p><p>如果你还希望将事务应用于简单JDBC操作（JDBC操作使用的datasource和EntityManagerFactory使用的dataSource必须相同），那么JpaTransactionManager必须装配一个JpaDialect的实现：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;jpaDialect&quot; class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;/&gt;<br><br><br>&lt;!--然后将jpaDialect装配到transactionManager中 --&gt;<br>&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;<br>  &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;/&gt;<br>  &lt;property name=&quot;jpaDialect&quot; ref=&quot;jpaDialect&quot;/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><h5 id="JTA事务"><a href="#JTA事务" class="headerlink" title="JTA事务"></a>JTA事务</h5><p>如果前面的事务管理器不能满足需求或事物需要跨多个事务资源（两个及以上数据库），需要使用JtaTrasactionManager了：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;transactionManager&quot;<br>  class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;&gt;<br>  &lt;property name=&quot;transactionManagerName&quot; value=&quot;java:/TrasactionManager&quot;/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>JtaTransactionManager将事务委托给一个JTA的实现（java.transaction.UserTransaction和javax.transaction.TransactionManager），通过UserTransaction来操作事务。JTA规定了应用程序晕一个或多个数据源之间协调事务的标准API，transactionManagerName属性指定了要在JNDI上查找JTA事务管理器。</p><h4 id="Spring事务实现方式"><a href="#Spring事务实现方式" class="headerlink" title="Spring事务实现方式"></a>Spring事务实现方式</h4><p>1）编码事务</p><p>通过TransactionTemplate的回调机制，例如：（UserSeriveImpl.java）<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public void addUser(final User u) &#123;<br><br>  TransactionTemplate temp = new TransactionTemplate();<br>  <br>  temp.execute(new TransactionCallback&lt;Void&gt;() &#123;<br>  <br>     @Override<br>     public Void doInTransaction(TransactionStatus txtStatus) &#123;<br>          // 要执行的事务代码<br>        try &#123;<br>           userDao.save(u);<br>        &#125; catch (RuntimeException e) &#123;<br>           e.printStackTrace();<br>           txtStatus.setRollbackOnly();<br>        &#125;<br>        return null;<br>     &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>此时UserService需要如下装配：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;userSerive&quot; class=&quot;com.demo.service.UserServiceImpl&quot;&gt;<br>  &lt;property name=&quot;transactionTemplate&quot;&gt;<br>     &lt;bean class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt;<br>        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;<br>     &lt;/bean&gt;<br>  &lt;/property&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>优点：可以完全控制事务边界，精确控制事务。</p><p>缺点：侵入性的，事务控制在代码中实现，耦合度高</p><p>2）声明式事务</p><p>传播行为</p><p>传播行为回答了新的事务是该被启动还是被挂起，或者方法是否要在事务环境中运行。</p><p>事务的传播行为都在org.springframework.transaction.TransactionDefinition接口中以常量的方式定义出来。</p><p>隔离级别</p><p>隔离级别定义了一个事务可能受其他并发事务影响的程度。</p><p>隔离级别都在org.springframework.transaction.TransactionDefinition接口中以常量的方式定义出来。</p><p>只读</p><p>事务启动的时候由数据库实施的，只有针对具备启动一个新事务传播行为（PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW和PROPAGATION_NESTED）的方法来说才有意义。【tips】如果使用Hibernate，将事务声明为只读会导致flush模式被设置为FLUSH_NEVER，这会告诉hibernate避免和数据库进行不必要的对象同步，并将所有的更新延迟到事务结束。</p><p>事务超时</p><p>长时间事务会导致一些不必要的数据库资源占用。</p><p>超时时钟会在事务开始时启动，只有针对具备启动一个新事务传播行为（PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW和PROPAGATION_NESTED）的方法来说才有意义。</p><p>回滚规则</p><p>这些规则定义了哪些异常会导致事务回滚哪些不会，默认情况下，运行时异常会回滚，检查异常不回滚，但是可以声明事务遇到检查异常回滚，运行时异常不回滚。</p><p>3）Spring在XML中定义事务</p><p>需要包括beans、aop、tx命名空间。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;<br>  &lt;tx:attributes&gt;<br>     &lt;!-- 事务执行方式 REQUIRED：指定当前方法必需在事务环境中运行，<br>     如果当前有事务环境就加入当前正在执行的事务环境，<br>     如果当前没有事务，就新建一个事务。 这是默认值。 --&gt;<br>     &lt;tx:method name=&quot;create*&quot; propagation=&quot;REQUIRED&quot; /&gt;<br>     &lt;tx:method name=&quot;save*&quot;   propagation=&quot;REQUIRED&quot; /&gt;<br>     &lt;tx:method name=&quot;add*&quot;    propagation=&quot;REQUIRED&quot; /&gt;<br>     &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt;<br>     &lt;tx:method name=&quot;remove*&quot; propagation=&quot;REQUIRED&quot; /&gt;<br>     &lt;tx:method name=&quot;del*&quot;    propagation=&quot;REQUIRED&quot; /&gt;<br>     &lt;tx:method name=&quot;import*&quot; propagation=&quot;REQUIRED&quot; /&gt;<br>     &lt;!-- 指定当前方法以非事务方式执行操作，如果当前存在事务，就把当前事务挂起，等我以非事务的状态运行完，再继续原来的事务。 查询定义即可<br>        read-only=&quot;true&quot; 表示只读 --&gt;<br>     &lt;tx:method name=&quot;*&quot;       propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot; /&gt;<br>  &lt;/tx:attributes&gt;<br>&lt;/tx:advice&gt;<br></code></pre></td></tr></table></figure></p><p>其中&lt;tx:method /&gt;有很多属性用来帮助定义方法的事务策略：<br><img src="/images/20181019215056.png"></p><p>4）定义注解驱动的事务</p><p>在XML配置文件中添加：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;tx:annotation-driven/&gt;<br></code></pre></td></tr></table></figure></p><p>可通过transaction-manager属性（默认值”transactionManager”）来指定事务管理器，如：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;<br></code></pre></td></tr></table></figure></p><p><code>&lt;tx:annotation-driven/&gt;</code>告诉Spring检查上下文中所有bean并检查使用到@Transactional注解的bean。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring中无处不在的Properties</title>
      <link href="/2018/10/19/Spring%E4%B8%AD%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E7%9A%84Properties/"/>
      <url>/2018/10/19/Spring%E4%B8%AD%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E7%9A%84Properties/</url>
      
        <content type="html"><![CDATA[<p>对 Spring 里面的 Properties 不理解的开发者可能会觉得有点乱，主要是因为配置方式很多种，使用方式也很多种。</p><p>本文不是原理分析、源码分析文章，只是希望可以帮助读者更好地理解和使用 Spring Properties。</p><hr><h3 id="Properties-的使用"><a href="#Properties-的使用" class="headerlink" title="Properties 的使用"></a>Properties 的使用</h3><p>先来看看 Properties 是怎么使用的，Spring 中常用的有以下几种使用方式：</p><h4 id="在-xml-配置文件中使用"><a href="#在-xml-配置文件中使用" class="headerlink" title="在 xml 配置文件中使用"></a>在 xml 配置文件中使用</h4><p>即自动替换 ${} 里面的值。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean id=&quot;xxx&quot; class=&quot;com.javadoop.Xxx&quot;&gt;<br>     &lt;property name=&quot;url&quot; value=&quot;$&#123;javadoop.jdbc.url&#125;&quot; /&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><h4 id="通过-Value-注入使用"><a href="#通过-Value-注入使用" class="headerlink" title="通过 @Value 注入使用"></a>通过 @Value 注入使用</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Value(&quot;$&#123;javadoop.jdbc.url&#125;&quot;)<br>private String url;<br></code></pre></td></tr></table></figure><h4 id="通过-Environment-获取"><a href="#通过-Environment-获取" class="headerlink" title="通过 Environment 获取"></a>通过 Environment 获取</h4><p>此法有需要注意的地方。并不是所有的配置方式都支持通过 Environment 接口来获取属性值，亲测只有使用注解 @PropertySource 的时候可以用，否则会得到 null，至于怎么配置，下面马上就会说。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Autowired<br>private Environment env;<br><br>public String getUrl() &#123;<br>   return env.getProperty(&quot;javadoop.jdbc.url&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注：如果是 Spring Boot 的 application.properties 注册的，那也是可以的。</strong></p><hr><h3 id="Properties-配置"><a href="#Properties-配置" class="headerlink" title="Properties 配置"></a>Properties 配置</h3><p>前面我们说了怎么使用我们配置的 Properties，那么该怎么配置呢？Spring 提供了很多种配置方式。</p><h4 id="通过-xml-配置"><a href="#通过-xml-配置" class="headerlink" title="通过 xml 配置"></a>通过 xml 配置</h4><p>下面这个是最常用的配置方式了，很多项目都是这么写的：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;context:property-placeholder location=&quot;classpath:sys.properties&quot; /&gt;<br></code></pre></td></tr></table></figure></p><h4 id="通过-PropertySource-配置"><a href="#通过-PropertySource-配置" class="headerlink" title="通过 @PropertySource 配置"></a>通过 @PropertySource 配置</h4><p>前面的通过 xml 配置非常常用，但是如果你也有一种要消灭所有 xml 配置文件的冲动的话，你应该使用以下方式：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@PropertySource(&quot;classpath:sys.properties&quot;)<br>@Configuration<br>public class JavaDoopConfig &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>注：@PropertySource 在这里必须搭配 @Configuration 来使用，具体不展开说了。</strong></p><h4 id="PropertyPlaceholderConfigurer"><a href="#PropertyPlaceholderConfigurer" class="headerlink" title="PropertyPlaceholderConfigurer"></a>PropertyPlaceholderConfigurer</h4><p>如果读者见过这个，也不必觉得奇怪，在 Spring 3.1 之前，经常就是这么使用的：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;<br>   &lt;property name=&quot;locations&quot;&gt;<br>       &lt;list&gt;<br>           &lt;value&gt;classpath:sys.properties&lt;/value&gt;<br>       &lt;/list&gt;<br>   &lt;/property&gt;<br>   &lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot;/&gt;<br>     &lt;!-- 这里可以配置一些属性 --&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>当然，我们也可以用相应的 java configuration 的版本：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean<br>public PropertyPlaceholderConfigurer propertiess() &#123;<br>   PropertyPlaceholderConfigurer ppc = new PropertyPlaceholderConfigurer();<br>   Resource[] resources = new ClassPathResource[]&#123;new ClassPathResource(&quot;sys.properties&quot;)&#125;;<br>   ppc.setLocations(resources);<br>   ppc.setIgnoreUnresolvablePlaceholders(true);<br>   return ppc;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="PropertySourcesPlaceholderConfigurer"><a href="#PropertySourcesPlaceholderConfigurer" class="headerlink" title="PropertySourcesPlaceholderConfigurer"></a>PropertySourcesPlaceholderConfigurer</h4><p>到了 Spring 3.1 的时候，引入了 PropertySourcesPlaceholderConfigurer，这是一个新的类，注意看和之前的 PropertyPlaceholderConfigurer 在名字上多了一个 Sources，所属的包也不一样，它在 Spring-Context 包中。</p><p>在配置上倒是没有什么区别：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean class=&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;&gt;<br>   &lt;property name=&quot;locations&quot;&gt;<br>       &lt;list&gt;<br>           &lt;value&gt;classpath:sys.properties&lt;/value&gt;<br>       &lt;/list&gt;<br>   &lt;/property&gt;<br>   &lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot;/&gt;<br>   &lt;!-- 这里可以配置一些属性 --&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>也来一个 java configuration 版本吧：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean<br>public PropertySourcesPlaceholderConfigurer properties() &#123;<br>   PropertySourcesPlaceholderConfigurer pspc = new PropertySourcesPlaceholderConfigurer();<br>   Resource[] resources = new ClassPathResource[]&#123;new ClassPathResource(&quot;sys.properties&quot;)&#125;;<br>   pspc.setLocations(resources);<br>   pspc.setIgnoreUnresolvablePlaceholders(true);<br>   return pspc;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="Spring-Boot-相关"><a href="#Spring-Boot-相关" class="headerlink" title="Spring Boot 相关"></a>Spring Boot 相关</h3><p>Spring Boot 真的是好东西，开箱即用的感觉实在是太好了。这里简单介绍下相关的内容。</p><p>快速生成一个 Spring Boot 项目：</p><p><a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a></p><p><strong>application.properties</strong></p><p>我们每个项目都默认有一个 application.properties 文件，这个配置文件不需要像前面说的那样进行注册，Spring Boot 会帮我们自动注册。</p><p>当然，也许你想换个名字也是可以的，在启动的时候指定你的文件名字就可以了：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">java -Dspring.config.location=classpath:sys.properties -jar app.jar<br></code></pre></td></tr></table></figure></p><p><strong>application-{env}.properties</strong></p><p>为了给不同的环境指定不同的配置，我们会用到这个。比如测试环境和生产环境的数据库连接信息就不一样。</p><p>所以，在 application.properties 的基础上，我们还需要新建 application-dev.properties 和 application-prd.properties，用于配置环境相关的信息，然后启动的时候指定环境。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">java -Dspring.profiles.active=prd -jar app.jar<br></code></pre></td></tr></table></figure></p><p>结果就是，application.properties 和 application-prd.properties 两个文件中的配置都会注册进去，如果有重复的 key，application-prd.properties 文件中的优先级较高。</p><p><strong>@ConfigurationProperties</strong></p><p>这个注解是 Spring Boot 中才有的。即使大家不使用这个注解，大家也可能会在开源项目中看到这个，这里简单介绍下。</p><p>来一个例子直观一些。按照之前说的，在配置文件中填入下面的信息，你可以选择写入 application.properties 也可以用第一节介绍的方法。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">javadoop.database.url=jdbc:mysql:<br>javadoop.database.username=admin<br>javadoop.database.password=admin123456<br></code></pre></td></tr></table></figure></p><p>java 文件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ConfigurationProperties(prefix = &quot;javadoop.database&quot;)<br>public class DataBase &#123;<br>   String url;<br>   String username;<br>   String password;<br>   // getters and setters<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这样，就在 Spring 的容器中就自动注册了一个类型为 DataBase 的 bean 了，而且属性都已经 set 好了。</p><p><strong>在启动过程中动态修改属性值</strong></p><p>这个我觉得都不需要太多介绍，用 Spring Boot 的应该基本上都知道。</p><p>属性配置有个覆盖顺序，也就是当出现相同的 key 的时候，以哪里的值为准。</p><p>启动参数 &gt; application-{env}.properties &gt; application.properties</p><p>启动参数动态设置属性：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">java -Djavadoop.database.password=admin4321 -jar app.jar<br></code></pre></td></tr></table></figure></p><p>另外，还可以利用系统环境变量设置属性，还可以指定随机数等等，确实很灵活，不过没什么用，就不介绍了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>读者如果想要更加深入地了解 Spring 的 Properties，需要去理解 Spring 的 Environment 接口相关的源码。建议感兴趣的读者去翻翻源代码看看</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_13</title>
      <link href="/2018/10/19/spring-annotation-day-13/"/>
      <url>/2018/10/19/spring-annotation-day-13/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong> </p><p>AOP原理：</p><p>我们上篇文章已经描述了AOP的使用情况，现在来研究一下AOP的原理。首先从@EnableAspectJAutoProxy注解开始。</p><hr><h3 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h3><p>1）点击@EnableAspectJAutoProxy注解：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Target(ElementType.TYPE)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>@Import(AspectJAutoProxyRegistrar.class)<br>public @interface EnableAspectJAutoProxy<br></code></pre></td></tr></table></figure></p><p>发现，使用了@Import注解来注入组件。组件是AspectJAutoProxyRegistrar类。</p><p>2）点击AspectJAutoProxyRegistrar类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar&#123;<br>  ···<br>&#125;<br></code></pre></td></tr></table></figure></p><p>该类，实现了ImportBeanDefinitionRegistrar接口，说明是用来自定义注入组件的。其中有一个registerBeanDefinitions（）方法。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;<br><br>AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);<br><br>AnnotationAttributes enableAspectJAutoProxy =<br>AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);<br>if (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;)) &#123;<br>AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);<br>&#125;<br>if (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;)) &#123;<br>AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>查看其中的AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</p><p>最终会调用registerOrEscalateApcAsRequired方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs undefined">private static BeanDefinition registerOrEscalateApcAsRequired(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source) &#123;<br>Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);<br>if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;<br>BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);<br>if (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;<br>int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());<br>int requiredPriority = findPriorityForClass(cls);<br>if (currentPriority &lt; requiredPriority) &#123;<br>apcDefinition.setBeanClassName(cls.getName());<br>&#125;<br>&#125;<br>return null;<br>&#125;<br>RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);<br>beanDefinition.setSource(source);<br>beanDefinition.getPropertyValues().add(&quot;order&quot;, Ordered.HIGHEST_PRECEDENCE);<br>beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<br>registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);<br>return beanDefinition;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>最后是给容器注入了一个Bean：<br>id：internalAutoProxyCreator ==》 Class：AnnotationAwareAspectJAutoProxyCreator</p><hr><h3 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h3><p>@EnableAspectJAutoProxy注解帮我们注入了AnnotationAwareAspectJAutoProxyCreator组件，这个组件有什么作用呢？</p><p>我们观察一下AnnotationAwareAspectJAutoProxyCreator的继承关系：</p><p>AnnotationAwareAspectJAutoProxyCreator</p><p>&nbsp;&nbsp;&nbsp;AspectJAwareAdvisorAutoProxyCreator  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractAdvisorAutoProxyCreator  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractAutoProxyCreator</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware</strong></p><p><strong>关键:实现了两个接口，一个后置处理器(在Bean初始化完成前后做事情)、一个自动装配BeanFactory</strong></p><hr><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>打上断点：(与后置处理器，自动装配有关的)</p><p>1）AbstractAutoProxyCreator.setBeanFactory<br>2）AbstractAutoProxyCreator.postProcessBeforeInstantiation<br>3) AbstractAutoProxyCreator.postProcessAfterInitialization</p><p>4) AbstractAdvisorAutoProxyCreator.setBeanFactory(父类重写的方法也打上断点)<br>5）AbstractAdvisorAutoProxyCreator.initBeanFactory</p><p>6) AspectJAwareAdvisorAutoProxyCreator类没有相关的就不打上断点</p><p>7）AnnotationAwareAspectJAutoProxyCreator.initBeanFactory(父类重写的方法也打上断点)</p><p>8) MainConfigOfAOP配置类的中的两个Bean对象打上断点：<br>&nbsp;&nbsp;&nbsp;mathCalculator和logAspects</p><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>流程：<br>1）传入配置类，创建IoC容器<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAOP.class);<br></code></pre></td></tr></table></figure></p><p>2) 注册配置类，调用refresh（）, 刷新容器<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) &#123;<br>this();<br>register(annotatedClasses); //注入配置类<br>refresh();  //刷新容器<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3）registerBeanPostProcessors(beanFactory);注册bean的后置处理器，来拦截bean的初始化操作。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;1.先获取IoC容器已经定义了的需要创建对象的所有BeanPostProcessor<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);<br></code></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;2.给容器中加别的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;3.优先注册实现了PriorityOrdered接口的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;4.再注册实现了Ordered接口的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;5.注册没有实现优先级接口的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;6.注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象，保存到容器中</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 创建    internalAutoProxyCreator的BeanPostProcessor【AnnotationAwareAspectJAutoProxyCreator】 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.创建Bean对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.populateBean：给bean的属性赋值</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.initializeBean：初始化bean</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.invokeAwareMethods：处理Aware接口的回调：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">private void invokeAwareMethods(final String beanName, final Object bean) &#123;<br>if (bean instanceof Aware) &#123;<br>if (bean instanceof BeanNameAware) &#123;<br>((BeanNameAware) bean).setBeanName(beanName);<br>&#125;<br>if (bean instanceof BeanClassLoaderAware) &#123;<br>((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());<br>&#125;<br>if (bean instanceof BeanFactoryAware) &#123;<br>((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.applyBeanPostProcessorsBeforeInitialization:执行后置处理器的postProcessor：postProcessBeforeInitialization方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.invokeInitMethods：自定义的初始化方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.applyBeanPostProcessorsAfterInitialization：执行postProcessor：postProcessAfterInitialization方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;7.把BeanPostProcessor注册到BeanFactory中：beanFactory.addBeanPostProcessor（）</p><hr><p>以上是创建AnnotationAwareAspectJAutoProxyCreator的过程。</p><p>AnnotationAwareAspectJAutoProxyCreator =》InstantiationAwareBeanPostProcessor，而不是 BeanPostProcessor 后置处理器</p><p>InstantiationAwareBeanPostProcessor是 postProcessBeforeInstantiation（实例化）</p><p>BeanPostProcessor是postProcessBeforeInitialization（初始化）</p><p><strong>说明InstantiationAwareBeanPostProcessor后置处理器是 在Bean实例化前后执行</strong></p><p><strong>BeanPostProcessor后置处理器是 在Bean对象初始化前后执行</strong></p><p>4）finishBeanFactoryInitialization(beanFactory);完成BeanFactory初始化工作，创建剩下的没有创建的Bean组件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;1.遍历获取容器中所有的Bean，依次创建对象；getBean(beanName)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getBean()-&gt;doGetBean()-&gt;getSingleton()-&gt;createBean()</p><p>&nbsp;&nbsp;&nbsp;&nbsp;2.创建Bean：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.先从缓存中获取当前的Bean，如果能获取到，说明bean是之前被创建过，直接使用，否则再创建.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要创建了bean就会被缓存起来。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.createBean():创建Bean</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.resolveBeforeInstantiation():解析BeanPostProcessors<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>想让后置处理器在次能返回一个代理对象</strong>，如果能返回代理对象就使用，如果不能就继续。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.后置处理器先尝试返回代理对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bean=applyBeanPostProcessorsBeforeInstantiation();拿到所有的后置处理器，如果是 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InstantiationAwareBeanPostProcessor；就执行postProcessBeforeInstantiation方法<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined"> if (bean != null) &#123;<br>  bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.doCreateBean()：真正去创建一个bean实例；和3.6流程一样</p><hr><p>AnnotationAwareAspectJAutoProxyCreator[InstantiationAwareBeanPostProcessor]</p><p>1) 每一个bean创建之前，调用postProcessBeforeInstantiation()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关心<strong>mathCalculator</strong>和<strong>logAspects</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）判断当前bean是否是在advicedBean中（保存了所有需要增强bean）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）判断当前bean是否是基础类型的Advice、PointCut、Advisor、AopInfrastructureBean或者是否是切面(@Aspect)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）是否需要跳过</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）获取候选的增强器(切面里面的通知方法)【List<advisor> candidateAdvisors】<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个封装的通知方法的增强器是InstantiationModelAwarePointcutAdvisor<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判断每一个增强器是否是AspectJPointcutAdvisor类型的；返回true</advisor></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）永远返回false</p><p>2）创建对象<br>postProcessAfterInitialization：<br>return wrapIfNecessary(bean, beanName, cacheKey);//需要包装的情况下  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）获取当前bean的所有增强器(通知方法) Object[] specificInterceptors</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）找到候选的所有增强器(找哪些通知方法是需要切入当前bean方法的)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）获取到能在bean使用的增强器</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）给增强器排序</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）保存当前bean在advisedBeans中；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）如果当前bean需要增强，创建当前bean的代理对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）获取所有的增强器(通知方法)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）保存到proxyFactory</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）创建代理对象：Spring自动决定<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jdk代理<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cglib代理</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）给容器中返回当前组件使用cglib代理的对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5）以后容器中获取的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程</p><p>3）目标方法的执行流程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容器中保存了组件的代理对象(cglib增强后的对象)，这个对象里面保存了详细信息(比如增强器、目标对象，xxx)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）CglibAopProxy.intercept();拦截目标方法的执行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）根据ProxyFactory对象获取将要执行的目标方法拦截器</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List<object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</object></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）List<object> interceptorList保存所有拦截器：5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个默认的ExposeInvocationInterceptor和4个增强器</object></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）遍历所有的增强器，将其转为Interceptor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）将增强器转为List<methodinterceptor>,如果是MethodInterceptor，直接加入集合中，如果不是，使用AdvisorAdapter将增强器转为   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MethodInterceptor，转换完后返回MethodInterceptor数组</methodinterceptor></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）如果没有拦截器链，直接执行目标方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）如果有拦截器链，把需要执行的目标对象，目标方法，拦截器链等信息传入，创建一个CglibMethodInvocation对象，并调用<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object retVal = mi.proceed();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5) 拦截器链的触发过程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）如果没有拦截器执行，就直接执行目标方法，或者拦截器的索引和拦截器数组的个数-1一样大，执行目标方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）链式获取每一个拦截器，拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拦截器链的机制，保证通知方法与目标方法的执行顺序.<br><img src="/images/20181019201432.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1）@EnableAspectJAutoProxy注解 开启AOP功能</p><p>2）@EnableAspectJAutoProxy 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator</p><p>3）AnnotationAwareAspectJAutoProxyCreator是一个后置处理器</p><p>4）容器的创建流程：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）registerBeanPostProcessors()注册后置处理器，创建AnnotationAwareAspectJAutoProxyCreator对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）finishBeanFactoryInitialization()：初始化剩下的单实例bean<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）创建业务逻辑组件和切面组件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）组件创建完之后，判断组件是否需要增强。是：切面的通知方法，包装成增强器(Advisor);给业务逻辑组件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个代理对象 </p><p>5）执行目标方法：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）代理对象执行目标方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）CglibAopProxy.Intercept:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）得到目标方法的拦截器链(增强器包装成拦截器MethodIntercept)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）利用拦截器的链式机制，依次进入每一个拦截器进行执行；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）效果：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 正常执行：前置通知 -》目标方法 -》后置通知 -》返回通知<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 出现异常：前置通知 -》目标方法 -》后置通知 -》异常通知  </p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring和SpringMVC父子容器关系初窥</title>
      <link href="/2018/10/19/Spring%E5%92%8CSpringMVC%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8%E5%85%B3%E7%B3%BB%E5%88%9D%E7%AA%A5/"/>
      <url>/2018/10/19/Spring%E5%92%8CSpringMVC%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8%E5%85%B3%E7%B3%BB%E5%88%9D%E7%AA%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>最近由于项目的包扫描出现了问题，在解决问题的过程中，偶然发现了Spring和SpringMVC是有父子容器关系的，而且正是因为这个才往往会出现包扫描的问题，我们在此来分析和理解Spring和SpringMVC的父子容器关系并且给出Spring和SpringMVC配置文件中包扫描的官方推荐方式。</p><h3 id="二、概念理解和知识铺垫"><a href="#二、概念理解和知识铺垫" class="headerlink" title="二、概念理解和知识铺垫"></a>二、概念理解和知识铺垫</h3><p>在Spring整体框架的核心概念中，容器是核心思想，就是用来管理Bean的整个生命周期的，而在一个项目中，容器不一定只有一个，Spring中可以包括多个容器，而且容器有上下层关系</p><p>目前最常见的一种场景就是在一个项目中引入Spring和SpringMVC这两个框架，那么它其实就是两个容器，Spring是父容器，SpringMVC是其子容器</p><p>并且在Spring父容器中注册的Bean对于SpringMVC容器中是可见的，而在SpringMVC容器中注册的Bean对于Spring父容器中是不可见的，也就是子容器可以看见父容器中的注册的Bean，反之就不行。</p><p>我们可以使用统一的如下注解配置来对Bean进行批量注册，而不需要再给每个Bean单独使用xml的方式进行配置。</p><p><code>&lt;context:component-scan base-package=&quot;com.liuzhuo.www&quot; /&gt;</code></p><p>从Spring提供的参考手册中我们得知该配置的功能是扫描配置的base-package包下的所有使用了@Component注解的类，并且将它们自动注册到容器中，同时也扫描@Controller，@Service，@Respository这三个注解，因为他们是继承自@Component</p><hr><p>在项目中我们经常见到还有如下这个配置，其实有了上面的配置，这个是可以省略掉的，因为上面的配置会默认打开以下配置。</p><p>以下配置会默认声明了@Required、@Autowired、 @PostConstruct、@PersistenceContext、@Resource、@PreDestroy等注解</p><p><code>&lt;context:annotation-config/&gt;</code></p><p><strong>另外，还有一个和SpringMVC相关如下配置，经过验证，这个是SpringMVC必须要配置的，因为它声明了@RequestMapping、@RequestBody、@ResponseBody等。并且，该配置默认加载很多的参数绑定方法，比如json转换解析器等。</strong></p><p><code>&lt;mvc:annotation-driven /&gt;</code></p><p>而上面这句,配置Spring3.1之前的版本和以下配置方式等价</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!--配置注解控制器映射器,它是SpringMVC中用来将Request请求URL到映射到具体Controller--&gt;<br>&lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping&quot;/&gt;<br>&lt;!--配置注解控制器适配器,它是SpringMVC中用来将具体请求映射到具体方法--&gt;<br>&lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;/&gt;<br></code></pre></td></tr></table></figure><p>Spring3.1之后的版本和以下配置方式等价：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!--配置注解控制器映射器,它是SpringMVC中用来将Request请求URL到映射到具体Controller--&gt;<br>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;<br>&lt;!--配置注解控制器适配器,它是SpringMVC中用来将具体请求映射到具体方法--&gt;<br>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;<br></code></pre></td></tr></table></figure></p><h3 id="三、具体场景分析"><a href="#三、具体场景分析" class="headerlink" title="三、具体场景分析"></a>三、具体场景分析</h3><p>下面让我们来详细扒一扒Spring与SpringMVC的容器冲突的原因到底在那里？</p><p>我们共有Spring和SpringMVC两个容器，它们的配置文件分别为applicationContext.xml和applicationContext-MVC.xml</p><p>1、在applicationContext.xml中配置了&lt;context:component-scan base-package=“com.hafiz.www” /&gt;，负责所有需要注册的Bean的扫描和注册工作</p><p>2、在applicationContext-MVC.xml中配置&lt;mvc:annotation-driven /&gt;，负责SpringMVC相关注解的使用</p><p>3、启动项目我们发现SpringMVC无法进行跳转，将log的日志打印级别设置为DEBUG进行调试，发现SpringMVC容器中的请求好像没有映射到具体controller中</p><p>4、在applicationContext-MVC.xml中配置&lt;context:component-scan base-package=“com.hafiz.www” /&gt;，重启后，验证成功，springMVC跳转有效</p><p>下面我们来查看具体原因，翻看源码，从SpringMVC的DispatcherServlet开始往下找，我们发现SpringMVC初始化时，会寻找SpringMVC容器中的所有使用了@Controller注解的Bean，来确定其是否是一个handler</p><p>1、2两步的配置使得当前SpringMVC容器中并没有注册带有@Controller注解的Bean，而是把所有带有@Controller注解的Bean都注册在Spring这个父容器中了，所以SpringMVC找不到处理器，不能进行跳转。核心源码如下:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">protected void initHandlerMethods() &#123;<br>　　if (logger.isDebugEnabled()) &#123;<br>　　　　logger.debug(&quot;Looking for request mappings in application context: &quot; + getApplicationContext());<br>　　&#125;<br>　　String[] beanNames = (this.detectHandlerMethodsInAncestorContexts ?<br>　　　　　　  BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) :<br>　　　　　　　getApplicationContext().getBeanNamesForType(Object.class));<br>　　for (String beanName : beanNames) &#123;<br>　　　　if (isHandler(getApplicationContext().getType(beanName)))&#123;<br>　　　　　　detectHandlerMethods(beanName);<br>　　　　&#125;<br>　　&#125;<br>　　handlerMethodsInitialized(getHandlerMethods());<br>&#125;<br></code></pre></td></tr></table></figure></p><p>在方法isHandler中会判断当前bean的注解是否是controller，源码如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">protected boolean isHandler(Class&lt;?&gt; beanType) &#123;<br>　　return AnnotationUtils.findAnnotation(beanType, Controller.class) != null;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>而在第4步配置中，SpringMVC容器中也注册了所有带有@Controller注解的Bean，故SpringMVC能找到处理器进行处理，从而正常跳转。</p><p>我们找到了出现不能正确跳转的原因，那么它的解决办法是什么呢？</p><p>我们注意到在initHandlerMethods()方法中，detectHandlerMethodsInAncestorContexts这个Switch，它主要控制获取哪些容器中的bean以及是否包括父容器，默认是不包括的。</p><p>所以解决办法就是在SpringMVC的配置文件中配置HandlerMapping的detectHandlerMethodsInAncestorContexts属性为true即可（这里需要根据具体项目看使用的是哪种HandlerMapping），让它检测父容器的bean。如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;&gt;<br>  &lt;property name=&quot;detectHandlerMethodsInAncestorContexts&quot;&gt;<br>      &lt;value&gt;true&lt;/value&gt;<br>  &lt;/property&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>但在实际工程中会包括很多配置，我们按照官方推荐根据不同的业务模块来划分不同容器中注册不同类型的Bean：</p><p>Spring父容器负责所有其他非@Controller注解的Bean的注册，而SpringMVC只负责@Controller注解的Bean的注册，使得他们各负其责、明确边界。配置方式如下</p><p>1、在applicationContext.xml中配置:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!-- Spring容器中注册非@controller注解的Bean --&gt;<br>&lt;context:component-scan base-package=&quot;com.hafiz.www&quot;&gt;<br>  &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;<br>&lt;/context:component-scan&gt;<br></code></pre></td></tr></table></figure></p><p>2、applicationContext-MVC.xml中配置<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!-- SpringMVC容器中只注册带有@controller注解的Bean --&gt;<br>&lt;context:component-scan base-package=&quot;com.hafiz.www&quot; use-default-filters=&quot;false&quot;&gt;<br>  &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;<br>&lt;/context:component-scan&gt;<br></code></pre></td></tr></table></figure></p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>这样我们在清楚了Spring和SpringMVC的父子容器关系、以及扫描注册的原理以后，根据官方建议我们就可以很好把不同类型的Bean分配到不同的容器中进行管理。再出现Bean找不到或者SpringMVC不能跳转以及事务的配置失效的问题，我们就可以很快的定位以及解决问题了。很开心，有木有~</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_12</title>
      <link href="/2018/10/18/spring-annotation-day-12/"/>
      <url>/2018/10/18/spring-annotation-day-12/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><h3 id="AOP介绍"><a href="#AOP介绍" class="headerlink" title="AOP介绍"></a>AOP介绍</h3><p>AOP是Spring 框架的一个关键组件，全称为Aspect-Oriented-Programming（面向切面编程），目前已是一种比较成熟的编程方式。</p><p>AOP采取横向抽取机制，将分散在各个方法中的重复代码提取出来，然后在编译或运行的时候，再将这些代码应用到需要执行的地方。</p><p><strong>注：提取出来的代码应用到需要执行的地方，并不会把源代码加到需要的地方执行，即源代码文件不会更改，但是它会影响最终的机器编译代码</strong></p><p>意思就是，有一些通用功能的代码可以提取出来，然后在使用的时候应用进去就可以了，比如表单验证和日志记录等等。</p><h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><p>Aspect（切面）</p><p>通常指封装起来用于插入到指定位置实现某项功能的类</p><p>Join point（连接点）</p><p>在SpringAOP中，连接点指方法的调用</p><p>Pointcut（切入点）</p><p>切面与程序流程的交叉点，即那些需要处理的连接点，通常在程序中，切入点指的是类或者方法名</p><p>Advice（通知/增强处理）</p><p>就是程序实际运行之前或之后执行的方法，也就是AOP加入的代码</p><p>Target Object（目标对象）</p><p>即需要加入AOP代码的对象</p><p>Proxy（代理）</p><p>AOP框架动态生成的一个对象，该对象可以作为目标对象使用</p><p>Weaving（织入）</p><p>把切面连接到其它的应用程序类型或者对象上，并创建一个需要Advice对象的过程</p><h3 id="AOP的例子（JDK代理）"><a href="#AOP的例子（JDK代理）" class="headerlink" title="AOP的例子（JDK代理）"></a>AOP的例子（JDK代理）</h3><p>1）首先建立一个java工程</p><p><img src="/images/20181018211302.png" style="width:50%"></p><p>UserDao接口:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package com.aop.jdk;<br><br>public interface UserDao &#123;<br> <br> public void addUser();<br> <br>&#125;<br></code></pre></td></tr></table></figure></p><p>UserDaoImpl:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package com.aop.jdk;<br><br>public class UserDaoImpl implements UserDao &#123;<br><br> @Override<br> public void addUser() &#123;<br>   <br>   System.out.println(&quot;新增用户&quot;);<br> &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure></p><p>JdkProxy:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package com.aop.jdk;<br><br>import java.lang.reflect.InvocationHandler;<br>import java.lang.reflect.Method;<br>import java.lang.reflect.Proxy;<br><br>import com.aop.aspect.MyAspect;<br><br>/**<br>* JDK代理类<br>*/<br>public class JdkProxy implements InvocationHandler&#123;<br> <br> // 声明目标类接口<br> private UserDao userDao;<br> <br> // 创建代理方法<br> public  Object createProxy(UserDao userDao) &#123;<br>   <br>   this.userDao = userDao;<br>   <br>   // 1.类加载器<br>   ClassLoader classLoader = JdkProxy.class.getClassLoader();<br>   <br>   // 2.被代理对象实现的所有接口<br>   @SuppressWarnings(&quot;rawtypes&quot;)<br>   Class[] clazz = userDao.getClass().getInterfaces();<br>   <br>   // 3.使用代理类，进行增强，返回的是代理后的对象<br>   return  Proxy.newProxyInstance(classLoader,clazz,this);<br>   <br> &#125;<br> <br> /*<br>  * 所有动态代理类的方法调用，都会交由invoke()方法去处理<br>  * proxy 被代理后的对象 <br>  * method 将要执行的方法<br>  * args 执行方法时需要的参数<br>  */<br> @Override<br> public Object invoke(Object proxy, Method method, Object[] args) <br>     throws Throwable &#123;<br>   <br>   // 声明切面<br>   MyAspect myAspect = new MyAspect();<br>   <br>   // 指定位置程序执行前执行这个方法<br>   myAspect.start();<br>   <br>   // 在目标类上调用方法<br>   Object obj = method.invoke(userDao, args);<br>   <br>   // 指定位置程序执行结束后执行<br>   myAspect.end();<br>   <br>   return obj;<br> &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure></p><p>MyAspect:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package com.aop.aspect;<br><br>/**<br>*  切面<br>*/<br>public class MyAspect &#123;<br> <br> public void start()&#123;<br>   System.out.println(&quot;模拟事务处理功能 ...&quot;);<br> &#125;<br> <br> public void end()&#123;<br>   System.out.println(&quot;程序结束后执行此处 ...&quot;);<br> &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure></p><p>JdkTest:</p><p>测试结果项目编写完之后运行该类</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package com.aop.test;<br><br>import com.aop.jdk.JdkProxy;<br>import com.aop.jdk.UserDao;<br>import com.aop.jdk.UserDaoImpl;<br><br>public class JdkTest &#123;<br> <br> public static void main(String[] args) &#123;<br>   <br>   // 创建代理对象<br>   JdkProxy jdkProxy = new JdkProxy();<br>        // 创建目标对象<br>   UserDao userDao= new UserDaoImpl();<br>   // 从代理对象中获取增强后的目标对象<br>   UserDao userDao1 = (UserDao) jdkProxy.createProxy(userDao);<br>   // 执行方法<br>   userDao1.addUser();<br> &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>运行之后，我们可以看到以下结果：<br><img src="/images/20181018211845.png" style="width:50%"></p><hr><p>我们可以看到，在我们执行新增用户的方法时，依据我们AOP编程，系统自动执行了start方法和end方法</p><p>在实际运用中，我们可以把一些通用的方法放到start和end的位置，在需要的方法处加入切面即可</p><p>此外，建议大家再了解下AspectJ</p><p>AspectJ实现AOP有两种方式：一种是基于XML的声明式，另一种是基于注解的声明式</p><p>基于XML的声明式AspectJ要便捷一些，但是存在配置信息多的缺点</p><p>基于注解的声明式AspectJ则通过注解的方式减少了很多配置信息</p><h3 id="Spring中的AOP使用"><a href="#Spring中的AOP使用" class="headerlink" title="Spring中的AOP使用"></a>Spring中的AOP使用</h3><p>1）创建新的配置类MainConfigOfAOP<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class MainConfigOfAOP &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 在com.liuzhuo.aop包下，创建MathCalculator类<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MathCalculator &#123;<br><br>    public int div(int a, int b) &#123;<br>        return a / b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 在com.liuzhuo.aop包下，创建切面类MathCalculator<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class LogAspects &#123;<br><br>    public void logStart()&#123;<br>        System.out.println(&quot;方法调用之前------&quot;);<br>    &#125;<br><br>    public void logEnd()&#123;<br>        System.out.println(&quot;方法调用之后-------&quot;);<br>    &#125;<br><br>    public void logReturn()&#123;<br>        System.out.println(&quot;方法成功返回之后------&quot;);<br>    &#125;<br><br>    public void logThrowing()&#123;<br>        System.out.println(&quot;方法出现异常之后------&quot;);<br>    &#125;<br><br>    public void logRound()&#123;<br>        //环绕方法<br>        System.out.println(&quot;环绕：方法调用之前----&quot;);<br>        System.out.println(&quot;环绕：方法调用之后----&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 添加AOP的依赖，在pom文件中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">      <br>&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;<br>    &lt;version&gt;5.1.1.RELEASE&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>4) 将切面与目标方法进行连接：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Aspect<br>public class LogAspects &#123;<br><br>    @Pointcut(&quot;execution(public int com.liuzhuo.aop.MathCalculator.div(int,int))&quot;)<br>    public void pointCut() &#123;<br>    &#125;<br><br>    //调用本类的切点<br>    @Before(&quot;pointCut()&quot;)<br>    public void logStart() &#123;<br>        System.out.println(&quot;方法调用之前------&quot;);<br>    &#125;<br><br>    //调用外面类的切点<br>    @After(&quot;com.liuzhuo.aop.LogAspects.pointCut()&quot;)<br>    public void logEnd() &#123;<br>        System.out.println(&quot;方法调用之后-------&quot;);<br>    &#125;<br><br>    @AfterReturning(value = &quot;pointCut()&quot;, returning = &quot;returns&quot;)<br>    public void logReturn(Object returns) &#123;<br>        System.out.println(&quot;方法成功返回之后------:&quot; + returns);<br>    &#125;<br><br>    @AfterThrowing(value = &quot;pointCut()&quot;, throwing = &quot;e&quot;)<br>    public void logThrowing(Exception e) &#123;<br>        System.out.println(&quot;方法出现异常之后------:&quot; + e);<br>    &#125;<br><br>    @Around(&quot;pointCut()&quot;)<br>    public Object logRound(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;<br>        //环绕方法<br>        System.out.println(&quot;环绕：方法调用之前----&quot;);<br>        Object proceed = proceedingJoinPoint.proceed();<br>        System.out.println(&quot;环绕：方法调用之后----&quot;);<br>        return proceed;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5) 将切面和目标类注入到容器中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class MainConfigOfAOP &#123;<br><br>    @Bean<br>    public MathCalculator mathCalculator() &#123;<br>        return new MathCalculator();<br>    &#125;<br><br>    @Bean<br>    public LogAspects logAspects() &#123;<br>        return new LogAspects();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>6) <strong>开启Aspect的注解驱动</strong>：@EnableAspectJAutoProxy<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@EnableAspectJAutoProxy //开启AOP注解驱动<br>public class MainConfigOfAOP &#123;<br><br>    @Bean<br>    public MathCalculator mathCalculator() &#123;<br>        return new MathCalculator();<br>    &#125;<br><br>    @Bean<br>    public LogAspects logAspects() &#123;<br>        return new LogAspects();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>7) 创建新的测试类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IoCTest_AOP &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAOP.class);<br><br>        //不要自己创建MathCalculator类<br>        //MathCalculator mathCalculator = new MathCalculator();<br>        //mathCalculator.div(1, 1);<br><br>        MathCalculator mathCalculator = applicationContext.getBean(MathCalculator.class);<br>        mathCalculator.div(1, 1);<br><br>        applicationContext.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>8) 运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">环绕：方法调用之前----<br>方法调用之前------<br>div:正在执行-----<br>环绕：方法调用之后----<br>方法调用之后-------<br>方法成功返回之后------:1<br>十月 18, 2018 10:03:03 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@3a4afd8d: startup date [Thu Oct 18 22:03:02 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>将业务逻辑组件和切面类都加入到容器中，告诉Spring哪个是切面类(Aspect)  </li><li>在切面类上的每一个通知方法上标注通知注解，告诉Spring何时何地运行（切入点表达式）</li><li>开启基于注解的AOP模式：@EnableAspectJAutoProxy</li></ol>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Bean的生命周期</title>
      <link href="/2018/10/18/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/10/18/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>Spring作为当前Java最流行、最强大的轻量级框架，受到了程序员的热烈欢迎。准确的了解Spring Bean的生命周期是非常必要的。</p><p>我们通常使用ApplicationContext作为Spring容器。这里，我们讲的也是 ApplicationContext中Bean的生命周期。而实际上BeanFactory也是差不多的，只不过处理器需要手动注册。</p><h3 id="一、生命周期流程图："><a href="#一、生命周期流程图：" class="headerlink" title="一、生命周期流程图："></a>一、生命周期流程图：</h3><p>Spring Bean的完整生命周期从创建Spring容器开始，直到最终Spring容器销毁Bean，这其中包含了一系列关键点。<br><img src="/images/20181018162309.png"><br><img src="/images/20181018162419.png"></p><p>若容器注册了以上各种接口，程序那么将会按照以上的流程进行。下面将仔细讲解各接口作用。</p><h3 id="二、各种接口方法分类"><a href="#二、各种接口方法分类" class="headerlink" title="二、各种接口方法分类"></a>二、各种接口方法分类</h3><p>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：</p><p>1、Bean自身的方法:这个包括了Bean本身调用的方法和通过配置文件中<bean>的init-method和destroy-method指定的方法</bean></p><p>2、Bean级生命周期接口方法:这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法</p><p>3、容器级生命周期接口方法:这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</p><p>4、工厂后处理器接口方法:这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</p><h3 id="三、演示"><a href="#三、演示" class="headerlink" title="三、演示"></a>三、演示</h3><p>我们用一个简单的Spring Bean来演示一下Spring Bean的生命周期。</p><p>1、首先是一个简单的Spring Bean，调用Bean自身的方法和Bean级生命周期接口方法，为了方便演示，它实现了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这4个接口，同时有2个方法，对应配置文件中<bean>的init-method和destroy-method。如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package springBeanTest;<br><br>import org.springframework.beans.BeansException;<br>import org.springframework.beans.factory.BeanFactory;<br>import org.springframework.beans.factory.BeanFactoryAware;<br>import org.springframework.beans.factory.BeanNameAware;<br>import org.springframework.beans.factory.DisposableBean;<br>import org.springframework.beans.factory.InitializingBean;<br><br>/**<br>* @author qsk<br>*/<br>public class Person implements BeanFactoryAware, BeanNameAware,<br>       InitializingBean, DisposableBean &#123;<br><br>   private String name;<br>   private String address;<br>   private int phone;<br><br>   private BeanFactory beanFactory;<br>   private String beanName;<br><br>   public Person() &#123;<br>       System.out.println(&quot;【构造器】调用Person的构造器实例化&quot;);<br>   &#125;<br><br>   public String getName() &#123;<br>       return name;<br>   &#125;<br><br>   public void setName(String name) &#123;<br>       System.out.println(&quot;【注入属性】注入属性name&quot;);<br>       this.name = name;<br>   &#125;<br><br>   public String getAddress() &#123;<br>       return address;<br>   &#125;<br><br>   public void setAddress(String address) &#123;<br>       System.out.println(&quot;【注入属性】注入属性address&quot;);<br>       this.address = address;<br>   &#125;<br><br>   public int getPhone() &#123;<br>       return phone;<br>   &#125;<br><br>   public void setPhone(int phone) &#123;<br>       System.out.println(&quot;【注入属性】注入属性phone&quot;);<br>       this.phone = phone;<br>   &#125;<br><br>   @Override<br>   public String toString() &#123;<br>       return &quot;Person [address=&quot; + address + &quot;, name=&quot; + name + &quot;, phone=&quot;<br>               + phone + &quot;]&quot;;<br>   &#125;<br><br>   // 这是BeanFactoryAware接口方法<br>   @Override<br>   public void setBeanFactory(BeanFactory arg0) throws BeansException &#123;<br>       System.out<br>               .println(&quot;【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()&quot;);<br>       this.beanFactory = arg0;<br>   &#125;<br><br>   // 这是BeanNameAware接口方法<br>   @Override<br>   public void setBeanName(String arg0) &#123;<br>       System.out.println(&quot;【BeanNameAware接口】调用BeanNameAware.setBeanName()&quot;);<br>       this.beanName = arg0;<br>   &#125;<br><br>   // 这是InitializingBean接口方法<br>   @Override<br>   public void afterPropertiesSet() throws Exception &#123;<br>       System.out<br>               .println(&quot;【InitializingBean接口】调用InitializingBean.afterPropertiesSet()&quot;);<br>   &#125;<br><br>   // 这是DiposibleBean接口方法<br>   @Override<br>   public void destroy() throws Exception &#123;<br>       System.out.println(&quot;【DiposibleBean接口】调用DiposibleBean.destory()&quot;);<br>   &#125;<br><br>   // 通过&lt;bean&gt;的init-method属性指定的初始化方法<br>   public void myInit() &#123;<br>       System.out.println(&quot;【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法&quot;);<br>   &#125;<br><br>   // 通过&lt;bean&gt;的destroy-method属性指定的初始化方法<br>   public void myDestory() &#123;<br>       System.out.println(&quot;【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法&quot;);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></bean></p><p>2、接下来是演示BeanPostProcessor接口的方法，如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package springBeanTest;<br><br>import org.springframework.beans.BeansException;<br>import org.springframework.beans.factory.config.BeanPostProcessor;<br><br>public class MyBeanPostProcessor implements BeanPostProcessor &#123;<br><br>   public MyBeanPostProcessor() &#123;<br>       super();<br>       System.out.println(&quot;这是BeanPostProcessor实现类构造器！！&quot;);<br>       // TODO Auto-generated constructor stub<br>   &#125;<br><br>   @Override<br>   public Object postProcessAfterInitialization(Object arg0, String arg1)<br>           throws BeansException &#123;<br>       System.out<br>       .println(&quot;BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！&quot;);<br>       return arg0;<br>   &#125;<br><br>   @Override<br>   public Object postProcessBeforeInitialization(Object arg0, String arg1)<br>           throws BeansException &#123;<br>       System.out<br>       .println(&quot;BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！&quot;);<br>       return arg0;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如上，BeanPostProcessor接口包括2个方法: postProcessAfterInitialization和postProcessBeforeInitialization，这两个方法的第一个参数都是要处理的Bean对象，第二个参数都是Bean的name。返回值也都是要处理的Bean对象。这里要注意。</strong></p><p>3、InstantiationAwareBeanPostProcessor 接口本质是BeanPostProcessor的子接口，一般我们继承Spring为其提供的适配器类InstantiationAwareBeanPostProcessor Adapter来使用它，如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package springBeanTest;<br><br>import java.beans.PropertyDescriptor;<br><br>import org.springframework.beans.BeansException;<br>import org.springframework.beans.PropertyValues;<br>import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;<br><br>public class MyInstantiationAwareBeanPostProcessor extends<br>       InstantiationAwareBeanPostProcessorAdapter &#123;<br><br>   public MyInstantiationAwareBeanPostProcessor() &#123;<br>       super();<br>       System.out<br>               .println(&quot;这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！&quot;);<br>   &#125;<br><br>   // 接口方法、实例化Bean之前调用<br>   @Override<br>   public Object postProcessBeforeInstantiation(Class beanClass,<br>           String beanName) throws BeansException &#123;<br>       System.out<br>               .println(&quot;InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法&quot;);<br>       return null;<br>   &#125;<br><br>   // 接口方法、实例化Bean之后调用<br>   @Override<br>   public Object postProcessAfterInitialization(Object bean, String beanName)<br>           throws BeansException &#123;<br>       System.out<br>               .println(&quot;InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法&quot;);<br>       return bean;<br>   &#125;<br><br>   // 接口方法、设置某个属性时调用<br>   @Override<br>   public PropertyValues postProcessPropertyValues(PropertyValues pvs,<br>           PropertyDescriptor[] pds, Object bean, String beanName)<br>           throws BeansException &#123;<br>       System.out<br>               .println(&quot;InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法&quot;);<br>       return pvs;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>这个有3个方法，其中第二个方法postProcessAfterInitialization就是重写了BeanPostProcessor的方法。第三个方法postProcessPropertyValues用来操作属性，返回值也应该是PropertyValues对象。</strong></p><p>4、演示工厂后处理器接口方法，如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package springBeanTest;<br><br>import org.springframework.beans.BeansException;<br>import org.springframework.beans.factory.config.BeanDefinition;<br>import org.springframework.beans.factory.config.BeanFactoryPostProcessor;<br>import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;<br><br>public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;<br><br>   public MyBeanFactoryPostProcessor() &#123;<br>       super();<br>       System.out.println(&quot;这是BeanFactoryPostProcessor实现类构造器！！&quot;);<br>   &#125;<br><br>   @Override<br>   public void postProcessBeanFactory(ConfigurableListableBeanFactory arg0)<br>           throws BeansException &#123;<br>       System.out.println(&quot;BeanFactoryPostProcessor调用postProcessBeanFactory方法&quot;);<br>       BeanDefinition bd = arg0.getBeanDefinition(&quot;person&quot;);<br>       bd.getPropertyValues().addPropertyValue(&quot;phone&quot;, &quot;110&quot;);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>5、配置文件如下beans.xml，很简单，使用ApplicationContext处理器不用手动注册：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br><br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;<br>   xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;<br>   xsi:schemaLocation=&quot;<br>           http://www.springframework.org/schema/beans <br>           http://www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;&gt;<br><br>   &lt;bean id=&quot;beanPostProcessor&quot; class=&quot;springBeanTest.MyBeanPostProcessor&quot;&gt;<br>   &lt;/bean&gt;<br><br>   &lt;bean id=&quot;instantiationAwareBeanPostProcessor&quot; class=&quot;springBeanTest.MyInstantiationAwareBeanPostProcessor&quot;&gt;<br>   &lt;/bean&gt;<br><br>   &lt;bean id=&quot;beanFactoryPostProcessor&quot; class=&quot;springBeanTest.MyBeanFactoryPostProcessor&quot;&gt;<br>   &lt;/bean&gt;<br>   <br>   &lt;bean id=&quot;person&quot; class=&quot;springBeanTest.Person&quot; init-method=&quot;myInit&quot;<br>       destroy-method=&quot;myDestory&quot; scope=&quot;singleton&quot; p:name=&quot;张三&quot; p:address=&quot;广州&quot;<br>       p:phone=&quot;15900000000&quot; /&gt;<br><br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure></p><p>6、下面测试一下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">package springBeanTest;<br><br>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;<br><br>public class BeanLifeCycle &#123;<br><br>   public static void main(String[] args) &#123;<br><br>       System.out.println(&quot;现在开始初始化容器&quot;);<br>       <br>       ApplicationContext factory = new ClassPathXmlApplicationContext(&quot;springBeanTest/beans.xml&quot;);<br>       System.out.println(&quot;容器初始化成功&quot;);    <br>       //得到Preson，并使用<br>       Person person = factory.getBean(&quot;person&quot;,Person.class);<br>       System.out.println(person);<br>       <br>       System.out.println(&quot;现在开始关闭容器！&quot;);<br>       ((ClassPathXmlApplicationContext)factory).registerShutdownHook();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关闭容器使用的是实际是AbstractApplicationContext的钩子方法。</p><p>我们来看一下结果：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs undefined">现在开始初始化容器<br>2014-5-18 15:46:20 org.springframework.context.support.AbstractApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@19a0c7c: startup date [Sun May 18 15:46:20 CST 2014]; root of context hierarchy<br>2014-5-18 15:46:20 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions<br>信息: Loading XML bean definitions from class path resource [springBeanTest/beans.xml]<br>这是BeanFactoryPostProcessor实现类构造器！！<br>BeanFactoryPostProcessor调用postProcessBeanFactory方法<br>这是BeanPostProcessor实现类构造器！！<br>这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！<br>2014-5-18 15:46:20 org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletons<br>信息: Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@9934d4: defining beans [beanPostProcessor,instantiationAwareBeanPostProcessor,beanFactoryPostProcessor,person]; root of factory hierarchy<br>InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法<br>【构造器】调用Person的构造器实例化<br>InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法<br>【注入属性】注入属性address<br>【注入属性】注入属性name<br>【注入属性】注入属性phone<br>【BeanNameAware接口】调用BeanNameAware.setBeanName()<br>【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()<br>BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！<br>【InitializingBean接口】调用InitializingBean.afterPropertiesSet()<br>【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法<br>BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！<br>InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法<br>容器初始化成功<br>Person [address=广州, name=张三, phone=110]<br>现在开始关闭容器！<br>【DiposibleBean接口】调用DiposibleBean.destory()<br>【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IntelliJ Idea 常用快捷键 列表(实战终极总结！！！！)</title>
      <link href="/2018/10/18/idea/"/>
      <url>/2018/10/18/idea/</url>
      
        <content type="html"><![CDATA[<h3 id="自动代码"><a href="#自动代码" class="headerlink" title="自动代码"></a>自动代码</h3><p>常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码 。</p><p>例如要输入for(User user : users) 只需输入user.for+Tab ;</p><p><strong>再比如，要输入Date birthday = user.getBirthday() 只需输入user.getBirthday().var+Tab即可。<br>代码标签输入完成后，按Tab，生成代码。</strong></p><p>Ctrl+Alt+O 优化导入的类和包 </p><p>Alt+Insert 生成代码(如get,set方法,构造函数等)   或者右键（Generate） </p><p>fori/sout/psvm + Tab  </p><p>Ctrl+Alt+T  生成try catch  或者 Alt+enter </p><p>CTRL+ALT+T  把选中的代码放在 TRY{} IF{} ELSE{} 里 </p><p>Ctrl + O 重写方法  </p><p>Ctrl + I 实现方法 </p><p>Ctrl+shift+U 大小写转化  </p><p>ALT+回车    导入包,自动修正  </p><p>ALT+/       代码提示 </p><p>CTRL+J      自动代码  </p><p>Ctrl+Shift+J，整合两行为一行 </p><p>CTRL+空格   代码提示  </p><p>CTRL+SHIFT+SPACE 自动补全代码  </p><p>CTRL+ALT+L  格式化代码  </p><p>CTRL+ALT+I  自动缩进  </p><p>CTRL+ALT+O  优化导入的类和包  </p><p>ALT+INSERT  生成代码(如GET,SET方法,构造函数等)  </p><p>CTRL+E      最近更改的代码  </p><p>CTRL+ALT+SPACE  类名或接口名提示  </p><p>CTRL+P   方法参数提示  </p><p>CTRL+Q，可以看到当前方法的声明 </p><p>Shift+F6  重构-重命名 (包、类、方法、变量、甚至注释等) </p><p>Ctrl+Alt+V 提取变量 </p><h3 id="查询快捷键"><a href="#查询快捷键" class="headerlink" title="查询快捷键"></a>查询快捷键</h3><p>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 </p><p>CTRL+ALT+ left/right 前后导航编辑过的地方 </p><p>ALT+7  靠左窗口显示当前文件的结构 </p><p>Ctrl+F12 浮动显示当前文件的结构 </p><p>ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 </p><p>CTRL+ALT+F7  找到你的函数或者变量或者类的所有引用到的地方 </p><p>Ctrl+Shift+Alt+N 查找类中的方法或变量 </p><p>双击SHIFT 在项目的所有目录查找文件 </p><p>Ctrl+N   查找类 </p><p>Ctrl+Shift+N 查找文件 </p><p>CTRL+G   定位行  </p><p>CTRL+F   在当前窗口查找文本  </p><p>CTRL+SHIFT+F  在指定窗口查找文本  </p><p>CTRL+R   在 当前窗口替换文本  </p><p>CTRL+SHIFT+R  在指定窗口替换文本  </p><p>ALT+SHIFT+C  查找修改的文件  </p><p>CTRL+E   最近打开的文件  </p><p>F3   向下查找关键字出现位置  </p><p>SHIFT+F3  向上一个关键字出现位置  </p><p>选中文本，按Alt+F3 ，高亮相同文本，F3逐个往下查找相同文本 </p><p>F4   查找变量来源  </p><p>CTRL+SHIFT+O  弹出显示查找内容 </p><p>Ctrl+W 选中代码，连续按会有其他效果 </p><p>F2 或Shift+F2 高亮错误或警告快速定位 </p><p>Ctrl+Up/Down 光标跳转到第一行或最后一行下 </p><p>Ctrl+B 快速打开光标处的类或方法  </p><p>CTRL+ALT+B  找所有的子类  </p><p>CTRL+SHIFT+B  找变量的类  </p><p>Ctrl+Shift+上下键  上下移动代码 </p><p>Ctrl+Alt+ left/right 返回至上次浏览的位置 </p><p>Ctrl+X 删除行 </p><p>Ctrl+D 复制行 </p><p>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>…</em>/ ） </p><p>Ctrl+H 显示类结构图 </p><p>Ctrl+Q 显示注释文档 </p><p>Alt+F1 查找代码所在位置 </p><p>Alt+1 快速打开或隐藏工程面板 </p><p>Alt+ left/right 切换代码视图 </p><p>ALT+ ↑/↓  在方法间快速移动定位  </p><p>CTRL+ALT+ left/right 前后导航编辑过的地方 </p><p>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 </p><p>Alt+6    查找TODO </p><h3 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h3><p>SHIFT+ENTER 另起一行 </p><p>CTRL+Z   倒退(撤销) </p><p>CTRL+SHIFT+Z  向前(取消撤销) </p><p>CTRL+ALT+F12  资源管理器打开文件夹  </p><p>ALT+F1   查找文件所在目录位置  </p><p>SHIFT+ALT+INSERT 竖编辑模式  </p><p>CTRL+F4  关闭当前窗口 </p><p>Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 </p><p>Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） </p><h3 id="svn快捷键"><a href="#svn快捷键" class="headerlink" title="svn快捷键"></a>svn快捷键</h3><p>ctrl+k 提交代码到SVN </p><p>ctrl+t 更新代码 </p><h3 id="调试快捷键"><a href="#调试快捷键" class="headerlink" title="调试快捷键"></a>调试快捷键</h3><p>其实常用的 就是F8 F7 F9 最值得一提的就是Drop Frame 可以让运行过的代码从头再来。</p><p>alt+F8    debug时选中查看值 </p><p>Alt+Shift+F9，选择 Debug </p><p>Alt+Shift+F10，选择 Run </p><p>Ctrl+Shift+F9，编译 </p><p>Ctrl+Shift+F8，查看断点 </p><p>F7，步入 </p><p>Shift+F7，智能步入 </p><p>Alt+Shift+F7，强制步入 </p><p>F8，步过 </p><p>Shift+F8，步出 </p><p>Alt+Shift+F8，强制步过 </p><p>Alt+F9，运行至光标处 </p><p>Ctrl+Alt+F9，强制运行至光标处 </p><p>F9，恢复程序 </p><p>Alt+F10，定位到断点 </p><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>Ctrl+Alt+Shift+T，弹出重构菜单 </p><p>Shift+F6，重命名 </p><p>F6，移动 </p><p>F5，复制 </p><p>Alt+Delete，安全删除 </p><p>Ctrl+Alt+N，内联 </p><h3 id="十大Intellij-IDEA快捷键"><a href="#十大Intellij-IDEA快捷键" class="headerlink" title="十大Intellij IDEA快捷键"></a>十大Intellij IDEA快捷键</h3><p>Intellij IDEA中有很多快捷键让人爱不释手，stackoverflow上也有一些有趣的讨论。每个人都有自己的最爱，想排出个理想的榜单还真是困难。 </p><p>以前也整理过Intellij的快捷键，这次就按照我日常开发时的使用频率，简单分类列一下我最喜欢的十大快捷-神-键吧。 </p><p>1 <strong>智能提示:</strong><br>Intellij首当其冲的当然就是Intelligence智能！基本的代码提示用Ctrl+Space，还有更智能地按类型信息提示Ctrl+Shift+Space，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。</p><p>用F2/ Shift+F2移动到有错误的代码，Alt+Enter快速修复(即Eclipse中的Quick Fix功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲Ctrl+Shift+Enter就能自动补全末尾的字符。而且不只是括号，例如敲完if/for时也可以自动补上{}花括号。 </p><p>最后要说一点，Intellij能够智能感知Spring、Hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。 </p><p>2 <strong>重构:</strong><br>Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。 </p><p>切入正题，先说一个无敌的重构功能大汇总快捷键Ctrl+Shift+Alt+T，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如Shift+F6直接就是改名，Ctrl+Alt+V则是提取变量。 </p><p>3 <strong>代码生成：</strong><br>这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码，用Ctrl+J可以查看所有模板。后面“辅助”一节中将会讲到Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter/setter。 </p><p>另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入user.for+Tab。再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。 </p><p>4 <strong>编辑：</strong><br>编辑中不得不说的一大神键就是能够自动按语法选中代码的Ctrl+W以及反向的Ctrl+Shift+W了。此外，Ctrl+Left/Right移动光标到前/后单词，Ctrl+[/]移动到前/后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left/Right/[]加上Shift的话就能选中跳跃范围内的代码。Alt+Forward/Backward移动到前/后方法。还有些非常普通的像Ctrl+Y删除行、Ctrl+D复制行、Ctrl+折叠代码就不多说了。 </p><p>关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。另外，Intellij的书签功能也是不错的，用Ctrl+Shift+Num定义1-10书签(再次按这组快捷键则是删除书签)，然后通过Ctrl+Num跳转。这避免了多次使用前/下一编辑位置Ctrl+Left/Right来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。</p><p>5 <strong>查找打开：</strong><br>类似Eclipse，Intellij的Ctrl+N/Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按Shift+Shift即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。 </p><p>类的继承关系则可用Ctrl+H打开类层次窗口，在继承层次上跳转则用Ctrl+B/Ctrl+Alt+B分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用Ctrl+F12。 </p><p>要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用Ctrl+F/Ctrl+Shift+F在当前窗口或全工程中查找，再配合F3/Shift+F3前后移动到下一匹配处。 </p><p>Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。 </p><p>6 <strong>其他辅助：</strong><br>以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有：</p><p>Ø  命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。 </p><p>Ø  新建：Alt+Insert可以新建类、方法等任何东西。 </p><p>Ø  格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。 </p><p>Ø  切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。 </p><p>Ø  单元测试：Ctrl+Alt+T创建单元测试用例。 </p><p>Ø  运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。 </p><p>Ø  调试：F7/F8/F9分别对应Step into，Step over，Continue。<br><i><strong>此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。</strong> </i></p><p>Ø  Top #10切来切去：Ctrl+Tab </p><p>Ø  Top #9选你所想：Ctrl+W </p><p>Ø  Top #8代码生成：Template/Postfix +Tab </p><p>Ø  Top #7发号施令：Ctrl+Shift+A </p><p>Ø  Top #6无处藏身：Shift+Shift </p><p>Ø  Top #5自动完成：Ctrl+Shift+Enter </p><p>Ø  Top #4创造万物：Alt+Insert </p><p><strong>太难割舍，前三名并列吧！</strong></p><p>Ø  Top #1智能补全：Ctrl+Shift+Space </p><p>Ø  Top #1自我修复：Alt+Enter </p><p>Ø  Top #1重构一切：Ctrl+Shift+Alt+T </p><p>CTRL+ALT+ left/right 前后导航编辑过的地方<br>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方</p>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring_Ioc</title>
      <link href="/2018/10/18/Spring-Ioc/"/>
      <url>/2018/10/18/Spring-Ioc/</url>
      
        <content type="html"><![CDATA[<h3 id="广义的Ioc"><a href="#广义的Ioc" class="headerlink" title="广义的Ioc"></a>广义的Ioc</h3><p>面试被问烂的 Spring IOC(求求你别再问了)  </p><p>1）IoC(Inversion of Control) 控制反转，即“不用打电话过来，我们会打给你”。</p><p>两种实现： 依赖查找（DL）和 依赖注入（DI）。</p><p>IoC 和 DI 、DL 的关系（这个 DL，Avalon 和 EJB 就是使用的这种方式实现的 IoC）：</p><p><img src="/images/20181018125125.png"></p><p>2) DL 已经被抛弃，因为他需要用户自己去是使用 API 进行查找资源和组装对象。即有侵入性。  </p><p>3) DI 是 Spring 使用的方式，容器负责组件的装配。</p><p><strong>注意：</strong><br>Java 使用 DI 方式实现 IoC 的不止 Spring，包括 Google 的 Guice，还有一个冷门的 PicoContainer（极度轻量，但只提供 IoC）。</p><h3 id="Spring的IoC"><a href="#Spring的IoC" class="headerlink" title="Spring的IoC"></a>Spring的IoC</h3><ol><li>依赖注入</li><li>依赖检查</li><li>自动装配</li><li>支持集合</li><li>指定初始化方法和销毁方法</li><li>支持回调某些方法(但是需要实现Spring接口，略有侵入)</li></ol><p>其中，最重要的就是依赖注入，从 XML 的配置上说， 即 ref 标签。对应 Spring RuntimeBeanReference 对象。</p><p><strong>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</strong>  </p><p>那么， Spring 如何设计容器的呢？  </p><p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。  </p><ol><li>BeanFactory</li><li>ApplicationContext</li></ol><p>BeanFactory 粗暴简单，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。</p><p>ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。</p><p>例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。  </p><p>该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p><p>当然，除了这两个大接口，还有其他的辅助接口，但我今天不会花太多篇幅介绍他们。</p><p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，我这里通过常用的 ClassPathXmlApplicationContext 类，来展示整个容器的层级 UML 关系。</p><p><img src="/images/20181018130402.png"></p><p>有点复杂？ 先不要慌，我来解释一下。</p><p>最上面的 BeanFactory 知道吧？我就不讲了。</p><p>下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p><p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p><p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p><p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置。生命周期事件回调等。</p><font color="#00ffff" size="4">好，解释了低级容器和高级容器，我们可以看看一个 IoC 启动过程是什么样子的。说白了，就是 ClassPathXmlApplicationContext 这个类，在启动时，都做了啥。</font><p>下图是 ClassPathXmlApplicationContext 的构造过程，实际就是 Spring IoC 的初始化过程。<br><img src="/images/20181018131026.png"></p><p>注意，这里为了理解方便，有所简化。</p><p>这里再用文字来描述这个过程：</p><ol><li>用户构造 ClassPathXmlApplicationContext（简称 CPAC）</li><li>CPAC 首先访问了 “抽象高级容器” 的 final 的 refresh 方法，这个方法是模板方法。所以要回调子类（低级容器）的 refreshBeanFactory 方法，这个方法的作用是使用低级容器加载所有 BeanDefinition 和 Properties 到容器中。</li><li>低级容器加载成功后，高级容器开始处理一些回调，例如 Bean 后置处理器。回调 setBeanFactory 方法。或者注册监听器等，发布事件，实例化单例 Bean 等等功能，这些功能，随着 Spring 的不断升级，功能越来越多，很多人在这里迷失了方向）。</li></ol><p>简单说就是：</p><ol><li>低级容器 加载配置文件（从 XML，数据库，Applet），并解析成 BeanDefinition 到低级容器中。</li><li>加载成功后，高级容器启动高级功能，例如接口回调，监听器，自动实例化单例，发布事件等等功能。</li></ol><p><strong>所以，一定要把 “低级容器” 和“高级容器” 的区别弄清楚。不能一叶障目不见泰山。</strong></p><p>好，当我们创建好容器，就会使用 getBean 方法，获取 Bean，而 getBean 的流程如下：<br><img src="/images/20181018131432.png" heigth="50%"></p><p>从图可以看出，getBean 的操作都是在低级容器里操作的。其中有个递归操作，这个是什么意思呢？</p><font color="#00ffff" size="4"><br>假设：当 Bean_A 依赖着 Bean_B，而这个 Bean_A 在加载的时候，其配置的 ref = “Bean_B” 在解析的时候只是一个占位符，被放入了 Bean_A 的属性集合中，当调用 getBean 时，需要真正 Bean_B 注入到 Bean_A 内部时，就需要从容器中获取这个 Bean_B，因此产生了递归。<br></font><p>为什么不是在加载的时候，就直接注入呢？因为加载的顺序不同，很可能 Bean_A 依赖的 Bean_B 还没有加载好，也就无法从容器中获取，你不能要求用户把 Bean 的加载顺序排列好，这是不人道的。</p><p>所以，Spring 将其分为了 2 个步骤：</p><ol><li><p>加载所有的 Bean 配置成 BeanDefinition 到容器中，如果 Bean 有依赖关系，则使用占位符暂时代替。</p></li><li><p>然后，在调用 getBean 的时候，进行真正的依赖注入，即如果碰到了属性是 ref 的（占位符），那么就从容器里获取这个 Bean，然后注入到实例中 —— 称之为依赖注入。<br>可以看到，依赖注入实际上，只需要 “低级容器” 就可以实现。  </p></li></ol><p>这就是 IoC。</p><p>所以 ApplicationContext refresh 方法里面的操作不只是 IoC，是高级容器的所有功能（包括 IoC），IoC 的功能在低级容器里就可以实现。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p><ol><li><p>加载配置文件，解析成 BeanDefinition 放在 Map 里。</p></li><li><p>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</p></li></ol><p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p><p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p><p>可以预见，随着 Spring 的不断发展，高级容器的功能会越来越多。</p><font color="#00ffff" size="4"><br>诚然，了解 IoC 的过程，实际上为了了解 Spring 初始化时，各个接口的回调时机。例如 InitializingBean，BeanFactoryAware，ApplicationListener 等等接口，这些接口的作用，笔者之前写过一篇文章进行介绍，有兴趣可以看一下，关键字：Spring 必知必会 扩展接口。<br></font><p>但是请注意，实现 Spring 接口代表着你这个应用就绑定死 Spring 了！代表 Spring 具有侵入性！要知道，Spring 发布时，无侵入性就是他最大的宣传点之一 —— 即 IoC 容器可以随便更换，代码无需变动。而现如今，Spring 已然成为 J2EE 社区准官方解决方案，也没有了所谓的侵入性这个说法。因为他就是标准，和 Servlet 一样，你能不实现 Servlet 的接口吗？: -)</p><p>好了，下次如果再有面试官问 Spring IoC 初始化过程，就再也不会含糊其词、支支吾吾了！！！</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_11</title>
      <link href="/2018/10/17/spring-annotation-day-11/"/>
      <url>/2018/10/17/spring-annotation-day-11/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><h3 id="Profile注解"><a href="#Profile注解" class="headerlink" title="@Profile注解"></a>@Profile注解</h3><p>Profile：Spring为我们提供的可以根据当前环境，动态的激活和切换一系列组件的功能。</p><p>比如：开发环境、测试环境、生产环境；</p><p>根据不同是环境，我们自动切换我们的数据源。</p><p>1）添加c3p0的数据源和mysql的驱动依赖：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt;<br> &lt;dependency&gt;<br>     &lt;groupId&gt;com.mchange&lt;/groupId&gt;<br>     &lt;artifactId&gt;c3p0&lt;/artifactId&gt;<br>     &lt;version&gt;0.9.5.2&lt;/version&gt;<br> &lt;/dependency&gt;<br> &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;<br> &lt;dependency&gt;<br>     &lt;groupId&gt;mysql&lt;/groupId&gt;<br>     &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br>     &lt;version&gt;8.0.12&lt;/version&gt;<br> &lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>2) 创建数据源的配置dbconfig.properties：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">db.user=root<br>db.password=123456<br>db.driverClass=com.mysql.jdbc.Driver<br></code></pre></td></tr></table></figure></p><p>3) 创建新的配置类MainConfigOfProfile：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@PropertySource(value = &quot;classpath:/dbconfig.properties&quot;)<br>public class MainConfigOfProfile implements EmbeddedValueResolverAware &#123;<br><br>    @Value(&quot;$&#123;db.user&#125;&quot;)<br>    private String user;<br><br>    private StringValueResolver valueResolver;<br>    private String driverClass;<br><br>    @Override<br>    public void setEmbeddedValueResolver(StringValueResolver resolver) &#123;<br>        this.valueResolver = resolver;<br>        String driverClass = valueResolver.resolveStringValue(&quot;$&#123;db.driverClass&#125;&quot;);<br>        this.driverClass = driverClass;<br>    &#125;<br><br><br>    @Bean(&quot;testDataSource&quot;)<br>    public DataSource dataSourceTest(@Value(&quot;$&#123;db.password&#125;&quot;) String pwd) throws PropertyVetoException &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(user);<br>        dataSource.setPassword(pwd);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);<br>        dataSource.setDriverClass(driverClass);<br>        return dataSource;<br>    &#125;<br><br>    @Bean(&quot;devDataSource&quot;)<br>    public DataSource dataSourceDev() throws PropertyVetoException &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(user);<br>        dataSource.setPassword(&quot;123456&quot;);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/school&quot;);<br>        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);<br>        return dataSource;<br>    &#125;<br><br>    @Bean(&quot;proDataSource&quot;)<br>    public DataSource dataSourcePro() throws PropertyVetoException &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(&quot;root&quot;);<br>        dataSource.setPassword(&quot;123456&quot;);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/sell&quot;);<br>        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);<br>        return dataSource;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>上述，有三个不同环境的数据源，test，dev，pro数据源，使用了不同的方式来给数据源进行赋值。</p><p>4）创建新的测试类IoCTest_Profile:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IoCTest_Profile &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfProfile.class);<br>        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();<br>        for (String name : beanDefinitionNames) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5) 运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfigOfProfile<br>testDataSource<br>devDataSource<br>proDataSource<br></code></pre></td></tr></table></figure></p><p>说明数据源都已经注入到容器中了。</p><hr><p>现在我们需要根据不同的环境，来指定加载需要的配置。</p><p>1)使用@Profile注解，是个属性、类加上一个标记的，标记这个属性或者类是属于这个环境的，只有激活了这个环境，才能被注册到容器中，默认激活default的环境，即@Profile(“default”）.</p><p>2)写在配置类上的@Profile，只能在该环境激活的情况下，整个配置类才能起作用，不管配置类里面的Bean是否是符合当前环境。</p><p>3）没有标记环境的bean，在任何环境下都是加载的</p><p><strong>验证：</strong></p><p>1) 在配置类MainConfigOfProfile中，给三个数据源加上标记：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@PropertySource(value = &quot;classpath:/dbconfig.properties&quot;)<br>public class MainConfigOfProfile implements EmbeddedValueResolverAware &#123;<br><br>    @Value(&quot;$&#123;db.user&#125;&quot;)<br>    private String user;<br><br>    private StringValueResolver valueResolver;<br>    private String driverClass;<br><br>    @Override<br>    public void setEmbeddedValueResolver(StringValueResolver resolver) &#123;<br>        this.valueResolver = resolver;<br>        String driverClass = valueResolver.resolveStringValue(&quot;$&#123;db.driverClass&#125;&quot;);<br>        this.driverClass = driverClass;<br>    &#125;<br><br><br>    @Profile(&quot;test&quot;)<br>    @Bean(&quot;testDataSource&quot;)<br>    public DataSource dataSourceTest(@Value(&quot;$&#123;db.password&#125;&quot;) String pwd) throws PropertyVetoException &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(user);<br>        dataSource.setPassword(pwd);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);<br>        dataSource.setDriverClass(driverClass);<br>        return dataSource;<br>    &#125;<br><br>    @Profile(&quot;dev&quot;)<br>    @Bean(&quot;devDataSource&quot;)<br>    public DataSource dataSourceDev() throws PropertyVetoException &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(user);<br>        dataSource.setPassword(&quot;123456&quot;);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/school&quot;);<br>        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);<br>        return dataSource;<br>    &#125;<br><br>    @Profile(&quot;pro&quot;)<br>    @Bean(&quot;proDataSource&quot;)<br>    public DataSource dataSourcePro() throws PropertyVetoException &#123;<br>        ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>        dataSource.setUser(&quot;root&quot;);<br>        dataSource.setPassword(&quot;123456&quot;);<br>        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/sell&quot;);<br>        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);<br>        return dataSource;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 设置当前的环境：</p><p><strong>方法一：</strong>  </p><p> 配置虚拟机的运行参数。</p><p>-Dspring.profiles.active=test</p><p>运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfigOfProfile<br>testDataSource<br></code></pre></td></tr></table></figure></p><p>此时，容器中只有testDataSource数据源了。</p><hr><p>-Dspring.profiles.active=dev</p><p>运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfigOfProfile<br>devDataSource<br></code></pre></td></tr></table></figure></p><p>此时，容器中只有devDataSource数据源了。</p><p><strong>方法二：</strong>  </p><p>使用无参数的AnnotationConfigApplicationContext容器。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IoCTest_Profile &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        //1.无参数<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();<br>        //2.设置环境,这里激活了test和dev<br>        applicationContext.getEnvironment().setActiveProfiles(&quot;test&quot;,&quot;dev&quot;);<br>        //3.设置配置类<br>        applicationContext.register(MainConfigOfProfile.class);<br>        //4.刷新容器<br>        applicationContext.refresh();<br><br><br>        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();<br>        for (String name : beanDefinitionNames) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfigOfProfile<br>testDataSource<br>devDataSource<br></code></pre></td></tr></table></figure></p><p>这里，test和dev数据源被激活了。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_10</title>
      <link href="/2018/10/17/spring-annotation-day-10/"/>
      <url>/2018/10/17/spring-annotation-day-10/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>自定义组件想要使用Spring容器底层的一些组件(ApplicationContext,BeanFactory,xxx)  </p><p>自定义组件实现xxxAware，在创建对象的时候，会调用接口规定的方法注入相关组件，Aware会把Spring底层的一些组件注入到自定义的Bean中。</p><p>xxxAware:功能使用xxxAwareProcessor现实的，比如：ApplicationContextAware是用ApplicationContextAwareProcessor注入的。</p><h3 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h3><p>1）在com.liuzhuo.bean包，随便找个Bean来实验：</p><p>这里使用Red类来实验：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Red implements ApplicationContextAware &#123;<br><br>    private ApplicationContext applicationContext;<br><br>    @Override<br>    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;<br>        this.applicationContext = applicationContext;<br>        System.out.println(&quot;容器:&quot; + applicationContext.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2）将Red类注入到容器中，使用包扫描，修改MainConfigOfAutowired配置类：<br><strong>加入了com.liuzhuo.bean包的扫描</strong><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(value = &#123;&quot;com.liuzhuo.controller&quot;, &quot;com.liuzhuo.service&quot;, &quot;com.liuzhuo.dao&quot;,&quot;com.liuzhuo.bean&quot;&#125;)<br>public class MainConfigOfAutowired<br></code></pre></td></tr></table></figure></p><p>3) 运行测试类IocTest_Autowired：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocTest_Autowired &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAutowired.class);<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs undefined">org.springframework.context.event.internalEventListenerProcessor------postProcessBeforeInitialization<br>org.springframework.context.event.internalEventListenerProcessor------postProcessAfterInitialization<br>org.springframework.context.event.internalEventListenerFactory------postProcessBeforeInitialization<br>org.springframework.context.event.internalEventListenerFactory------postProcessAfterInitialization<br>mainConfigOfAutowired------postProcessBeforeInitialization<br>mainConfigOfAutowired------postProcessAfterInitialization<br>bookController------postProcessBeforeInitialization<br>bookController------postProcessAfterInitialization<br>bookDao2------postProcessBeforeInitialization<br>bookDao2------postProcessAfterInitialization<br>bookService------postProcessBeforeInitialization<br>bookService------postProcessAfterInitialization<br>bookDao------postProcessBeforeInitialization<br>bookDao------postProcessAfterInitialization<br>Cat constructer ···<br>cat------postProcessBeforeInitialization<br>Cat afterPropertiesSet ····<br>cat------postProcessAfterInitialization<br>Dog construct ····<br>dog------postProcessBeforeInitialization<br>Dog @PostConstruct ····<br>dog------postProcessAfterInitialization<br>容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:08:27 CST 2018]; root of context hierarchy<br>red------postProcessBeforeInitialization<br>red------postProcessAfterInitialization<br>Dog @PreDestroy ····<br>Cat destroy ····<br>十月 17, 2018 2:08:28 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:08:27 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>能观察到：</p><p><code>容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:08:27 CST 2018]; root of context hierarchy</code></p><p>说明在Red类中，注入了容器类。</p><p>5）验证是否是同一个容器，修改测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocTest_Autowired &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAutowired.class);<br>        System.out.println(applicationContext);<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>6) 运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs undefined">org.springframework.context.event.internalEventListenerProcessor------postProcessBeforeInitialization<br>org.springframework.context.event.internalEventListenerProcessor------postProcessAfterInitialization<br>org.springframework.context.event.internalEventListenerFactory------postProcessBeforeInitialization<br>org.springframework.context.event.internalEventListenerFactory------postProcessAfterInitialization<br>mainConfigOfAutowired------postProcessBeforeInitialization<br>mainConfigOfAutowired------postProcessAfterInitialization<br>bookController------postProcessBeforeInitialization<br>bookController------postProcessAfterInitialization<br>bookDao2------postProcessBeforeInitialization<br>bookDao2------postProcessAfterInitialization<br>bookService------postProcessBeforeInitialization<br>bookService------postProcessAfterInitialization<br>bookDao------postProcessBeforeInitialization<br>bookDao------postProcessAfterInitialization<br>Cat constructer ···<br>cat------postProcessBeforeInitialization<br>Cat afterPropertiesSet ····<br>cat------postProcessAfterInitialization<br>Dog construct ····<br>dog------postProcessBeforeInitialization<br>Dog @PostConstruct ····<br>dog------postProcessAfterInitialization<br>容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:14:10 CST 2018]; root of context hierarchy<br>red------postProcessBeforeInitialization<br>red------postProcessAfterInitialization<br>十月 17, 2018 2:14:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:14:10 CST 2018]; root of context hierarchy<br>org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:14:10 CST 2018]; root of context hierarchy<br>Dog @PreDestroy ····<br>Cat destroy ····<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>观察到：<br>容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: </p><p>org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf:</p><p>一样，都是@2f410acf，说明是一个容器。</p><hr><h3 id="BeanNameAware"><a href="#BeanNameAware" class="headerlink" title="BeanNameAware"></a>BeanNameAware</h3><p>给自定义组件，注入自己在容器的id名。</p><p>1）修改Red类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Red implements ApplicationContextAware,BeanNameAware &#123;<br><br>    private ApplicationContext applicationContext;<br><br>    @Override<br>    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;<br>        this.applicationContext = applicationContext;<br>        System.out.println(&quot;容器:&quot; + applicationContext.toString());<br>    &#125;<br><br>    @Override<br>    public void setBeanName(String name) &#123;<br>        System.out.println(&quot;自定义组件的id名字：&quot;+name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">自定义组件的id名字：red<br>容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:21:56 CST 2018]; root of context hierarchy<br>red------postProcessBeforeInitialization<br>red------postProcessAfterInitialization<br></code></pre></td></tr></table></figure></p><p><strong>总结：</strong></p><p>想让自定义组件使用Spring底层的组件，就实现xxxAware接口就行。</p><p>ApplicationContextAware<br>ApplicationEventPublisherAware<br>BeanClassLoaderAware<br>BeanFactoryAware<br>BeanNameAware<br>BootstrapContextAware<br>EmbeddedValueResolverAware<br>EnvironmentAware<br>ImportAware<br>LoadTimeWeaverAware<br>MessageSourceAware<br>NotificationPublisherAware<br>PortletConfigAware<br>PortletContextAware<br>ResourceLoaderAware<br>SchedulerContextAware<br>ServletConfigAware<br>ServletContextAware</p><hr><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>1）在Red类下的setApplicationContext方法上面打上断点</p><p>2) 运行测试方法：</p><p>发现ApplicationContextAware是由ApplicationContextAwareProcessor处理的：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException &#123;<br>AccessControlContext acc = null;<br><br>if (System.getSecurityManager() != null &amp;&amp;<br>(bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||<br>bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||<br>bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) &#123;<br>acc = this.applicationContext.getBeanFactory().getAccessControlContext();<br>&#125;<br><br>if (acc != null) &#123;<br>AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;<br>@Override<br>public Object run() &#123;<br>invokeAwareInterfaces(bean);<br>return null;<br>&#125;<br>&#125;, acc);<br>&#125;<br>else &#123;<br>invokeAwareInterfaces(bean);<br>&#125;<br><br>return bean;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>内部执行postProcessBeforeInitialization方法来判断自定义的组件是否实现类xxxAware接口。</p><p>最后调用invokeAwareInterfaces(bean)方法</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">private void invokeAwareInterfaces(Object bean) &#123;<br>if (bean instanceof Aware) &#123;<br>if (bean instanceof EnvironmentAware) &#123;<br>((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());<br>&#125;<br>if (bean instanceof EmbeddedValueResolverAware) &#123;<br>((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);<br>&#125;<br>if (bean instanceof ResourceLoaderAware) &#123;<br>((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);<br>&#125;<br>if (bean instanceof ApplicationEventPublisherAware) &#123;<br>((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);<br>&#125;<br>if (bean instanceof MessageSourceAware) &#123;<br>((MessageSourceAware) bean).setMessageSource(this.applicationContext);<br>&#125;<br>if (bean instanceof ApplicationContextAware) &#123;<br>((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用相应的方法来实现注入。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_09</title>
      <link href="/2018/10/16/spring-annotation-day-09/"/>
      <url>/2018/10/16/spring-annotation-day-09/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>Spring的自动装配：  </p><p>Spring利用依赖注入(DI)，完成对IoC容器中各个组件的依赖关系赋值。</p><h3 id="Autowired注解"><a href="#Autowired注解" class="headerlink" title="@Autowired注解"></a>@Autowired注解</h3><p>1）在com.liuzhuo.config包下，创建新的类MainConfigOfAutowired：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并扫描三个包.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(value = &#123;&quot;com.liuzhuo.controller&quot;, &quot;com.liuzhuo.service&quot;, &quot;com.liuzhuo.dao&quot;&#125;)<br>public class MainConfigOfAutowired &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 修改BookService类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    @Autowired<br>    private BookDao bookDao;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 修改BookDao类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Repository<br>public class BookDao &#123;<br><br>    private Integer laber = 1;<br><br>    public BookDao() &#123;<br>    &#125;<br><br>    public BookDao(Integer laber) &#123;<br>        this.laber = laber;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookDao&#123;&quot; +<br>                &quot;laber=&quot; + laber +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 创建新的测试类IocTest_Autowired：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocTest_Autowired &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAutowired.class);<br>        BookService bookService = applicationContext.getBean(BookService.class);<br>        System.out.println(bookService);<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5) 运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:20:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:20:48 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=BookDao&#123;laber=1&#125;&#125;<br>十月 16, 2018 9:20:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:20:48 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>看到，BookService对象中的BookDao对象也注入进来了。</p><hr><p>当我们有多个相同类型的对象时，会注入哪个对象呢？</p><p>1）我们在配置文件MainConfigOfAutowired中添加先的BookDao对象：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(value = &#123;&quot;com.liuzhuo.controller&quot;, &quot;com.liuzhuo.service&quot;, &quot;com.liuzhuo.dao&quot;&#125;)<br>public class MainConfigOfAutowired &#123;<br><br>    @Bean<br>    public BookDao bookDao() &#123;<br>        return new BookDao(2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2）运行测试：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:27:35 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:27:35 CST 2018]; root of context hierarchy<br>十月 16, 2018 9:27:36 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>BookService&#123;bookDao=BookDao&#123;laber=1&#125;&#125;<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:27:35 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p><strong>结果不变，说明有多个相同类型时，注入到容器中的对象是与@AutoWired下面属性的名字相同的id的Bean对象。</strong></p><p>3）验证我们的结论，修改BookService类下的属性BookDao的属性名字：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    @Autowired<br>    private BookDao bookDao2;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao2 +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 运行测试：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:30:54 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:30:54 CST 2018]; root of context hierarchy<br>十月 16, 2018 9:30:54 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>BookService&#123;bookDao=BookDao&#123;laber=2&#125;&#125;<br><br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:30:54 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>验证正确，说明注入的Bean是与属性的名字相同的对象。</p><hr><p>除了，上述的方法来处理多个相同类型的对象。我们还可以使用 @Qualifier来指定注入容器中的Bean的id名。</p><p>1）修改BookService类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    @Qualifier(&quot;bookDao&quot;)<br>    @Autowired<br>    private BookDao bookDao2;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao2 +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 测试：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:34:12 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:34:12 CST 2018]; root of context hierarchy<br>十月 16, 2018 9:34:12 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:34:12 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=BookDao&#123;laber=1&#125;&#125;<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>此时注入容器中的BookDao对象就是@Qualifier(“bookDao”)注解的对象，而不是bookDao2了。</p><hr><p>默认情况下，@Autowired注解的属性，必须要在容器中已经注入了，否则会报错。</p><p>1）将刚刚的两个BookDao对象都注释掉。</p><p>2）运行测试：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:38:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:38:48 CST 2018]; root of context hierarchy<br>十月 16, 2018 9:38:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext refresh<br>警告: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;bookService&apos;: Unsatisfied dependency expressed through field &apos;bookDao2&apos;; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &apos;com.liuzhuo.dao.BookDao&apos; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125;<br><br>org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;bookService&apos;: Unsatisfied dependency expressed through field &apos;bookDao2&apos;; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &apos;com.liuzhuo.dao.BookDao&apos; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125;<br><br>at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:588)<br>at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:88)<br>at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:366)<br>at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1264)<br>at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553)<br>at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)<br>at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)<br>at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)<br>at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)<br>at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)<br>at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761)<br>at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:867)<br>at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:543)<br>at org.springframework.context.annotation.AnnotationConfigApplicationContext.&lt;init&gt;(AnnotationConfigApplicationContext.java:84)<br>at com.liuzhuo.test.IocTest_Autowired.test01(IocTest_Autowired.java:18)<br>at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>at java.lang.reflect.Method.invoke(Method.java:498)<br>at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)<br>at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)<br>at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)<br>at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)<br>at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)<br>at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)<br>at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)<br>at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)<br>at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)<br>at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)<br>at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)<br>at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)<br>at org.junit.runners.ParentRunner.run(ParentRunner.java:363)<br>at org.junit.runner.JUnitCore.run(JUnitCore.java:137)<br>at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)<br>at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)<br>at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)<br>at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)<br>Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &apos;com.liuzhuo.dao.BookDao&apos; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125;<br>at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoMatchingBeanFound(DefaultListableBeanFactory.java:1493)<br>at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1104)<br>at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1066)<br>at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:585)<br>... 36 more<br><br><br>Process finished with exit code -1<br></code></pre></td></tr></table></figure></p><p>我们也可以使@Autowired注解的属性，不是必须的。<br>因为@Autowired注解里面有一个属性 boolean required() default true;<br>将required设置为：false</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    //@Qualifier(&quot;bookDao&quot;)<br>    @Autowired(required = false)<br>    private BookDao bookDao2;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao2 +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:43:23 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:43:23 CST 2018]; root of context hierarchy<br>十月 16, 2018 9:43:24 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:43:23 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=null&#125;<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>此时不报错了。修改了默认情况下，必须给@Autowired注解的属性，注入到容器中。</p><hr><p>@primary注解：使用这个注解，就是当有多个类型的情况下，优先注入的bean对象：</p><p>1) 修改配置文件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(value = &#123;&quot;com.liuzhuo.controller&quot;, &quot;com.liuzhuo.service&quot;, &quot;com.liuzhuo.dao&quot;&#125;)<br>public class MainConfigOfAutowired &#123;<br><br>    @Primary<br>    @Bean(value = &quot;bookDao2&quot;)<br>    public BookDao bookDao() &#123;<br>        return new BookDao(2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 修改BookService：注释掉@Qualifier(“bookDao”)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    //@Qualifier(&quot;bookDao&quot;)<br>    @Autowired(required = false)<br>    private BookDao bookDao;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 运行测试：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:47:44 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:47:44 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=BookDao&#123;laber=2&#125;&#125;<br>十月 16, 2018 9:47:44 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:47:44 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>此时，输出的是laber=2的BookDao对象了，不再根据@Autowired注解下的属性名来注入到容器中了。</p><p>4）将BookService中的@Qualifier(“bookDao”)的注释去掉：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    @Qualifier(&quot;bookDao&quot;)<br>    @Autowired(required = false)<br>    private BookDao bookDao;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5) 运行测试：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 9:51:00 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:51:00 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=BookDao&#123;laber=1&#125;&#125;<br>十月 16, 2018 9:51:00 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:51:00 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p><strong>说明：当@Primary和@Qualifier同时存在时，是以@Qualifier为标准的！</strong></p><hr><h3 id="Resource注解"><a href="#Resource注解" class="headerlink" title="@Resource注解"></a>@Resource注解</h3><p>1）修改BookService类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    //@Qualifier(&quot;bookDao&quot;)<br>    //@Autowired(required = false)<br>    @Resource<br>    private BookDao bookDao;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 10:09:41 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:09:41 CST 2018]; root of context hierarchy<br>十月 16, 2018 10:09:41 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:09:41 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=BookDao&#123;laber=1&#125;&#125;<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>此时，输出的是laber=1的bookService对象，说明@primary注解没有起作用。<br>@Resource注解，默认是注入属性的名。也可以通过@Resource的name属性来修改需要注入到容器中的Bean对象。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    //@Qualifier(&quot;bookDao&quot;)<br>    //@Autowired(required = false)<br>    @Resource(name = &quot;bookDao2&quot;)<br>    private BookDao bookDao;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 10:13:02 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:13:02 CST 2018]; root of context hierarchy<br>BookService&#123;bookDao=BookDao&#123;laber=2&#125;&#125;<br>十月 16, 2018 10:13:02 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:13:02 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><hr><h3 id="Inject注解"><a href="#Inject注解" class="headerlink" title="@Inject注解"></a>@Inject注解</h3><p>@Inject注解：需要导入javax.inject包。</p><p>1）在pom文件中添加依赖：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependency&gt;<br>    &lt;groupId&gt;javax.inject&lt;/groupId&gt;<br>    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;<br>    &lt;version&gt;1&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>2) 修改BookService类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Service<br>public class BookService &#123;<br><br>    //@Qualifier(&quot;bookDao&quot;)<br>    //@Autowired(required = false)<br>    //@Resource(name = &quot;bookDao2&quot;)<br>    @Inject<br>    private BookDao bookDao;<br><br>    public BookService() &#123;<br>    &#125;<br><br>    @Override<br>    public String toString() &#123;<br>        return &quot;BookService&#123;&quot; +<br>                &quot;bookDao=&quot; + bookDao +<br>                &apos;&#125;&apos;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 运行：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 16, 2018 10:16:52 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:16:52 CST 2018]; root of context hierarchy<br>十月 16, 2018 10:16:52 下午 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &lt;init&gt;<br>信息: JSR-330 &apos;javax.inject.Inject&apos; annotation found and supported for autowiring<br>BookService&#123;bookDao=BookDao&#123;laber=2&#125;&#125;<br>十月 16, 2018 10:16:52 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:16:52 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>输出的是laber=2的BookService对象，说明支持@primary注解。</p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1）@Autowired：自动注入<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1）、默认优先按照类型去容器中找对应的组件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2）、如果找到多个相同类型的组件，再将属性的名称作为组件的id去容器中查找<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.3）、@Qualifier：使用@Qualifier指定需要装配的组件的id，而不使用属性名<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.4）、自动装配默认是一定将属性赋值好，没有就报错。可以使用@Autowired(required=false)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.5）、@Primary:当存在多个同类型的Bean时，优先装配的Bean，优先级没有@Qualifier高。  </p><p>2）Spring还支持使用@Resource(JSR250)和@Inject(JSR330)[java规范的注解]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Resource：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以和@Autowired一样实现自动装配功能，默认是按照组件名称进行装配的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不支持@primary功能和@Autowired(required=false)功能，但是有@Resource(name = “bookDao2”)修改注入容器Bean的id的功能。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Inject：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要导入javax.inject包，和@Autowired的功能一样，但是没有required=false的功能。</p><p>3）@Autowired是Spring定义的，只能在有Spring的环境时才有作用，@Resource和@Inject注解是java规范，只有是满足java规范的都可以使用，意思就是跨框架性更好。</p><p>4）上述自动注入都是通过AutowiredAnnotationBeanPostProcessor这个后置处理器完成。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_08</title>
      <link href="/2018/10/16/spring-annotation-day-08/"/>
      <url>/2018/10/16/spring-annotation-day-08/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><h3 id="Value注解"><a href="#Value注解" class="headerlink" title="@Value注解"></a>@Value注解</h3><p>使用@Value注解来注入值</p><p>1）在com.liuzhuo.config包下，创建新的配置类MainConfigOfProperty：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class MainConfigOfProperty &#123;<br><br>    @Bean<br>    public Person person() &#123;<br>        return new Person();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2）在com.liuzhuo.test包下，创建新的测试类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class PropertyTest &#123;<br><br>    private AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfProperty.class);<br><br>    @Test<br>    public void test01() &#123;<br>        printBeanName(applicationContext);<br>        Person person = (Person) applicationContext.getBean(&quot;person&quot;);<br>        System.out.println(person);<br>        applicationContext.close();<br>    &#125;<br><br>    private void printBeanName(AnnotationConfigApplicationContext applicationContext) &#123;<br>        String[] names = applicationContext.getBeanDefinitionNames();<br>        for (String name : names) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 运行测试方法：test01<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">org.springframework.context.annotation.internalConfigurationAnnotationProcessor<br>org.springframework.context.annotation.internalAutowiredAnnotationProcessor<br>org.springframework.context.annotation.internalRequiredAnnotationProcessor<br>org.springframework.context.annotation.internalCommonAnnotationProcessor<br>org.springframework.context.event.internalEventListenerProcessor<br>org.springframework.context.event.internalEventListenerFactory<br>mainConfigOfProperty<br>person<br>Person&#123;name=&apos;null&apos;, age=null&#125;<br>十月 16, 2018 5:34:32 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2ff5659e: startup date [Tue Oct 16 17:34:31 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>我们能看到，打印出来的Person对象的属性都是null。</p><p>4）修改Person类<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Person &#123;<br><br>    /*<br>    * value:<br>    *     1.使用直接值，比如字符串，数值等<br>    *     2.使用SpEL表达式，#&#123;&#125;<br>    *     3.使用$&#123;&#125;,获取资源文件中的数据<br>    * */<br>    @Value(&quot;张三&quot;)<br>    private String name;<br>    @Value(&quot;#&#123;20-2&#125;&quot;)<br>    private Integer age;<br>    <br>    ·····<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5）再次运行test01：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">org.springframework.context.annotation.internalConfigurationAnnotationProcessor<br>org.springframework.context.annotation.internalAutowiredAnnotationProcessor<br>org.springframework.context.annotation.internalRequiredAnnotationProcessor<br>org.springframework.context.annotation.internalCommonAnnotationProcessor<br>org.springframework.context.event.internalEventListenerProcessor<br>org.springframework.context.event.internalEventListenerFactory<br>mainConfigOfProperty<br>person<br>Person&#123;name=&apos;张三&apos;, age=18&#125;<br>十月 16, 2018 5:37:41 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2ff5659e: startup date [Tue Oct 16 17:37:41 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><hr><h3 id="PropertySource注解"><a href="#PropertySource注解" class="headerlink" title="@PropertySource注解"></a>@PropertySource注解</h3><p>使用@PropertySource注解来获取资源配置文件中的数据。</p><p>1）在resource包下，创建person.properties文件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">person.nickName=小张三<br></code></pre></td></tr></table></figure></p><p>2) 修改Person类：<br>添加nickName属性和对应的get、set方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Person &#123;<br><br>    /*<br>     * value:<br>     *     1.使用直接值，比如字符串，数值等<br>     *     2.使用SpEL表达式，#&#123;&#125;<br>     *     3.使用$&#123;&#125;,获取资源文件中的数据<br>     * */<br>    @Value(&quot;张三&quot;)<br>    private String name;<br>    @Value(&quot;#&#123;20-2&#125;&quot;)<br>    private Integer age;<br>    @Value(&quot;$&#123;person.nickName&#125;&quot;)<br>    private String nickName;<br>    <br>    ·····<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3）在配置文件中，加入资源文件的扫描：<br>&nbsp;&nbsp;&nbsp;@PropertySource(value = “classpath:person.properties”)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@PropertySource(value = &quot;classpath:person.properties&quot;)<br>public class MainConfigOfProperty<br></code></pre></td></tr></table></figure></p><p>这里的@PropertySource(value = “classpath:person.properties”)，相当于以前在xml中的配置的<br>&lt;context:property-placeholder location=”person.properties”/&gt;，如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>       xsi:schemaLocation=&quot;<br>        http://www.springframework.org/schema/beans<br>        http://www.springframework.org/schema/beans/spring-beans.xsd<br>        http://www.springframework.org/schema/context<br>        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;<br><br>    &lt;!--包扫描、只要标注了@Controller、@Service、@Repository、@Component都会自动注入到容器中--&gt;<br>    &lt;!--&lt;context:component-scan base-package=&quot;com.liuzhuo&quot;/&gt;--&gt;<br><br>    &lt;!--扫描资源文件--&gt;<br>    &lt;context:property-placeholder location=&quot;person.properties&quot;/&gt;<br><br>    &lt;!--以前的开发模式，使用配置文件--&gt;<br>    &lt;bean id=&quot;person&quot; class=&quot;com.liuzhuo.bean.Person&quot; init-method=&quot;&quot; destroy-method=&quot;&quot;&gt;<br>        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;<br>        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;<br>    &lt;/bean&gt;<br><br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure></p><p>4) 运行test01：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfigOfProperty<br>person<br>Person&#123;name=&apos;张三&apos;, age=18, nickName=&apos;小张三&apos;&#125;<br></code></pre></td></tr></table></figure></p><p>这里的昵称，小张三也打印出来了。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_07</title>
      <link href="/2018/10/16/spring-annotation-day-07/"/>
      <url>/2018/10/16/spring-annotation-day-07/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><h3 id="BeanPostProcessor的生命周期流程"><a href="#BeanPostProcessor的生命周期流程" class="headerlink" title="BeanPostProcessor的生命周期流程"></a>BeanPostProcessor的生命周期流程</h3><p>我们知道BeanPostProcessor是后置处理器，是在Bean初始化前后执行一些列操作的，底层到底是怎么执行的呢？现在debug一下。</p><p>1）设置断点，在com.liuzhuo.bean包下的MyBeanPostProcessor类中，给postProcessBeforeInitialization方法设置断点。</p><p><img src="/images/20181016100600.png"></p><p>2) debug一下。发现调用栈如下：</p><p><img src="/images/20181016101036.png" style="width:50%"></p><p>程序是从test01开始：</p><p>1）创建AnnotationConfigApplicationContext对象  </p><p>2）执行AnnotationConfigApplicationContext的构造方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) &#123;<br>this();<br>register(annotatedClasses);<br>refresh();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 调用refresh()方法：完成一系列资源配置操作。最后调用finishBeanFactoryInitialization()方法，初始化容器。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public void refresh() throws BeansException, IllegalStateException &#123;<br>synchronized (this.startupShutdownMonitor) &#123;<br>// Prepare this context for refreshing.<br>prepareRefresh();<br><br>// Tell the subclass to refresh the internal bean factory.<br>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<br><br>// Prepare the bean factory for use in this context.<br>prepareBeanFactory(beanFactory);<br><br>try &#123;<br>// Allows post-processing of the bean factory in context subclasses.<br>postProcessBeanFactory(beanFactory);<br><br>// Invoke factory processors registered as beans in the context.<br>invokeBeanFactoryPostProcessors(beanFactory);<br><br>// Register bean processors that intercept bean creation.<br>registerBeanPostProcessors(beanFactory);<br><br>// Initialize message source for this context.<br>initMessageSource();<br><br>// Initialize event multicaster for this context.<br>initApplicationEventMulticaster();<br><br>// Initialize other special beans in specific context subclasses.<br>onRefresh();<br><br>// Check for listener beans and register them.<br>registerListeners();<br><br>// Instantiate all remaining (non-lazy-init) singletons.<br>finishBeanFactoryInitialization(beanFactory);<br><br>// Last step: publish corresponding event.<br>finishRefresh();<br>&#125;<br><br>catch (BeansException ex) &#123;<br>if (logger.isWarnEnabled()) &#123;<br>logger.warn(&quot;Exception encountered during context initialization - &quot; +<br>&quot;cancelling refresh attempt: &quot; + ex);<br>&#125;<br><br>// Destroy already created singletons to avoid dangling resources.<br>destroyBeans();<br><br>// Reset &apos;active&apos; flag.<br>cancelRefresh(ex);<br><br>// Propagate exception to caller.<br>throw ex;<br>&#125;<br><br>finally &#123;<br>// Reset common introspection caches in Spring&apos;s core, since we<br>// might not ever need metadata for singleton beans anymore...<br>resetCommonCaches();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4）进入finishBeanFactoryInitialization：<br>调用<br><code>beanFactory.preInstantiateSingletons();</code></p><p>5) 最终调用doCreateBean()方法：<br>我们主要看其中的：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">      // Initialize the bean instance.<br>Object exposedObject = bean;<br>try &#123;<br>populateBean(beanName, mbd, instanceWrapper);<br>if (exposedObject != null) &#123;<br>exposedObject = initializeBean(beanName, exposedObject, mbd);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>populateBean:给Bean的属性赋值等操作<br>initializeBean:Bean初始化操作。</p><p>6）点击initializeBean方法:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Object wrappedBean = bean;<br>if (mbd == null || !mbd.isSynthetic()) &#123;<br>wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>&#125;<br><br>try &#123;<br>invokeInitMethods(beanName, wrappedBean, mbd);<br>&#125;<br>catch (Throwable ex) &#123;<br>throw new BeanCreationException(<br>(mbd != null ? mbd.getResourceDescription() : null),<br>beanName, &quot;Invocation of init method failed&quot;, ex);<br>&#125;<br><br>if (mbd == null || !mbd.isSynthetic()) &#123;<br>wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>&#125;<br>return wrappedBean;<br></code></pre></td></tr></table></figure></p><p>其中：<br>applyBeanPostProcessorsBeforeInitialization：完成初始化之前的操作。</p><p>invokeInitMethods：初始化是操作(@PostConstruc、init-method等)</p><p>applyBeanPostProcessorsAfterInitialization：完成初始化之后的操作。</p><p>7）点击applyBeanPostProcessorsBeforeInitialization：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)<br>throws BeansException &#123;<br><br>Object result = existingBean;<br>for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;<br>result = beanProcessor.postProcessBeforeInitialization(result, beanName);<br>if (result == null) &#123;<br>return result;<br>&#125;<br>&#125;<br>return result;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>发现：就是使用for循环来调用一系列BeanPostProcessor接口的实现类，包括Spring容器自身的和我们自定义的实现类。</p><p><strong>注意:如果其中的某一个BeanPostProcessor实现类返回了null，那么后面的BeanPostProcessor实现类就不执行了！！！</strong></p><p>大概的流程就走完了~~~</p><hr><h3 id="Spring底层对BeanPostProcessor的使用"><a href="#Spring底层对BeanPostProcessor的使用" class="headerlink" title="Spring底层对BeanPostProcessor的使用"></a>Spring底层对BeanPostProcessor的使用</h3><p>ps：在idea中：类名查找类:Ctrl+Shift+Alt+N; </p><p><img src="/images/20181016104349.png"></p><p>1) 找到BeanPostProcessor接口：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public interface BeanPostProcessor &#123;<br><br><br>Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;<br><br><br>Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 在BeanPostProcessor上Ctrl+T：找到所有的实现类：</p><p><img src="/images/20181016105219.png"></p><p>我们能看到各种BeanPostProcessor的实现类</p><p>3）ApplicationContextAwareProcessor</p><p>我们使用一下ApplicationContextAwareProcessor这个处理器。这个处理器是给我们的自定义Bean注入容器的。</p><p>4）在com.liuzhuo.bean包下，随便找个一个Bean，并实现ApplicationContextAware接口：<br>ps:这里使用的Dog类<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Dog implements ApplicationContextAware<br></code></pre></td></tr></table></figure></p><p>5）需要实现：setApplicationContext方法<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;<br>    this.applicationContext = applicationContext;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这样我们就将容器注入到Dog类中。</p><hr><p>还有：<br>InitDestroyAnnotationBeanPostProcessor处理我们的@PostConstruct、@PreDestory注解。<br>AutowiredAnnotationBeanPostProcessor处理我们的@Autowired注解等。</p><p><strong>总结：<br>&nbsp;&nbsp;&nbsp;&nbsp;Spring对底层BeanPostProcessor的使用：bean的赋值、注入其他组件、@Autowired、生命周期注解功能、@Async、xxxBeanPostProcessor等等。</strong></p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_06</title>
      <link href="/2018/10/15/spring-annotation-day-06/"/>
      <url>/2018/10/15/spring-annotation-day-06/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p>在Spring中Bean的生命周期：<br>Bean的创建—-初始化—–调用—–销毁。</p><p>构造(对象的创建)：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单实例：在容器启动的时候创建对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多实例：在每次获取的时候创建对象 </p><p>初始化：<br>对象创建完成，并赋值好，调用初始化方法</p><p>销毁：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单实例：容器关闭的时候<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多实例：容器不会管理这个Bean，容器不会调用销毁方法</p><p>以前，我们定义初始化和销毁方法是在xml文件中配置的：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!--以前的开发模式，使用配置文件--&gt;<br>    &lt;bean id=&quot;person&quot; class=&quot;com.liuzhuo.bean.Person&quot; init-method=&quot;&quot; destroy-method=&quot;&quot;&gt;<br>        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;<br>        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;<br>    &lt;/bean&gt;<br></code></pre></td></tr></table></figure></p><p>init-method=””    : 定义初始化方法<br>destroy-method=”” : 定义销毁方法  </p><hr><p>现在，我们可以使用其他方式来完成生命周期。</p><h4 id="通过-Bean指定init-method和destroy-method"><a href="#通过-Bean指定init-method和destroy-method" class="headerlink" title="通过@Bean指定init-method和destroy-method"></a>通过@Bean指定init-method和destroy-method</h4><p>1）在com.liuzhuo.config包下，创建MainConfigOfLife配置类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class MainConfigOfLife &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 在com.liuzhuo.bean包下，创建Car类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Car &#123;<br><br>    public Car() &#123;<br>        System.out.println(&quot;Car construct ····&quot;);<br>    &#125;<br><br>    //定义初始化方法<br>    public void init()&#123;<br>        System.out.println(&quot;Car init ·····&quot;);<br>    &#125;<br><br>    //定义销毁方法<br>    public void destory()&#123;<br>        System.out.println(&quot;Car destory ·····&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 将Car注册到容器中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>public class MainConfigOfLife &#123;<br><br>    @Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;destory&quot;)<br>    public Car car() &#123;<br>        return new Car();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 在com.liuzhuo.test包下，创建新的测试类(IocOfLifeTest):<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocOfLifeTest &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext =<br>                new AnnotationConfigApplicationContext(MainConfigOfLife.class);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5)运行测试test01方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Car construct ····<br>Car init ·····<br></code></pre></td></tr></table></figure></p><p>说明：单例模式下，容器启动就会将Bean对象注入到容器中，并执行了初始化方法。</p><p>想要调用销毁方法，关闭容器就好。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocOfLifeTest &#123;<br><br>    @Test<br>    public void test01() &#123;<br><br>        //启动容器<br>        AnnotationConfigApplicationContext applicationContext =<br>                new AnnotationConfigApplicationContext(MainConfigOfLife.class);<br>        //关闭容器<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">D:\Java1.8\bin\java<br>十月 15, 2018 9:08:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh<br>信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:08:11 CST 2018]; root of context hierarchy<br>Car construct ····<br>Car init ·····<br>十月 15, 2018 9:08:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:08:11 CST 2018]; root of context hierarchy<br>Car destory ·····<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><hr><h4 id="InitializingBean和DisposableBean"><a href="#InitializingBean和DisposableBean" class="headerlink" title="InitializingBean和DisposableBean"></a>InitializingBean和DisposableBean</h4><p>通过让Bean实现InitializingBean和DisposableBean两个接口来定义初始化和销毁。</p><p>1）在com.liuzhuo.bean包下，创建Cat类，并实现上述两个接口：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Cat implements InitializingBean, DisposableBean &#123;<br><br>    public Cat() &#123;<br>        System.out.println(&quot;Cat constructer ···&quot;);<br>    &#125;<br><br>    @Override<br>    public void destroy() throws Exception &#123;<br>        System.out.println(&quot;Cat destroy ····&quot;);<br>    &#125;<br><br>    @Override<br>    public void afterPropertiesSet() throws Exception &#123;<br>        System.out.println(&quot;Cat afterPropertiesSet ····&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 将Cat类注入到容器中，这里我使用了包扫描:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration<br>@ComponentScan(value = &quot;com.liuzhuo&quot;)<br>public class MainConfigOfLife<br></code></pre></td></tr></table></figure></p><p>3) 运行测试方法test01:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocOfLifeTest &#123;<br><br>    @Test<br>    public void test01() &#123;<br><br>        //启动容器<br>        AnnotationConfigApplicationContext applicationContext =<br>                new AnnotationConfigApplicationContext(MainConfigOfLife.class);<br><br>        Object cat = applicationContext.getBean(&quot;cat&quot;);<br>        //关闭容器<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 15, 2018 9:21:42 下午 org.springframework.beans.factory.support.DefaultListableBeanFactory registerBeanDefinition<br>信息: Overriding bean definition for bean &apos;person&apos; with a different definition: replacing [Generic bean: class [com.liuzhuo.bean.Person]; scope=singleton; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [E:\ideaProject\springannotation\target\classes\com\liuzhuo\bean\Person.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=true; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=mainConfig2; factoryMethodName=person; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/liuzhuo/config/MainConfig2.class]]<br>Cat constructer ···<br>Cat afterPropertiesSet ····<br>Car construct ····<br>Car init ·····<br>十月 15, 2018 9:21:43 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:21:42 CST 2018]; root of context hierarchy<br>Car destory ·····<br>Cat destroy ····<br></code></pre></td></tr></table></figure></p><hr><h4 id="JSR250-PostConstruct和-PreDestory"><a href="#JSR250-PostConstruct和-PreDestory" class="headerlink" title="JSR250:@PostConstruct和@PreDestory"></a>JSR250:@PostConstruct和@PreDestory</h4><p>@PostConstruct: 在bean创建完成并且属性赋值完成，来执行初始化方法<br>@PreDestory：&nbsp;&nbsp;在容器销毁bean之前通知我们进行清理工作</p><p>1) 在com.liuzhuo.bean包下，创建Dog类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Dog &#123;<br><br>    public Dog() &#123;<br>        System.out.println(&quot;Dog construct ····&quot;);<br>    &#125;<br><br>    //在构造函数之后<br>    @PostConstruct<br>    public void init() &#123;<br>        System.out.println(&quot;Dog @PostConstruct ····&quot;);<br>    &#125;<br><br>    //在销毁之前<br>    @PreDestroy<br>    public void destory() &#123;<br>        System.out.println(&quot;Dog @PreDestroy ····&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 运行测试类test01:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocOfLifeTest &#123;<br><br>    @Test<br>    public void test01() &#123;<br><br>        //启动容器<br>        AnnotationConfigApplicationContext applicationContext =<br>                new AnnotationConfigApplicationContext(MainConfigOfLife.class);<br><br>        applicationContext.getBean(&quot;dog&quot;);<br>        <br>        //关闭容器<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">十月 15, 2018 9:35:11 下午 org.springframework.beans.factory.support.DefaultListableBeanFactory registerBeanDefinition<br>信息: Overriding bean definition for bean &apos;person&apos; with a different definition: replacing [Generic bean: class [com.liuzhuo.bean.Person]; scope=singleton; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [E:\ideaProject\springannotation\target\classes\com\liuzhuo\bean\Person.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=true; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=mainConfig2; factoryMethodName=person; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/liuzhuo/config/MainConfig2.class]]<br>Cat constructer ···<br>Cat afterPropertiesSet ····<br>Dog construct ····<br>Dog @PostConstruct ····<br>Car construct ····<br>Car init ·····<br>十月 15, 2018 9:35:12 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:35:11 CST 2018]; root of context hierarchy<br>Car destory ·····<br>Dog @PreDestroy ····<br>Cat destroy ····<br></code></pre></td></tr></table></figure></p><hr><h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h4><p>BeanPostProcessor:bean后置处理器（意思是bean初始化前后执行）</p><p>postProcessBeforeInitialization：在初始化之前执行，这里是初始化指：上述的init-method、InitializingBean、@PostConstruct。</p><p>postProcessAfterInitialization：在初始化之后执行。</p><hr><p>1）在com.liuzhuo.bean包下，创建MyBeanPostProcessor并实现BeanPostProcessor接口<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class MyBeanPostProcessor implements BeanPostProcessor &#123;<br><br>    //初始化之前执行<br>    /**<br>     * @param bean     容器创建的Bean<br>     * @param beanName bean的id<br>     * @return<br>     * @throws BeansException<br>     */<br>    @Override<br>    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;<br><br>        System.out.println(beanName + &quot;------postProcessBeforeInitialization&quot;);<br>        //返回值是原始的Bean，或者是包装后的Bean<br>        return bean;<br>    &#125;<br><br>    //初始化之后执行<br>    @Override<br>    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;<br>        System.out.println(beanName + &quot;------postProcessAfterInitialization&quot;);<br>        return bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 运行测试方法test01：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocOfLifeTest &#123;<br><br>    @Test<br>    public void test01() &#123;<br><br>        //启动容器<br>        AnnotationConfigApplicationContext applicationContext =<br>                new AnnotationConfigApplicationContext(MainConfigOfLife.class);<br><br>        applicationContext.getBean(&quot;dog&quot;);<br><br>        //关闭容器<br>        applicationContext.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfigOfLife------postProcessBeforeInitialization<br>mainConfigOfLife------postProcessAfterInitialization<br>Cat constructer ···<br>cat------postProcessBeforeInitialization<br>Cat afterPropertiesSet ····<br>cat------postProcessAfterInitialization<br>Dog construct ····<br>dog------postProcessBeforeInitialization<br>Dog @PostConstruct ····<br>dog------postProcessAfterInitialization<br>Car construct ····<br>car------postProcessBeforeInitialization<br>Car init ·····<br>car------postProcessAfterInitialization<br>Car destory ·····<br>Dog @PreDestroy ····<br>Cat destroy ····<br>十月 15, 2018 9:57:03 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose<br>信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:57:03 CST 2018]; root of context hierarchy<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>分析：<br>Cat constructer ···<br>cat——postProcessBeforeInitialization<br>Cat afterPropertiesSet ····<br>cat——postProcessAfterInitialization<br>Cat destroy ····  </p><p><strong>构造–初始化之前–初始化–初始化之后–销毁</strong></p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_05</title>
      <link href="/2018/10/15/spring-annotation-day-05/"/>
      <url>/2018/10/15/spring-annotation-day-05/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><h3 id="Import注解"><a href="#Import注解" class="headerlink" title="@Import注解"></a>@Import注解</h3><p>给容器中注册组件：<br>1）、包扫描+组件标记注解（@Controller、@Service、@Repository、@Component)[导入我们自己写的组件]<br>2）、@Bean[导入第三方包里面的组件]<br>3）、@Import[快速给容器中导入一个组件]  </p><hr><p>@Bean导入，只能一个一个的导入，不太方便，所以需要@Import注解。现在我们来看@Import的用法。</p><h4 id="一、-Import"><a href="#一、-Import" class="headerlink" title="一、@Import"></a>一、@Import</h4><p>@Import：容器中会自动注册这个组件，id默认是全类名  </p><p>1）在com.liuzhuo.bean包下，创建Color对象。<br>2）修改配置类MainConfig2类：(看@Import注解)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@Import(Color.class)<br>public class MainConfig2<br></code></pre></td></tr></table></figure></p><p>3）在test类中，创建新的测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void testImport() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>    printBeanName(applicationContext);<br>&#125;<br><br>private void printBeanName(AnnotationConfigApplicationContext applicationContext) &#123;<br>    String[] names = applicationContext.getBeanDefinitionNames();<br>    for (String name : names) &#123;<br>        System.out.println(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig2<br>com.liuzhuo.bean.Color<br>person<br>bier<br></code></pre></td></tr></table></figure></p><p>观察结果：发现Color组件已经注册到容器中了，而且id名是全类名。</p><hr><p>点击@Import。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Target(&#123;ElementType.TYPE&#125;)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>public @interface Import &#123;<br>    Class&lt;?&gt;[] value();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>发现，@Import中的value是一个Class类型的数组，说明可以注入多个Class类型  </p><p>1）现在，在com.liuzhuo.bean包下，再创建一个Red类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Red &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2）修改配置类MainConfig2：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@Import(&#123;Color.class, Red.class&#125;)<br>public class MainConfig2<br></code></pre></td></tr></table></figure></p><p>3) 运行测试方法testImport:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig2<br>com.liuzhuo.bean.Color<br>com.liuzhuo.bean.Red<br>person<br>bier<br></code></pre></td></tr></table></figure></p><p>结果：Red类也被注册到容器中了。</p><hr><h4 id="二、ImportSelect"><a href="#二、ImportSelect" class="headerlink" title="二、ImportSelect"></a>二、ImportSelect</h4><p>ImporSelect：返回要导入的全类名数组。</p><p>在@Import的value属性中，导入实现了ImportSelect接口的类，该实现类返回我们需要导入的组件的全类名即可。</p><p>1）在com.liuzhuo.condition包下，创建MyImportSelect类并实现ImportSelect接口：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyImportSelect implements ImportSelector &#123;<br><br>    /*<br>    * annotationMetadata:获取注解的信息。<br>    * 返回值：全类名的字符串数组<br>    * */<br>    @Override<br>    public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br><br>        //返回值不能是null，否则会出空指针异常<br>        return new String[0];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 在com.liuzhuo.bean包下，创建Bule、Yellow类。</p><p>3）修改selectImports方法是返回值：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyImportSelect implements ImportSelector &#123;<br><br>    /*<br>    * annotationMetadata:获取注解的信息。<br>    * 返回值：全类名的字符串数组<br>    * */<br>    @Override<br>    public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br><br>        //返回值不能是null，否则会出空指针异常<br>        return new String[]&#123;&quot;com.liuzhuo.bean.Blue&quot;,&quot;com.liuzhuo.bean.Yellow&quot;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 修改配置类MainConfig2:(添加类MyImportSelect类)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@Import(&#123;Color.class, Red.class, MyImportSelect.class&#125;)<br>public class MainConfig2<br></code></pre></td></tr></table></figure></p><p>5)运行测试方法testImport:</p><p>结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig2<br>com.liuzhuo.bean.Color<br>com.liuzhuo.bean.Red<br>com.liuzhuo.bean.Blue<br>com.liuzhuo.bean.Yellow<br>person<br>bier<br></code></pre></td></tr></table></figure></p><p>发现：Blue、Yellow也被注册到容器中了。</p><hr><h4 id="三、ImportBeanDefinitionRegistrar"><a href="#三、ImportBeanDefinitionRegistrar" class="headerlink" title="三、ImportBeanDefinitionRegistrar"></a>三、ImportBeanDefinitionRegistrar</h4><p>ImportBeanDefinitionRegistrar ：手动注册Bean。</p><p>使用的形式与ImportSelect类似。</p><p>1）在com.liuzhuo.condition包下，创建MyImportBeanDefinitionRegistrar类实现ImportBeanDefinitionRegistrar接口。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;<br>    /*<br>    *<br>    * importingClassMetadata:注解类的信息<br>    * registry：注册组件，使用register.registerBeanDefinition()方法，手动注册Bean。<br>    * */<br>    @Override<br>    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2)在com.liuzhuo.bean包下，创建RainBow类。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class RainBow &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 修改registerBeanDefinitions方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Override<br>public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;<br><br>    /*<br>     * 这里，我们根据是否有Bule和Yellow组件来注册RainBow组件。<br>     * */<br><br>    //注意这里传入的是Bean的id。<br>    boolean b = registry.containsBeanDefinition(&quot;com.liuzhuo.bean.Blue&quot;);<br>    boolean y = registry.containsBeanDefinition(&quot;com.liuzhuo.bean.Yellow&quot;);<br>    if (b &amp;&amp; y) &#123;<br>        //两个参数：String beanName<br>        //         BeanDefinition beanDefinition<br>        // beanName：要注册的Bean的id<br>        //beanDefinition:Bean的定义。是一个接口，我们需要传入一个实现类。<br>        RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(RainBow.class);<br>        registry.registerBeanDefinition(&quot;rainBow&quot;, rootBeanDefinition);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 修改配置类MainConfig2：(MyImportBeanDefinitionRegistrar.class)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@Import(&#123;Color.class, Red.class, MyImportSelect.class, MyImportBeanDefinitionRegistrar.class&#125;)<br>public class MainConfig2<br></code></pre></td></tr></table></figure></p><p>5) 运行测试方法testImport:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig2<br>com.liuzhuo.bean.Color<br>com.liuzhuo.bean.Red<br>com.liuzhuo.bean.Blue<br>com.liuzhuo.bean.Yellow<br>person<br>bier<br>rainBow<br></code></pre></td></tr></table></figure></p><p>结果：发现rainBow已经被注册到容器中了。</p><hr><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>第四种方法给容器注册Bean.</p><p>使用Spring提供的FactoryBean（工厂Bean）<br> &nbsp;&nbsp;&nbsp;&nbsp;1）默认获取的是工厂bean调用getObject创建的对象<br> &nbsp;&nbsp;&nbsp;&nbsp;2）要想获取工厂Bean本身，需要给id前面加一个&amp;</p><hr><p>1) 在com.liuzhuo.bean包下，创建ColorFactoryBean类，实现FactoryBean接口：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class ColorFactoryBean implements FactoryBean&lt;Color&gt; &#123;<br><br>    //返回的Bean对象<br>    @Override<br>    public Color getObject() throws Exception &#123;<br>        return new Color();<br>    &#125;<br><br>    //Bean的类型<br>    @Override<br>    public Class&lt;?&gt; getObjectType() &#123;<br>        return Color.class;<br>    &#125;<br><br>    //是否是单例：<br>    //true:单例<br>    //false:多例<br>    @Override<br>    public boolean isSingleton() &#123;<br>        return true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2) 注册ColorFactoryBean到容器中，在配置文件MainConfig2中：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean<br>public ColorFactoryBean colorFactoryBean() &#123;<br>    return new ColorFactoryBean();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3) 修改testImport方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void testImport() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>    printBeanName(applicationContext);<br><br><br>    Object colorFactoryBean = applicationContext.getBean(&quot;colorFactoryBean&quot;);<br>    System.out.println(colorFactoryBean);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>4) 结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig2<br>com.liuzhuo.bean.Color<br>com.liuzhuo.bean.Red<br>com.liuzhuo.bean.Blue<br>com.liuzhuo.bean.Yellow<br>person<br>bier<br>colorFactoryBean<br>rainBow<br>com.liuzhuo.bean.Color@6107227e<br></code></pre></td></tr></table></figure></p><p>发现：com.liuzhuo.bean.Color@6107227e 已经注册到容器中了。<br><strong>注意：我们注册到容器中的是ColorFactoryBean，但是获取Bean的时候，却是Color。</strong></p><p>底层是调用ColorFactoryBean的getObject()来获取的。</p><p>如果就是想要获取ColorFactoryBean本身的话，在id前面加一个&amp;：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Object colorFactoryBean = applicationContext.getBean(&quot;colorFactoryBean&quot;);<br>System.out.println(colorFactoryBean);<br>Object colorFactoryBean2 = applicationContext.getBean(&quot;&amp;colorFactoryBean&quot;);<br>System.out.println(colorFactoryBean2);<br></code></pre></td></tr></table></figure></p><p>结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">com.liuzhuo.bean.Color@6107227e<br>com.liuzhuo.bean.ColorFactoryBean@7c417213<br></code></pre></td></tr></table></figure></p><p>ps:点击BeanFactory：<br>会发现有一个字段：<br><code>String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</code><br>这就是为啥加&amp;会获取FactoryBean本身的原因.</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_04</title>
      <link href="/2018/10/14/spring-annotation-day-04/"/>
      <url>/2018/10/14/spring-annotation-day-04/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h3><p>作用：按照一定的条件进行判断，满足条件给容器中注入bean  </p><p>现在我们的需求的是根据操作系统的类型来，注入给定的bean对象。</p><p>在配置类中，添加两个方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Bean(&quot;bier&quot;)<br>public Person person01() &#123; //如果是windows系统就注入到容器中<br>    return new Person(&quot;Bier&quot;, 16);<br>&#125;<br><br>@Bean(&quot;linux&quot;)<br>public Person person02() &#123; //如果是Linux系统就注入到容器中<br>    return new Person(&quot;Linux&quot;, 18);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>在测试类中，创建新的test03方法:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test03() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>    //根据Bean类来获取所有的Bean类的id名字<br>    String[] beanNamesForType = applicationContext.getBeanNamesForType(Person.class);<br>    for (String name : beanNamesForType) &#123;<br>        System.out.println(name);<br>    &#125;<br>    //根据Bean类来获取Map结构<br>    Map&lt;String, Person&gt; beansOfType = applicationContext.getBeansOfType(Person.class);<br>    System.out.println(beansOfType);<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">D:\Java1.8\bin\java  <br>person<br>bier<br>linux<br>加载person类到容器中~~~<br>&#123;person=Person&#123;name=&apos;dengjie&apos;, age=18&#125;, bier=Person&#123;name=&apos;Bier&apos;, age=16&#125;, linux=Person&#123;name=&apos;Linux&apos;, age=18&#125;&#125;<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>此时：获取了所有的person类的Bean的id的名字。</p><hr><p>现在，我们创建com.liuzhuo.conditaion包，并创建两个实现了condition接口的类。如下：</p><p><img src="/images/20181014203017.png" style="width:50%">  </p><p>WinCondition类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class WinCondition implements Condition &#123;<br>    /*<br>     * conditionContext：     条件上下文（获取我们需要的资源）<br>     * annotatedTypeMetadata：注解类型的信息<br>     * */<br>    @Override<br>    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123;<br><br>        //获取beanFactory工厂<br>        ConfigurableListableBeanFactory beanFactory = conditionContext.getBeanFactory();<br>        //获取加载类<br>        ClassLoader classLoader = conditionContext.getClassLoader();<br>        //获取注解类<br>        BeanDefinitionRegistry registry = conditionContext.getRegistry();<br>        //获取环境变量<br>        Environment environment = conditionContext.getEnvironment();<br>        //获取资源加载类<br>        ResourceLoader resourceLoader = conditionContext.getResourceLoader();<br><br>        /*<br>        * 创建如果是windows系统的话，就注入到容器中<br>        * */<br>        String property = environment.getProperty(&quot;os.name&quot;);<br>        if (property.contains(&quot;Windows&quot;)) return true;<br>        return false;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>LinuxCondition类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class LinuxCondition implements Condition &#123;<br>    @Override<br>    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123;<br><br>        Environment environment = conditionContext.getEnvironment();<br>        String property = environment.getProperty(&quot;os.name&quot;);<br>        if (property.contains(&quot;Linux&quot;)) return true;<br>        return false;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>修改配置类：给刚刚创建的两个方法添加@Conditional注解</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Conditional(&#123;WinCondition.class&#125;)<br>@Bean(&quot;bier&quot;)<br>public Person person01() &#123; //如果是windows系统就注入到容器中<br>    return new Person(&quot;Bier&quot;, 16);<br>&#125;<br><br>@Conditional(&#123;LinuxCondition.class&#125;)<br>@Bean(&quot;linux&quot;)<br>public Person person02() &#123; //如果是Linux系统就注入到容器中<br>    return new Person(&quot;Linux&quot;, 18);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">person<br>bier<br>加载person类到容器中~~~<br>&#123;person=Person&#123;name=&apos;dengjie&apos;, age=18&#125;, bier=Person&#123;name=&apos;Bier&apos;, age=16&#125;&#125;<br>Windows 10<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>看到结果：现在作者的操作系统是windows系统，所以现在是bier给注入到容器中了。</p><p>现在修改操作系统的类型。</p><p>修改test03的运行环境，在idea的右上角点击”Edit Configrations···”:</p><p><img src="/images/20181014204146.png" style="width:50%"></p><p>编辑里面的 VM options: -Dos.name=Linux </p><p>然后运行test03.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">person<br>linux<br>加载person类到容器中~~~<br>&#123;person=Person&#123;name=&apos;dengjie&apos;, age=18&#125;, linux=Person&#123;name=&apos;Linux&apos;, age=18&#125;&#125;<br>Linux<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></p><p>此时，注入到容器中的是linux。</p><hr><p>总结：@Conditional注解是用来按照一定的条件进行判断，满足条件给容器中注入bean。<br>点击@Conditional：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>public @interface Conditional &#123;<br>    Class&lt;? extends Condition&gt;[] value();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>说明@Conditional里面是Condition&gt;[] value()数组。我们需要在@Conditional的value中写入数组。数组需要使用｛｝来写。传入的是实现了Condition接口的类。比如这里的WinCondition、LinuxCondition类。<br>实例：@Conditional({WinCondition.class})、@Conditional({LinuxCondition.class})。</p><p>@Conditional，不仅可以放在方法上面，还可以是类上面。<br>放在类上面，就是对这个类统一设置。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_03</title>
      <link href="/2018/10/14/spring-annotation-day-03/"/>
      <url>/2018/10/14/spring-annotation-day-03/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><h3 id="Scope注解"><a href="#Scope注解" class="headerlink" title="@Scope注解"></a>@Scope注解</h3><p>@Scope注解：是用来控制创建对象的作用域的，这里的作用域是我们平时所说的作用域。<br>这里是：单例模式、多例模式等。  </p><p>现在创建新的配置类com.liuzhuo.config.MainConfig2:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig2 &#123;<br><br>    @Bean(&quot;person&quot;)<br>    public Person person() &#123;<br>        return new Person(&quot;dengjie&quot;, 18);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在测试类IocTest中创建新的测试方法，test02：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test02() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>    //获取所有已经注入到容器中的Bean的id.<br>    String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();<br>    for (String name : beanDefinitionNames) &#123;<br>        System.out.println(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig2<br>person<br></code></pre></td></tr></table></figure><hr><p>现在我们修改配置类MainConfig2：<br>使用@Scope注解（作用域的功能）</p><p>@Scope可以使用四个值：<br>1.singleton：单例模式（<strong>默认值</strong>）<br>2.prototype：多例模式<br>3.request  ：一个request请求，创建一个新的实例<br>4.session  ：一个session请求，创建一个新的实例 </p><p>在配置类下的person方法上加入@Scope注解：   </p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig2 &#123;<br><br>    @Scope<br>    @Bean(&quot;person&quot;)<br>    public Person person() &#123;<br>        return new Person(&quot;dengjie&quot;, 18);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>现在修改test02测试方法，测试person是否是单例：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test02() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>    //获取所有已经注入到容器中的Bean的id.<br>    /*String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();<br>    for (String name : beanDefinitionNames) &#123;<br>        System.out.println(name);<br>    &#125;*/<br><br>    Object person = applicationContext.getBean(&quot;person&quot;);<br>    Object person2 = applicationContext.getBean(&quot;person&quot;);<br>    System.out.println(person == person2);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：true。注意：<strong>此时已经加载的是配置文件2了！！！</strong><br>说明@Scope默认是单例模式。</p><hr><p>现在修改成多例模式：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig2 &#123;<br><br>    @Scope(value = &quot;prototype&quot;)<br>    @Bean(&quot;person&quot;)<br>    public Person person() &#123;<br>        return new Person(&quot;dengjie&quot;, 18);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行测试方法test02：输出false。<br>说明：现在是多例模式。</p><hr><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>修改配置类，在person方法中加入一句输出语句。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig2 &#123;<br><br>    @Scope(value = &quot;singleton&quot;)<br>    @Bean(&quot;person&quot;)<br>    public Person person() &#123;<br>        System.out.println(&quot;加载person类到容器中~~~&quot;);<br>        return new Person(&quot;dengjie&quot;, 18);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>修改测试类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test02() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行测试方法：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">D:\Java1.8\bin\java -ea -Didea.test.cyclic.buffer.size=1048576 <br>加载person类到容器中~~~<br>true<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure><p>此时虽然只加载了容器类，但是person还是被加载到了容器中。<br>说明单例模式下，注入到容器中的类是立即注入的。不用到使用person类才注入到容器中来。</p><hr><p>现在讲单例变成多例模式，不改测试方法。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig2 &#123;<br><br>    @Scope(value = &quot;prototype&quot;)<br>    @Bean(&quot;person&quot;)<br>    public Person person() &#123;<br>        System.out.println(&quot;加载person类到容器中~~~&quot;);<br>        return new Person(&quot;dengjie&quot;, 18);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>此时啥也不输出！！!</strong></p><p>现在修改测试方法：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test02() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>  <br>    Object person = applicationContext.getBean(&quot;person&quot;);<br>    Object person2 = applicationContext.getBean(&quot;person&quot;);<br>    System.out.println(person == person2);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">加载person类到容器中~~~<br>加载person类到容器中~~~<br>false<br></code></pre></td></tr></table></figure></p><p>说明：多例是懒加载，只有等到获取person对象时，才会将person注入到容器中。</p><hr><h3 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h3><p>使用@Lazy注解来控制是否是懒加载。</p><p>修改配置类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig2 &#123;<br><br>    @Scope<br>    @Lazy<br>    @Bean(&quot;person&quot;)<br>    public Person person() &#123;<br>        System.out.println(&quot;加载person类到容器中~~~&quot;);<br>        return new Person(&quot;dengjie&quot;, 18);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>修改测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test02() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行测试方法：啥也不输出，说明此时已经是懒加载了。</p><hr><p>修改测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Test<br>public void test02() &#123;<br>    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);<br><br>    Object person = applicationContext.getBean(&quot;person&quot;);<br>    Object person2 = applicationContext.getBean(&quot;person&quot;);<br>    System.out.println(person == person2);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行测试方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">加载person类到容器中~~~<br>true<br></code></pre></td></tr></table></figure></p><p>此时是到使用person对象时，才会加载。并且只是加载了一次，因为是单例模式。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_02</title>
      <link href="/2018/10/13/spring-annotation-day-02/"/>
      <url>/2018/10/13/spring-annotation-day-02/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>接着day01天的内容，我们知道怎么使用java配置来初始化容器，使用@Configuration注解来标记一个java类就等同于了bean.xml文件了。</p><p>接下来，我们看看包扫描怎么配置，因为我们不可能给每个类都配置，那样太花时间和精力，所以我们需要包扫描的配置，来自动帮我们把需要的bean对象注入到容器中。</p><h3 id="一：xml版的包扫描"><a href="#一：xml版的包扫描" class="headerlink" title="一：xml版的包扫描"></a>一：xml版的包扫描</h3><hr><p>注意：这里在Bean.xml文件中需要配置命名空间,加上context的命名空间.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>       xsi:schemaLocation=&quot;<br>         http://www.springframework.org/schema/beans<br>         http://www.springframework.org/schema/beans/spring-beans.xsd<br>         http://www.springframework.org/schema/context<br>         http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;<br></code></pre></td></tr></table></figure></p><p>主要加入了xmlns:context=····和xsi:中的两个context(看结尾).</p><p>bean.xml配置文件加入了：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!--包扫描、只要标注了@Controller、@Service、@Repository、@Component都会自动注入到容器中--&gt;<br>&lt;!-- base-package包名，在该包下的子包也会被扫描--&gt;<br>&lt;context:component-scan base-package=&quot;com.liuzhuo&quot;/&gt;<br></code></pre></td></tr></table></figure></p><p>现在将bean.xml中的person配置注解掉。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!--以前的开发模式，使用配置文件--&gt;<br>&lt;!--&lt;bean id=&quot;person&quot; class=&quot;com.liuzhuo.bean.Person&quot;&gt;<br>    &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;<br>    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;<br>&lt;/bean&gt;--&gt;<br></code></pre></td></tr></table></figure></p><p>在Person类上面加入@Component注解。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Component<br>public class Person<br></code></pre></td></tr></table></figure></p><p>运行MainTest测试类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);<br>Person person = (Person) applicationContext.getBean(&quot;person&quot;);<br>System.out.println(person);<br></code></pre></td></tr></table></figure></p><p>输出:</p><p><code>Person{name=&#39;null&#39;, age=null}</code>  </p><p>说明包扫描成功!</p><hr><h3 id="二：java类版的包扫描"><a href="#二：java类版的包扫描" class="headerlink" title="二：java类版的包扫描"></a>二：java类版的包扫描</h3><hr><p>首先将xml版本中的包扫描注解掉。</p><p>在java配置类上加入@ComponentScan(value = “com.liuzhuo”)<br>value：就是扫描的具体包的路径。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@ComponentScan(value = &quot;com.liuzhuo&quot;) //包扫描<br>public class MainConfig &#123;<br>   ·····<br>&#125;<br></code></pre></td></tr></table></figure><p>创建com.liuzhuo.controller、com.liuzhuo.service包、com.liuzhuo.dao<br>并创建相应的java类，BookController，BookService，BookDao。如下：</p><p><img src="/images/20181013170247.png" style="width:50%;">  </p><p>并在相应的类上面标注相应的注解。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Controller<br>public class BookController &#123;<br>&#125;<br>-----------------------------<br>@Service<br>public class BookService &#123;<br>&#125;<br>-----------------------------<br>@Repository<br>public class BookDao &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要是@Controller、@Service、@Repository三个注解。  </p><p>现在在test文件夹下面的jave包下创建测试类。</p><p>com.liuzhuo.test.IocTest类。</p><p>并在pom.xml文件中加入依赖<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependency&gt;<br>    &lt;groupId&gt;junit&lt;/groupId&gt;<br>    &lt;artifactId&gt;junit&lt;/artifactId&gt;<br>    &lt;version&gt;4.12&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></p><p>在IocTest类中写入一下代码:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class IocTest &#123;<br><br>    @Test<br>    public void test01() &#123;<br>        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);<br>        //获取所有已经注入到容器中的Bean的id.<br>        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();<br>        for (String name : beanDefinitionNames) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>执行test01，结果：<br>除了spring内置的Bean对象外，主要有以下我们自己定义的Bean对象的id名<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>bookController<br>bookDao<br>bookService<br>person01<br></code></pre></td></tr></table></figure></p><hr><h3 id="三、-ComponentScan的用法"><a href="#三、-ComponentScan的用法" class="headerlink" title="三、@ComponentScan的用法"></a>三、@ComponentScan的用法</h3><p>上面，我们已经初步了解了@ComponentScan包扫描的基本用法了。<br>点击@ComponentScan注解。我们会看到<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Retention(RetentionPolicy.RUNTIME)<br>@Target(&#123;ElementType.TYPE&#125;)<br>@Documented<br>@Repeatable(ComponentScans.class)<br>public @interface ComponentScan &#123;<br>    @AliasFor(&quot;basePackages&quot;)<br>    String[] value() default &#123;&#125;;<br>    ····<br>&#125;<br></code></pre></td></tr></table></figure></p><p>value这个字段，说明是一个字符串类型的数组。说明value值，我们可以填写多个值，数组的话，用大花括号来表示，{}.每个值用逗号，来隔开。</p><p>ps:提一个小技巧，在idea中，Alt+7可以查看这个类中所有的字段和方法。</p><p>我们可以看到其中有一个includeFilters()的字段。<br><img src="/images/20181013173018.png" style="width:50%"></p><p>ComponentScan.Filter[] includeFilters() default {};</p><p>看到includeFilters也是一个数组，类型是ComponentScan的内部类Filter。<br>点击Filter，发现也是一个注解.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Retention(RetentionPolicy.RUNTIME)<br>    @Target(&#123;&#125;)<br>    public @interface Filter &#123;<br>        FilterType type() default FilterType.ANNOTATION;<br><br>        @AliasFor(&quot;classes&quot;)<br>        Class&lt;?&gt;[] value() default &#123;&#125;;<br><br>        @AliasFor(&quot;value&quot;)<br>        Class&lt;?&gt;[] classes() default &#123;&#125;;<br><br>        String[] pattern() default &#123;&#125;;<br>    &#125;<br></code></pre></td></tr></table></figure></p><p>发现有一个类型和字节码类的字段。</p><p><strong>1.includeFilters</strong></p><p>现在我们来使用这个includeFilters来在包扫描的时候，只扫描我们相要的类。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = &#123;<br>        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)<br>&#125;) //包扫描<br></code></pre></td></tr></table></figure></p><p>type是来说明过滤的类型的，这里的类型是注解(FilterType.ANNOTATION)。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public enum FilterType &#123;<br>    ANNOTATION,<br>    ASSIGNABLE_TYPE,<br>    ASPECTJ,<br>    REGEX,<br>    CUSTOM;<br><br>    private FilterType() &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总共有以上五个类型。<br>ANNOTATION：注解类型<br>ASSIGNABLE_TYPE：赋值类型</p><hr><p>运行test01类，发现结果还是<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>bookController<br>bookDao<br>bookService<br>person01<br></code></pre></td></tr></table></figure></p><p>是配置出现问题了嘛？不是，是因为我们忘记了，包扫描，默认是配置是扫描所有，所以，我们只需要将默认的配置设置为false就好了。<br>useDefaultFilters = false</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = &#123;<br>        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)<br>&#125;,useDefaultFilters = false) //包扫描<br>public class MainConfig<br></code></pre></td></tr></table></figure><p>结果为：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>bookController<br>person01<br></code></pre></td></tr></table></figure></p><p><strong>2.excludeFilters</strong></p><p>excludeFilters：是和includeFilters对着来的，是排除哪些类不扫描。</p><p>具体的配置情况如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@ComponentScan(value = &quot;com.liuzhuo&quot;, excludeFilters = &#123;<br>        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)<br>&#125;) //包扫描<br>public class MainConfig<br></code></pre></td></tr></table></figure></p><p>输出结果为：将@Controller注解的类就没有扫描。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>bookDao<br>bookService<br>person01<br></code></pre></td></tr></table></figure></p><p>总结：<br>@ComponentScan value:指定要扫描的包<br>jdk1.8中@ComponentScan是可重复的，所以可以写两个@ComponentScan<br>不过，可以使用@ComponentScans来配置多个@ComponentScan<br>excludeFilters = Filter[]: 指定扫描的时候按照什么规则排除哪些组件<br>includeFilters = Filter[]: 指定扫描的时候只需要包含哪些组件<br>ps:includeFilters,需要将默认的配置设置为false。(useDefaultFilters = false)</p><hr><h3 id="四、详解Filter的类型"><a href="#四、详解Filter的类型" class="headerlink" title="四、详解Filter的类型"></a>四、详解Filter的类型</h3><p>FilterType.ANNOTATION        按照注解<br>FilterType.ASSIGNABLE_TYPE   按照给定的类型<br>FilterType.ASPECTJ           使用ASPECTJ表达式<br>FilterType.REGEX             使用正则表达式<br>FilterType.CUSTOM            使用自定义的规则</p><p>更新MainConfig类:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@ComponentScans(value = &#123;<br>        @ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = &#123;<br>                @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)<br>        &#125;, useDefaultFilters = false)<br>&#125;)<br>public class MainConfig<br></code></pre></td></tr></table></figure><p>现在的输出结果为：(包含有@Controller注解的类)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>bookController<br>person01<br></code></pre></td></tr></table></figure></p><p>现在我们使用FilterType.ASSIGNABLE_TYPE 类型(给定类的类型)</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@ComponentScans(value = &#123;<br>        @ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = &#123;<br>                @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = &#123;BookService.class&#125;)<br>        &#125;, useDefaultFilters = false)<br>&#125;)<br>public class MainConfig<br></code></pre></td></tr></table></figure><p>输出结果是只要BookService类型的就行，他的子类也行。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>bookService<br>person01<br></code></pre></td></tr></table></figure></p><p>现在我们使用自定义规则，FilterType.CUSTOM。</p><p>需要自己创建一个类并实现TypeFilter接口。(我放在com.liuzhuo.config包)</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyTypeFilter implements TypeFilter &#123;<br>    @Override<br>    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123;<br>        return false;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释一下：<br>1.metadataReader  读取到当前正在扫描的类的信息<br>2.metadataReaderFactory  可以获取到其他任何类信息</p><p>我们通过这两个参数可以获取很多当前扫描类的信息。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyTypeFilter implements TypeFilter &#123;<br>    @Override<br>    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123;<br><br>        //获取当前类的注解信息<br>        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();<br>        //获取当前正在扫描的类信息<br>        ClassMetadata classMetadata = metadataReader.getClassMetadata();<br>        //获取当前类的资源(类的路径)<br>        Resource resource = metadataReader.getResource();<br><br>        String className = classMetadata.getClassName();<br>        System.out.println(&quot;---&gt;&quot; + className);<br><br>        return false;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述的方法，我们可以打印出被扫描的类的名字；<br>在此之前，我们还需要修改MainConfig配置类：<br>将Filter类型改为自定义类型。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>@ComponentScans(value = &#123;<br>        @ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = &#123;<br>                @ComponentScan.Filter(type = FilterType.CUSTOM, classes = &#123;MyTypeFilter.class&#125;)<br>        &#125;, useDefaultFilters = false)<br>&#125;)<br>public class MainConfig<br></code></pre></td></tr></table></figure></p><p>运行test01测试类：<br>结果如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">---&gt;com.liuzhuo.test.IocTest<br>---&gt;com.liuzhuo.bean.Person<br>---&gt;com.liuzhuo.config.MyTypeFilter<br>---&gt;com.liuzhuo.controller.BookController<br>---&gt;com.liuzhuo.dao.BookDao<br>---&gt;com.liuzhuo.MainTest<br>---&gt;com.liuzhuo.service.BookService<br></code></pre></td></tr></table></figure></p><p>现在我们的MyTypeFilter返回都是false，所以被注入到容器的是<br>mainConfig<br>person01</p><p>现在，我们来更改MyTypeFilter类，我们只注入类名包含‘er’的类。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MyTypeFilter implements TypeFilter &#123;<br>    @Override<br>    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123;<br><br>        //获取当前类的注解信息<br>        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();<br>        //获取当前正在扫描的类信息<br>        ClassMetadata classMetadata = metadataReader.getClassMetadata();<br>        //获取当前类的资源(类的路径)<br>        Resource resource = metadataReader.getResource();<br><br>        String className = classMetadata.getClassName();<br>        System.out.println(&quot;---&gt;&quot; + className);<br><br>        if (className.contains(&quot;er&quot;)) return true;<br>        return false;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>其实就是加了一句代码：<br><code>if (className.contains(&quot;er&quot;)) return true;</code></p><p>运动test01测试类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">mainConfig<br>person<br>myTypeFilter<br>bookController<br>bookService<br>person01<br></code></pre></td></tr></table></figure></p><p>除了本来的mainConfig、person01是配置文件帮我注入的。<br>其他的注入的类都是类名包含‘er’的。</p><p><strong>ps：都是在包扫描@ComponentScan(value = “com.liuzhuo”)</strong><br><strong>com.liuzhuo包下的’er’.</strong></p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring_annotation_day_01</title>
      <link href="/2018/10/12/spring-annotation-01/"/>
      <url>/2018/10/12/spring-annotation-01/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong><br>开发流程：主要是使用idea来完成的，此教程是针对有spring开发经验的人看的。用来对比以前的配置文件来注入依赖和java类配置来注入依赖的区别。  </p><p>打开idea创建Maven工程，输入三个坐标，groupId，artifactId，version。<br>我们这里的三个坐标是:  </p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;groupId&gt;com.liuzhuo&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-annotation&lt;/artifactId&gt;<br>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;<br></code></pre></td></tr></table></figure><p>创建后的工程如下：<br><img src="/images/20181012212912.png" style="width:300px; heigh:300px"></p><hr><p>现在打开pom.xml文件:添加依赖如下<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;<br>            &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;<br>        &lt;/dependency&gt;<br>&lt;/dependencies&gt;<br></code></pre></td></tr></table></figure></p><p>更新pom文件，会自动导入jar包。 </p><hr><p>在src下的main下的java中创建Person类。我的包名是com.liuzhuo.bean<br>Person类中主要是两个字段，一个name，一个age，如图:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Person &#123;<br>    private String name;<br>    private Integer age;<br><br>    ···中间省略了无参、有参的构造函数和getter、setter方法以及toString方法.    <br>&#125;<br></code></pre></td></tr></table></figure></p><p>现在在main下的resources下创建bean.xml文件  </p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;<br><br>    &lt;!--以前的开发模式，使用配置文件--&gt;<br>    &lt;bean id=&quot;person&quot; class=&quot;com.liuzhuo.bean.Person&quot;&gt;<br>        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;<br>        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;<br>    &lt;/bean&gt;<br><br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><hr><p>现在在com.liuzhuo包下创建MainTest类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MainTest &#123;<br><br>    public static void main(String[] args) &#123;<br><br>        //以前的开发模式，使用xml来配置bean<br>        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);<br>        Person person = (Person) applicationContext.getBean(&quot;person&quot;);<br>        System.out.println(person);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><p>输出结果:就是在配置文件中的配置的person类。</p><p><code>Person{name=&#39;zhangsan&#39;, age=18}</code></p><hr><p>现在创建com.liuzhuo.config包，并创建MainConfig类:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//配置类==配置文件<br>@Configuration   //告诉spring这是一个配置类，用来生成bean<br>public class MainConfig &#123;<br><br>    //给容器中注册一个Bean；类型为返回值的类型，id默认为方法名<br>    @Bean<br>    public Person person() &#123;<br>        return new Person(&quot;lisi&quot;, 16);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><p>修改MainTest类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MainTest &#123;<br><br>    public static void main(String[] args) &#123;<br><br>        //以前的开发模式，使用xml来配置bean<br>        /*ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);<br>        Person person = (Person) applicationContext.getBean(&quot;person&quot;);<br>        System.out.println(person);*/<br><br>        //现在使用java类来配置上下文容器<br>        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig.class);<br>        Person person = context.getBean(Person.class);<br>        System.out.println(person);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><p>输出结果：是MainConfig类中配置Person类(@Bean注解的类) </p><p><code>Person{name=&#39;lisi&#39;, age=16}</code></p><p>在配置文件类必须使用@Configuration注解，然后再注入自己想要的Bean对象<br>创建一个方法，使用@Bean注解，返回值就是注入到容器中的Bean类型，默认情况下方法名就是注入到容器中的id。  </p><p>@Bean注解()中，可以输入参数，其中就有value来修改Bean的id名，如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class MainConfig &#123;<br><br>    //给容器中注册一个Bean；类型为返回值的类型，id默认为方法名<br>    @Bean(value = &quot;person01&quot;) //修改了Bean的id为person01<br>    public Person person() &#123;<br>        return new Person(&quot;lisi&quot;, 16);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>在MainTest文件中输入获取Person类的名字：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//现在使用java类来配置上下文容器<br>AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig.class);<br>Person person = context.getBean(Person.class);<br>System.out.println(person);<br><br>String[] beanNames = context.getBeanNamesForType(Person.class);<br>for(String name:beanNames)&#123;<br>   System.out.println(name);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果： </p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Person&#123;name=&apos;lisi&apos;, age=16&#125;<br>person01<br></code></pre></td></tr></table></figure><p>说明此时，Bean的id名字是被@Bean(value=”person01”)给替换了，不再是方法名person了。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown</title>
      <link href="/2018/10/12/markdown/"/>
      <url>/2018/10/12/markdown/</url>
      
        <content type="html"><![CDATA[<p> <strong>序言</strong>:<br></p><p></p><p>很久没有写日记了，以前只是在QQ空间写，现在觉得在自己的平台写日记还是感觉不错的，还是要多写博客来加强自己学习的知识，学的知识点感觉还是记不住，渐渐地让我明白，看的越多，懂的越少（你这话不是有毛病吗？应该是看的越多，懂的越多才对），此话怎讲，当你在茫茫的知识库里面东看西看的时候，很快就被海量的知识给淹没了，根本就不知道哪些是对的，哪些是错的，感觉好像这个也懂了，那个也懂了，但是真正写起来，脑子又一片空白，又好像什么都不懂，这种状态时有发生，这就叫不懂装懂，最根本的原因就是看的太多，写的太少，所以为了改掉这样毛病，把被动学习变成主动学习，接下来的日子，多写写，即使是写一些学习工作中遇到的坑也是好的，没事翻出来看看，还可以加深印象，好了，废话到处！<br></p><br>正文：<br><br><strong>一、标题的几种写法</strong>：<p></p><p><strong>第一种</strong>：<br></p><p>#一级标题<br></p><p>##二级标题<br></p><p>###三级级标题<br></p><p>####四级标题<br></p><p>#####五级标题<br></p><p>######六级标题<br><br><strong>说明：真正使用的时候，需要在#后加空格!!!!!</strong><br><br>效果:<br>   </p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级级标题"><a href="#三级级标题" class="headerlink" title="三级级标题"></a>三级级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p><strong>第二种</strong>：<br><br>  这是一级标题<br><br>  ======<br><br>  这是二级标题<br><br>  ———<br><br>这种只能表示一级和二级标题,==和–的数量个数没有限制，多少都行!!!<br>效果：<br></p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><p><strong>第三种</strong>：<br></p><p>#一级标题#<br></p><p>##二级标题##<br><br>其他几级标题类似，就是一个封闭的意思，也是注意#后面需要有空格!!!</p><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><p>那既然3种都可以使用，可不可以混合使用呢？我试了一下，是可以的，但是为了让页面标签的统一性，不建议混合使用，推荐使用第一种，比较简洁，全面</p><p>为了搞清楚原理，我特意在网上搜一下在线编写markdown的工具，发现实际上是把这些标签最后转化为html标签，如图：<br><br><img src="https://i.imgur.com/QSo6UUP.png" alt=""><br>在线地址请看这里:<a href="http://tool.oschina.net/markdown/" title="markdown在线编辑器" target="_blank" rel="noopener">markdown在线编辑器</a><br></p><hr><p><strong>二：列表</strong><br><br>1.无序列表：<br><br>*1<br><br>*2<br><br>*3<br><br>+1<br><br>+2<br><br>+3<br><br>-1<br><br>-2<br><br>-3<br><br>效果:<br></p><ul><li>1</li><li>2</li><li>3</li></ul><ul><li>1</li><li>2</li><li>3</li></ul><ul><li>1</li><li>2</li><li>3<br></li></ul><p>可以看到，无序列表可以用 * ， + ， - 来创建，用在线编辑器看，实际上是转换成了ul&gt;li ，所以使用哪个都可以，推荐使用*吧.<br><br><br>2.有序列表:<br><br>1.列表1<br>2.列表2<br>3.列表3</p><ol><li>列表1</li><li>列表2</li><li>列表3</li></ol><p>有序列表就相对简单一点，只有这一种方式，注意，数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的。</p><hr><p><strong>三：区块引用</strong><br>比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语句。使用&gt;  </p><ul><li>犯我帝国者，虽远必诛!  <blockquote><p>这是嘉文四世说的</p></blockquote></li></ul><p><strong>四：华丽的分割线</strong><br>分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以</p><hr><p><strong>五:图片</strong><br>图片也有2种方式：行内式和参数式.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">![我是图片](https://www.fdfdfdf.jpg)<br>[我是图片]: (https://www.fdfdfdf.jpg)<br>参数式图片，这里是[我是图片]<br></code></pre></td></tr></table></figure></p><p>用法跟链接的基本一样，唯一的不同就是，图片前面要写一个！（这是必须的），没什么好说的。</p><hr><p><strong>六：代码块</strong></p><p>这个就比较重要了，很多时候都需要展示出一些代码</p><p>如果代码量比较少，只有单行的话，可以用单反引号包起来，如下： </p><p>第一种：单行（两个）: ``</p><p><code>var js = new object();</code>  </p><p>要是多行这个就不行了，多行可以用3个 `</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">int a = 10;  <br>int b = 20;  <br>int sum = a + b;  <br>printf(&quot;%d&quot;,sum);<br></code></pre></td></tr></table></figure><hr><p><strong>七：强调</strong>  </p><p>*字体倾斜*<br>_字体倾斜_<br>**字体加粗**<br>__字体加粗__  </p><p>一个星号或者是一个下划线包起来，会转换为<code>&lt;em&gt;</code>倾斜，如果是2个，会转换为<code>&lt;strong&gt;</code>加粗</p><hr><p><strong>八：转义</strong>  </p><p> \：转义符号，和js一样。</p><hr><p><strong>九：删除线</strong>  </p><p>~~请删除我~~:</p><p><del>请删除我</del>  </p><hr><p><strong>十：html原始码</strong> </p><p>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理.</p><hr><p>常用的基本上就这些了，如果还有一些常用的，可以跟我留言，我补充上去. </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>新文章</title>
      <link href="/2018/10/11/my-new-post/"/>
      <url>/2018/10/11/my-new-post/</url>
      
        <content type="html"><![CDATA[<p>这是作者的第一篇文章，主要是为了纪念自己的博客!!</p><hr><p>欢迎大家在此篇文章下面评论，我会尽量回复大家的问题。</p><p>不管是生活上面的，还是学习上面的疑惑都可以提</p><p>一段故事温柔人心，爱分享爱解忧，么么哒~~</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>  <img src="/images/gakki.png"></p><p>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;本人只是一个即将毕业的程序猿小哥哥，由于秋招结束，闲暇时间搭建了这个平台，只为给自己的生活增添一点乐趣。</p><p></p><p>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;本人也是Gakki酱的脑残粉，非常喜欢她的微笑，看了好多她的电视剧，比如：父女七日变、恋空、花水木、逃避虽可耻但有用、Legal High、全开女孩等，欢迎大家关注我的<a href="https://weibo.com/p/1005053310889015/home/" target="_blank" rel="noopener">微博</a>，比心~~~</p><p></p><p>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;平时喜欢的娱乐是打篮球和逛B站，对二次元有着一定的情怀，B站也给我机会，为了生活放弃了机会，不知道是对还是错，只能一路走到黑了。游戏的话，英雄联盟也陪伴了我的大学生活，现在都不怎么玩了，最多玩玩荣耀和吃鸡，但是还是少了当初那种在网吧5连坐开黑的感觉，我觉得人生最大的乐趣莫过于回忆，等老了，和老伴坐在板凳上面，说着过去的回忆，想想就很幸福。</p><p></p><p>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;作为一个程序员对技术不感兴趣，说来也惭愧，平时我也会更新自己的技术博客的，为了生活，不容易，fighting~</p><p></p><p>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;最后放一段爱豆的视频让大家欣赏一下，萨拉拉~</p><p></p>  <iframe src="//player.bilibili.com/player.html?aid=23675732&cid=39547539&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="80%" height="500px" style="margin-left:30px"><br>  </iframe>]]></content>
      
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
  
</search>
